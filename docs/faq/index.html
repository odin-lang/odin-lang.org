<!doctype html><html>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<link rel=icon href=/favicon.svg>
<meta name=color-scheme content="only dark">
<meta property="og:title" content="Frequently Asked Questions">
<meta property="og:description" content="Answers to commonly asked questions about Odin.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://odin-lang.org/docs/faq/">
<meta property="og:image" content="https://odin-lang.org/images/logo-slim.png">
<link rel=stylesheet href=https://odin-lang.org/scss/custom.min.css>
<link rel=stylesheet href=/lib/highlight/styles/github-dark.min.css>
<script src=/lib/highlight/highlight.min.js></script>
<script>hljs.registerLanguage("odin",function(a){return{aliases:["odin","odinlang","odin-lang"],keywords:{keyword:"auto_cast bit_field bit_set break case cast context continue defer distinct do dynamic else enum fallthrough for foreign if import in map matrix not_in or_else or_return package proc return struct switch transmute type_of typeid union using when where",literal:"true false nil",built_in:"abs align_of cap clamp complex conj expand_to_tuple imag jmag kmag len max min offset_of quaternion real size_of soa_unzip soa_zip swizzle type_info_of type_of typeid_of"},illegal:"</",contains:[a.C_LINE_COMMENT_MODE,a.C_BLOCK_COMMENT_MODE,{className:"string",variants:[a.QUOTE_STRING_MODE,{begin:"'",end:"[^\\\\]'"},{begin:"`",end:"`"}]},{className:"number",variants:[{begin:a.C_NUMBER_RE+"[ijk]",relevance:1},a.C_NUMBER_MODE]}]}})</script>
<script>hljs.highlightAll()</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-67516878-2"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','UA-67516878-2')</script>
<link href=/css/style.css rel=stylesheet>
<title>Frequently Asked Questions | Odin Programming Language </title>
<link rel=alternate type=application/rss+xml href=https://odin-lang.org/categories/newsletter/index.xml title="Odin Newsletter"><body data-bs-spy=scroll data-bs-target=#TOC data-bs-offset=0 tabindex=0>
<script>window.localStorage.getItem("theme")||window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches&&(window.localStorage.setItem("theme","dark"),document.body.classList.add("dark-mode")),window.localStorage.getItem("theme")==="dark"&&document.body.classList.add("dark-mode");function toggleDarkMode(){document.body.classList.toggle("dark-mode")?window.localStorage.setItem("theme","dark"):window.localStorage.setItem("theme","light")}</script><header class=sticky-top>
<nav class="navbar navbar-expand-lg navbar-dark bg-primary odin-menu">
<div class=container-xxl>
<a class=navbar-brand href=/>
<img src=/logo.svg height=30 alt=Odin id=navbar-logo>
</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#odin-navbar-content aria-controls=odin-navbar-content aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span>
</button>
<div class="collapse navbar-collapse" id=odin-navbar-content>
<ul class="navbar-nav ms-md-auto">
<li class=nav-item>
<a class=nav-link href=/>Home</a>
</li>
<li class=nav-item>
<a class="nav-link active" href=/docs aria-current=page>Docs</a>
</li>
<li class=nav-item>
<a class=nav-link href=https://pkg.odin-lang.org/>Packages</a>
</li>
<li class=nav-item>
<a class=nav-link href=/news>News</a>
</li>
<li class=nav-item>
<a class=nav-link href=/showcase>Showcase</a>
</li>
<li class=nav-item>
<a class=nav-link href=https://forum.odin-lang.org>Forum</a>
</li>
<li class=nav-item>
<a class=nav-link href=/community>Community</a>
</li>
<li class=nav-item>
<a class=nav-link href=https://github.com/odin-lang/Odin target=_blank>GitHub</a>
</li>
<li class=nav-item>
<a class="nav-link btn-dark-mode" onclick=toggleDarkMode() title="Toggle Light/Dark Mode">
<span class=dark-mode-appearance>Appearance:</span><svg fill="#fff" id="dark-mode-icon" viewBox="0 0 384 512"><path d="M223.5 32C1e2 32 0 132.3.0 256S1e2 480 223.5 480c60.6.0 115.5-24.2 155.8-63.4 5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6-96.9.0-175.5-78.8-175.5-176 0-65.8 36-123.1 89.3-153.3 6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"/></svg><svg fill="#fff" id="light-mode-icon" viewBox="0 0 16 16"><path d="M8 12a4 4 0 100-8 4 4 0 000 8M8 0a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 0m0 13a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 13m8-5a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2a.5.5.0 01.5.5M3 8a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2A.5.5.0 013 8m10.657-5.657a.5.5.0 010 .707l-1.414 1.415a.5.5.0 11-.707-.708l1.414-1.414a.5.5.0 01.707.0m-9.193 9.193a.5.5.0 010 .707L3.05 13.657a.5.5.0 01-.707-.707l1.414-1.414a.5.5.0 01.707.0m9.193 2.121a.5.5.0 01-.707.0l-1.414-1.414a.5.5.0 01.707-.707l1.414 1.414a.5.5.0 010 .707M4.464 4.465a.5.5.0 01-.707.0L2.343 3.05a.5.5.0 11.707-.707l1.414 1.414a.5.5.0 010 .708"/></svg>
</button>
</a>
</li>
</ul>
</div>
</div>
</nav>
</header>
<main>
<div class=container-xxl>
<div class="row odin-main">
<nav class="col-lg-2 odin-sidebar-border navbar-light">
<div class="sticky-top odin-below-navbar py-3">
<ul class="nav nav-pills d-flex flex-column">
<li class=nav-item>
<a class=nav-link href=/docs/install/>Getting Started</a>
</li>
<li class=nav-item>
<a class=nav-link href=/docs/overview/>Overview</a>
</li>
<li class=nav-item>
<a class="nav-link active" href=/docs/faq/ aria-current=page>FAQ</a>
</li>
<li class=nav-item>
<a class=nav-link href=/docs/packages/>Packages</a>
</li>
<li class=nav-item>
<a class=nav-link href=/docs/nightly/>Nightly Builds</a>
</li>
<li class=nav-item>
<a class=nav-link href=/docs/testing/>Running Tests</a>
</li>
</ul>
</div>
</nav>
<article class="col-lg-8 p-4">
<header>
<nav aria-label=breadcrumb>
<ol class=breadcrumb>
<li class=breadcrumb-item><a href=/docs>Docs</a></li>
<li class=breadcrumb-item><a href=/docs/faq>Faq</a></li>
</ol>
<h1>Frequently Asked Questions</h1>
</header>
<div class=odin-article>
<h2 id=general>General <a class=text-decoration-none href=#general>#</a></h2>
<h3 id=what-is-the-history-of-the-project>What is the history of the project? <a class=text-decoration-none href=#what-is-the-history-of-the-project>#</a></h3>
<p>The project started one evening in late July 2016 when Ginger Bill was annoyed with programming in C++. The language began as a Pascal clone (with <code>begin</code> and <code>end</code> and more) but changed quite quickly to become something else.</p>
<p>Bill originally tried to create a preprocessor for C to augment and add new capabilities to the language. However, he found this endeavour a dead-end. That evening was the point at which Bill decided to create an entirely new language from scratch instead of trying to augment C.</p>
<h3 id=what-have-been-the-major-influences-in-the-languages-design>What have been the major influences in the language&rsquo;s design? <a class=text-decoration-none href=#what-have-been-the-major-influences-in-the-languages-design>#</a></h3>
<p>The language borrows heavily from (in order of philosophy and impact): <a href=https://wikipedia.org/wiki/Pascal_(programming_language)>Pascal</a>, <a href=https://wikipedia.org/wiki/C_(programming_language)>C</a>, <a href=https://en.wikipedia.org/wiki/Go_(programming_language)>Go</a>, <a href=https://en.wikipedia.org/wiki/Oberon-2>Oberon-2</a>, <a href=https://en.wikipedia.org/wiki/Newsqueak>Newsqueak</a>, <a href=https://en.wikipedia.org/wiki/OpenGL_Shading_Language>GLSL</a>.</p>
<p><a href=https://en.wikipedia.org/wiki/Niklaus_Wirth>Niklaus Wirth</a> and <a href=https://en.wikipedia.org/wiki/Rob_Pike>Rob Pike</a> have been the programming language design idols throughout this project.</p>
<h3 id=how-is-odin-licensed>How is Odin licensed? <a class=text-decoration-none href=#how-is-odin-licensed>#</a></h3>
<p>The Odin compiler and the library are under the <a href=https://github.com/odin-lang/Odin/blob/master/LICENSE>BSD 3-Clause license</a>.</p>
<h3 id=does-odin-have-any-third-party-library>Does Odin have any third-party library? <a class=text-decoration-none href=#does-odin-have-any-third-party-library>#</a></h3>
<p>Check out a few selected libraries at <a href=https://github.com/odin-lang/Odin/wiki/Odin-Libs>https://github.com/odin-lang/Odin/wiki/Odin-Libs</a>.</p>
<h3 id=what-are-the-guiding-principles-behind-the-design-of-odin>What are the guiding principles behind the design of Odin? <a class=text-decoration-none href=#what-are-the-guiding-principles-behind-the-design-of-odin>#</a></h3>
<ul>
<li>Simplicity and readability</li>
<li>Minimal: there ought to be one way to write something</li>
<li>Striving for orthogonality</li>
<li>Programs are about transforming data into other forms of data
<ul>
<li>Code is about expressing algorithms&mdash;not the type system</li>
</ul>
</li>
<li>There is embedded knowledge and wisdom in older programming languages</li>
<li>The entire language specification should be possible to be memorized by a mere mortal</li>
</ul>
<h3 id=what-does-odin-offer-over-other-languages>What does Odin offer over other languages? <a class=text-decoration-none href=#what-does-odin-offer-over-other-languages>#</a></h3>
<p>A quick overview of features (in no particular order):</p>
<ul>
<li>Full UTF-8 Support</li>
<li>Custom allocators that are simple to use:
<ul>
<li>Memory arenas/regions, pools, stacks, etc. which can be easily added</li>
</ul>
</li>
<li><a href=#context-system>Context system</a> for allocations, logging, and thread data</li>
<li>Built-in types and procedures that take advantage of the context system:
<ul>
<li><code>new(type)</code>, and <code>make</code> use the context&rsquo;s allocator (unless explicitly given)</li>
<li>Dynamic arrays and hash maps (<code>[dynamic]int</code> and <code>map[string]int</code>)</li>
</ul>
</li>
<li>Array programming
<ul>
<li><code>a, b: [4]f32; c := a * b</code></li>
<li><code>i := a.x * b.y</code></li>
<li><code>v := swizzle(a, 1, 2, 0)</code></li>
</ul>
</li>
<li><a href=#why-does-odin-have-explicit-procedure-overloading-but-not-implicit-procedure-overloading>Explicit procedure overloading</a></li>
<li>Introspection on all types</li>
<li>High control over memory layout
<ul>
<li>Alignment</li>
<li>Field offsets</li>
<li>Endianness</li>
<li>Data sizes</li>
</ul>
</li>
<li>Endian specific integer types (useful for specific data formats)
<ul>
<li><code>u32le</code></li>
<li><code>u64be</code></li>
</ul>
</li>
<li>Decent <a href=#packages>package</a> system and file handling</li>
<li>No <em>bad</em> preprocessor</li>
<li>Type inference
<ul>
<li><code>x: int = 1</code></li>
<li><code>x := 1 // x is deduced to be an int</code></li>
</ul>
</li>
<li><code>using</code>
<ul>
<li>making everything a namespace (similar to Pascal&rsquo;s <code>with</code> but on steroids)</li>
<li>Ability to have <a href=#is-odin-an-object-oriented-language>subtype polymorphism</a></li>
</ul>
</li>
<li>Multiple return values</li>
<li>Clean, consistent, and fast to parse syntax</li>
<li>No need for procedure prototypes</li>
<li><a href=/docs/overview/#defer-statement><code>defer</code> statements</a>
<ul>
<li>defer a statement until the end of scope (akin to D&rsquo;s <code>scope(exit)</code>)</li>
</ul>
</li>
<li>Nested procedures and types</li>
<li>Tagged unions and untagged unions</li>
<li>Ranged <code>for</code> loops</li>
<li><a href=/docs/overview/#branch-statements>Labelled branches</a>
<ul>
<li><code>break label_name</code></li>
</ul>
</li>
<li><code>break</code> by default in <code>switch</code> statements
<ul>
<li>Explicit <code>fallthrough</code></li>
</ul>
</li>
<li>&ldquo;Raw&rdquo; strings
<ul>
<li><code>x := `what "the" string?`</code></li>
</ul>
</li>
<li><code>cstring</code> for legacy use</li>
<li><a href=/docs/overview/#parametric-polymorphism>Parametric polymorphism</a> (&ldquo;generics&rdquo;)</li>
<li><a href=/docs/overview/#foreign-system>Foreign system</a></li>
<li>Compile time <a href=/docs/overview/#when-statement><code>when</code> statements</a></li>
<li>Bounds checking which is togglable at the statement level:
<ul>
<li><code>#no_bounds_check</code> <code>#bounds_check</code></li>
</ul>
</li>
<li><code>i128</code> and <code>u128</code> support</li>
</ul>
<p>And lots more!</p>
<h2 id=design>Design <a class=text-decoration-none href=#design>#</a></h2>
<h3 id=why-does-odin-not-have-feature-x>Why does Odin not have feature X? <a class=text-decoration-none href=#why-does-odin-not-have-feature-x>#</a></h3>
<p>Odin was designed with the ideas of simplicity, clarity, speed of compilation, orthogonality of concepts, and for high performance. Feature X may be missing because it does not meet these basic ideas.</p>
<p>If you honestly believe that Odin is missing feature X, please investigate what features Odin does have and you may be able to find intriguing ways to solve your problem in the lack of feature X.</p>
<h3 id=why-does-odin-not-have-exceptions>Why does Odin not have exceptions? <a class=text-decoration-none href=#why-does-odin-not-have-exceptions>#</a></h3>
<p>Coupling exceptions to a control structure, as in the try-catch-finally idiom, complicates the understanding of the program.</p>
<p>Odin uses plain error handling through the use of multiple return values. It is clear which procedure the error value is from compared to a <code>try-catch</code> approach which is akin to the <a href=https://en.wikipedia.org/wiki/COMEFROM>COMEFROM</a> statement.</p>
<p>Please see gingerBill&rsquo;s article for more information: <a href=https://www.gingerbill.org/article/2018/09/05/exceptions-and-why-odin-will-never-have-them/>Exceptions — And Why Odin Will Never Have Them</a>.</p>
<h2 id=types>Types <a class=text-decoration-none href=#types>#</a></h2>
<h3 id=is-odin-an-object-oriented-language>Is Odin an object oriented language? <a class=text-decoration-none href=#is-odin-an-object-oriented-language>#</a></h3>
<p>No. Data structures are just data.</p>
<p>Subtype polymorphism is possible through the use of <code>using</code> but Odin does not offer methods.</p>
<pre><code class=language-odin data-lang=odin>Base :: struct {...}
Derived :: struct {
    using base: Base,
    name: string,
}
Derived_By_Ptr :: struct {
    name: string,
    // `using` can be applied anywhere and even to a pointer.
    // This allows for a huge amount of control over the memory
    // layout of the data structure.
    using base: ^Base,
}
</code></pre><p>This idiom allows the user to create a virtual procedure table if they do wish, akin to C, but in a nicer way by having more control over the memory layout and field access.</p>
<h3 id=why-does-odin-not-have-uniform-function-call-syntax-ufcs>Why does Odin not have Uniform Function Call Syntax (UFCS)? <a class=text-decoration-none href=#why-does-odin-not-have-uniform-function-call-syntax-ufcs>#</a></h3>
<p>The main reason is that it does not make any sense in Odin.</p>
<p>It is not &ldquo;uniform&rdquo; as Odin does not have the concept of a method. Odin also has the concept of import names for packages: this means procedures are declared within different scopes, meaning it would not make any sense syntactically.</p>
<p>One of Odin&rsquo;s goals is simplicity and striving to only offer one way to do things, to improve clarity. <code>x.f(y)</code> meaning <code>f(x, y)</code> is ambiguous as <code>x</code> may have a field called <code>f</code>. It is not at all clear what this means.</p>
<p>Very early on during Odin&rsquo;s development (circa. 2017), infix and suffix syntax for procedure calls was experimented with, but they were soon removed as it was found in practice that they were virtually never used nor did they actually aid with code clarity either.</p>
<p>One of the main reasons people want UFCS is to allow for &ldquo;dot-autocomplete&rdquo; in many IDEs, allowing the ability to show a list available procedures, dependent on the context. It is entirely possible to have this with normal procedure call syntax but most IDEs just do not do it for whatever reason.</p>
<h3 id=why-does-odin-have-explicit-procedure-overloading-but-not-implicit-procedure-overloading>Why does Odin have explicit procedure overloading but not implicit procedure overloading? <a class=text-decoration-none href=#why-does-odin-have-explicit-procedure-overloading-but-not-implicit-procedure-overloading>#</a></h3>
<p>The design goals of Odin were explicitness and simplicity. Implicit procedure overloading complicates the scoping system. In C++, you cannot nest procedures within procedures so all procedure look-ups are done at the global scope. In Odin, procedures can be nested within procedures and as a result, determining which procedure should be used, in the case of implicit overloading, is complex.</p>
<p>Explicit overloading has many advantages:</p>
<ul>
<li>Explicitness of what is overloaded</li>
<li>Able to refer to the specific procedure if needed</li>
<li>Clear which scope the entity name belongs to</li>
</ul>
<pre><code class=language-odin data-lang=odin>foo :: proc{
    foo_bar,
    foo_baz,
    foo_baz2,
    another_thing_entirely,
}
</code></pre><h3 id=why-does-odin-not-have-operator-overloading>Why does Odin not have operator overloading? <a class=text-decoration-none href=#why-does-odin-not-have-operator-overloading>#</a></h3>
<p>The design goals of Odin were explicitness and simplicity. Operator overloading is very easily abused and can be used to do many magical things. A procedure is clearer and more explicit.</p>
<p>Array programming is available in Odin; this removes some of the need for operator overloading when creating mathematical libraries.</p>
<h3 id=what-does-distinct-do>What does <code>distinct</code> do? <a class=text-decoration-none href=#what-does-distinct-do>#</a></h3>
<p><code>distinct</code> makes a type declaration distinct from its base type.</p>
<pre><code class=language-odin data-lang=odin>Int_Alias :: int
#assert(Int_Alias == int)

My_Int :: distinct int
#assert(My_Int != int)
</code></pre><h3 id=what-is-the-type-of-x-in-x--123>What is the type of <code>x</code> in <code>x := 123</code>? <a class=text-decoration-none href=#what-is-the-type-of-x-in-x--123>#</a></h3>
<p><code>123</code> is an untyped integer literal: if the type has not been specified in the declaration, the default type for the &ldquo;untyped&rdquo; type will be chosen. In this case, <code>x</code> will be of type <code>int</code>.</p>
<table>
<thead>
<tr>
<th>Untyped type</th>
<th>Default Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td><code>bool</code></td>
</tr>
<tr>
<td>integer</td>
<td><code>int</code></td>
</tr>
<tr>
<td>float</td>
<td><code>f64</code></td>
</tr>
<tr>
<td>complex</td>
<td><code>complex128</code></td>
</tr>
<tr>
<td>quaternion</td>
<td><code>quaternion256</code></td>
</tr>
<tr>
<td>rune</td>
<td><code>rune</code></td>
</tr>
<tr>
<td>string</td>
<td><code>string</code></td>
</tr>
<tr>
<td>nil</td>
<td>*</td>
</tr>
<tr>
<td>undef</td>
<td>*</td>
</tr>
<tr>
<td>type (not first class)</td>
<td>*</td>
</tr>
</tbody>
</table>
<p>* if there is no default type for the untyped type, the type of the value cannot be inferred and this will cause an error.</p>
<h3 id=what-is-the-size-of-int>What is the size of <code>int</code>? <a class=text-decoration-none href=#what-is-the-size-of-int>#</a></h3>
<p><code>size_of(int) = size_of(uint) = size_of(rawptr)</code>. For portability, code that relies on a particular size of value should use an explicitly sized type, like <code>i64</code>. <code>int</code> and <code>uint</code> are guaranteed to be big enough to represent a pointer; however, please use <code>uintptr</code> to represent a pointer.</p>
<p>Floating-point types and complex types are always sized, because the programmer should be aware of precision.</p>
<h3 id=which-of-f32-and-f64-should-i-prefer-for-floating-point-mathematics>Which of <code>f32</code> and <code>f64</code> should I prefer for floating-point mathematics? <a class=text-decoration-none href=#which-of-f32-and-f64-should-i-prefer-for-floating-point-mathematics>#</a></h3>
<p>The choice is dependent on the purpose of the program. The default floating point type is <code>f64</code> so if in doubt, prefer <code>f64</code>.</p>
<h3 id=what-is-rune>What is <code>rune</code>? <a class=text-decoration-none href=#what-is-rune>#</a></h3>
<p>A <code>rune</code> is a basic type that is used to represent individual Unicode code points. It is equivalent to an <code>i32</code> internally but they are not the same type.</p>
<p>Character literals such as <code>'g'</code>, <code>'芋'</code>, and <code>'\u0123'</code> are all untyped runes, with the default type <code>rune</code>. Character literals can be used as numbers and can convert to any number type.</p>
<h2 id=values>Values <a class=text-decoration-none href=#values>#</a></h2>
<h3 id=why-does-odin-not-have-implicit-numeric-type-conversions>Why does Odin not have implicit numeric type conversions? <a class=text-decoration-none href=#why-does-odin-not-have-implicit-numeric-type-conversions>#</a></h3>
<p>Implicit conversions complicate things and would be difficult to make consistent across architectures. To increase portability and to simplify the language, Odin uses explicit conversion.</p>
<p>In C, the convenience provided by implicit numeric type conversion is outweighed by the confusion it causes. There are many rules in C which are not at all obvious nor simple to the reader of the code (e.g. is this expression unsigned? does this expression over/under-flow? etc).</p>
<p>The exceptions to this are that: all pointer types can automatically coerce to a <code>rawptr</code>, and untyped constants can be converted to a type - if that conversion is valid. The constant system does reduce a lot of the issues regarding types as &ldquo;numbers just work&rdquo;; there is no need for literal suffixes like in C.</p>
<p>Most programmers spend most of their time <em>reading</em> code; not <em>writing</em> code. And that has been a big design in Odin: making it clear to the reader what is going on in the program. In most cases Odin has been optimized for the <em>reader</em> of code more than the <em>writer</em> of code; as a result this can annoy the <em>writer</em> in certain cases when there requires a lot of explicit type conversions.</p>
<h3 id=why-are-slices-dynamic-arrays-and-maps-references-whilst-arrays-are-values>Why are slices, dynamic arrays, and maps references whilst arrays are values? <a class=text-decoration-none href=#why-are-slices-dynamic-arrays-and-maps-references-whilst-arrays-are-values>#</a></h3>
<p>This is mostly because it &ldquo;felt&rdquo; right and is very convenient. Having them as values would require many allocations and may even require automatic memory management to handle correctly.</p>
<h2 id=procedures>Procedures <a class=text-decoration-none href=#procedures>#</a></h2>
<h3 id=why-is-it-named-proc>Why is it named <code>proc</code>? <a class=text-decoration-none href=#why-is-it-named-proc>#</a></h3>
<p><em>Procedure</em> used to be the common term as opposed to a function or subroutine. A function is a mathematical entity that has no side effects. A subroutine is something that has side effects but does not return anything.</p>
<p>A procedure is a superset of functions and subroutines. A procedure may or may not return something. A procedure may or may not have side effects.</p>
<h3 id=why-does-odin-not-have-any-methods>Why does Odin not have any methods? <a class=text-decoration-none href=#why-does-odin-not-have-any-methods>#</a></h3>
<p>We believe that data and code should be separate concepts; data should not have &ldquo;behaviour&rdquo;.</p>
<p>Use a procedure.</p>
<h3 id=how-do-i-define-a-procedure-with-a-different-calling-convention>How do I define a procedure with a different calling convention? <a class=text-decoration-none href=#how-do-i-define-a-procedure-with-a-different-calling-convention>#</a></h3>
<pre><code class=language-odin data-lang=odin>proc &quot;c&quot; ()
proc &quot;cdecl&quot; ()
proc &quot;stdcall&quot; ()
proc &quot;fastcall&quot; ()
proc &quot;odin&quot; ()
proc &quot;contextless&quot; ()
proc &quot;naked&quot; ()
</code></pre><h3 id=does-odin-have-closures>Does Odin have closures? <a class=text-decoration-none href=#does-odin-have-closures>#</a></h3>
<p>Odin only has non-capturing lambda procedures. For closures to work correctly would require a form of automatic memory management which will never be implemented into Odin.</p>
<pre><code class=language-odin data-lang=odin>foo :: proc() {
    y: int
    x := proc() -&gt; int {
        // `y` is not available in this scope as it is in a different stack frame
        return 123
    }
}
</code></pre><h3 id=why-are-maps-built-in>Why are maps built-in? <a class=text-decoration-none href=#why-are-maps-built-in>#</a></h3>
<p>The same reason why strings and dynamic arrays are: they are such a useful, powerful, and important data structure that providing an excellent first class implementation with syntactic support makes programming more of a joy. Odin&rsquo;s main implementation of <code>map</code> types are strong for the vast majority of use cases. If something specific is needed, it is possible to write your own but it will not benefit from the same convenient syntax. We believe that this is a reasonable trade-off between clarity and flexibility.</p>
<h2 id=context-system>Context System <a class=text-decoration-none href=#context-system>#</a></h2>
<h3 id=what-is-the-context-system-for>What is the context system for? <a class=text-decoration-none href=#what-is-the-context-system-for>#</a></h3>
<p>In each scope, there is an implicit value named <code>context</code>. This <code>context</code> variable is local to each scope and is implicitly passed by pointer to any procedure call in that scope (if the procedure has the Odin calling convention).</p>
<p>The main purpose of the implicit context system is for the ability to intercept third-party code and libraries and modify their functionality. One such case is modifying how a library allocates something or logs something. In C, this was usually achieved with the library defining macros which could be overridden so that the user could define what they wanted. However, not many libraries supported this in many languages by default which meant intercepting third-party code to see what it does and to change how it does it is not possible.</p>
<p>Please see the overview section on the <a href=/docs/overview/#implicit-context-system>implicit context system</a> for more information.</p>
<h2 id=pointers-and-allocation>Pointers and Allocation <a class=text-decoration-none href=#pointers-and-allocation>#</a></h2>
<h3 id=when-are-procedure-parameters-passed-by-value>When are procedure parameters passed by value? <a class=text-decoration-none href=#when-are-procedure-parameters-passed-by-value>#</a></h3>
<p>In Odin, procedure parameters are immutable values. This allows Odin to optimize how procedure values are passed. If it is more efficient to pass them by value (making a copy) or more efficient to pass them as an immutable pointer internally, it does not matter from a user perspective as the parameter value is immutable (because of the Odin calling conventions).</p>
<p>Passing a pointer value makes a copy of the pointer, not the data it points to. Slices, dynamic arrays, and maps behave like pointers in this case (internally they are structures that contain values, which include pointers and the &ldquo;structure&rdquo; and may be passed as an immutable pointer internally for performance).</p>
<p>Originally, continuing the C family tradition, everything in Odin was passed by value. However, for performance reasons, this behaviour was changed for the Odin calling conventions.</p>
<h3 id=what-is-the-difference-between-new-and-make>What is the difference between <code>new</code> and <code>make</code>? <a class=text-decoration-none href=#what-is-the-difference-between-new-and-make>#</a></h3>
<p><code>new</code> allocates memory.</p>
<pre><code class=language-odin data-lang=odin>ptr: ^int = new(int)
</code></pre><p><code>make</code> initializes the slice, dynamic array, and map types.</p>
<pre><code class=language-odin data-lang=odin>slice: []int = make([]int, 16)
</code></pre><h3 id=what-is-the-difference-between-free-and-delete>What is the difference between <code>free</code> and <code>delete</code>? <a class=text-decoration-none href=#what-is-the-difference-between-free-and-delete>#</a></h3>
<p><code>free</code> deallocates memory</p>
<pre><code class=language-odin data-lang=odin>ptr: ^int = new(int)
free(ptr)
</code></pre><p><code>delete</code> deinitializes the slice, dynamic array, map, and string types.</p>
<pre><code class=language-odin data-lang=odin>slice := make([]int, 10)
delete(slice)

m := make(map[int]string)
delete(m)

str: string = ...
delete(str)
</code></pre><h2 id=packages>Packages <a class=text-decoration-none href=#packages>#</a></h2>
<h3 id=how-do-i-create-a-multiple-file-package>How do I create a multiple file package? <a class=text-decoration-none href=#how-do-i-create-a-multiple-file-package>#</a></h3>
<p>Put all the <code>.odin</code> source files for a package in a directory. Source files must have the same <code>package</code> declaration. All source files within a package can refer to items from other files. There is no need for a forward declarations or a header file like in C.</p>
<h3 id=why-isnt-x-in-the-core-library>Why isn&rsquo;t X in the core library? <a class=text-decoration-none href=#why-isnt-x-in-the-core-library>#</a></h3>
<p>The core library is not yet complete. However when it is complete, it will remain small, as its purpose is to support the runtime, operating system specific calls, formatted I/O, and other key functionality that most Odin programs require.</p>
<h2 id=syntax>Syntax <a class=text-decoration-none href=#syntax>#</a></h2>
<h3 id=what-does--mean>What does <code>:=</code> mean? <a class=text-decoration-none href=#what-does--mean>#</a></h3>
<p>This is two different operators <code>:</code> and <code>=</code>; is used for variable declarations. The following are all equivalent:</p>
<pre><code class=language-odin data-lang=odin>x : int = 123
x :     = 123
x := 123
x := int(123)
</code></pre><h3 id=what-does--mean-1>What does <code>::</code> mean? <a class=text-decoration-none href=#what-does--mean-1>#</a></h3>
<p>This is two different separate operators <code>:</code> and <code>:</code>; is used for constant value declarations.</p>
<pre><code class=language-odin data-lang=odin>X :: 123
X :   : 123

Y : int : 123
Y :: int(123)

Z :: proc() {}
Z : proc() : proc() {} // Redundant type declaration
</code></pre><h3 id=why-does-odin-not-use-keywords-to-prefix-declarations>Why does Odin not use keywords to prefix declarations? <a class=text-decoration-none href=#why-does-odin-not-use-keywords-to-prefix-declarations>#</a></h3>
<p>Please see gingerBill&rsquo;s article <a href=https://www.gingerbill.org/article/2018/03/12/on-the-aesthetics-of-the-syntax-of-declarations/>On the Aesthetics of the Syntax of Declarations</a>.</p>
<h3 id=why-are-there-two-ways-to-do-type-conversions>Why are there two ways to do type conversions? <a class=text-decoration-none href=#why-are-there-two-ways-to-do-type-conversions>#</a></h3>
<pre><code class=language-odin data-lang=odin>cast(type)value
type(value) or (type)(value)
</code></pre><p>The reason that there are two ways to do type conversions is because one approach may <em>feel</em> better than the other case. If you are converting a large expression, it sometimes a lot easier to use the operator-style approach, <code>cast(type)</code>. The call syntax is commonly used to specify a type of an expression which may be relatively short such as <code>u32(123)</code> or <code>uintptr(ptr)</code>.</p>
<p>There are two other type conversion operators, <a href=/docs/overview/#type-conversion>transmute</a> and <a href=/docs/overview/#auto-cast-operation>auto_cast</a>.</p>
<h3 id=why-curly-brackets>Why curly brackets? <a class=text-decoration-none href=#why-curly-brackets>#</a></h3>
<p>Curly brackets to denote a block is a common approach in many programming languages, and Odin&rsquo;s consistency is useful for people already familiar with the style. Curly brackets also allow for more flexible syntax styles for the programmer and it is easier to parse by the compiler because it is not white space sensitive.</p>
<h3 id=why-do-slice-expressions-use--and-not-the-range-syntax>Why do slice expressions use <code>:</code> and not the range syntax? <a class=text-decoration-none href=#why-do-slice-expressions-use--and-not-the-range-syntax>#</a></h3>
<p>The reason for the specific syntax was done for the following reasons:</p>
<ul>
<li>It is the same syntax as Go and Python, making it familiar to others who have used those languages</li>
<li>Allows for partial ranges e.g. <code>x[:]</code>, <code>x[:n]</code>, <code>x[i:]</code></li>
<li>Partial ranges with <em>two</em> range expression (<code>a..&lt;b</code> and <code>a..=b</code>) do not look aesthetically good are also inconsistent: <code>x[..&lt;]</code> <code>x[..=]</code>, <code>x[..&lt;n]</code> <code>x[..=n]</code>, <code>x[i..&lt;]</code> <code>x[i..=]</code></li>
<li>Virtually all slicing cases only ever require the Python/Go like semantics because Odin is a 0-index language</li>
<li>Ranges in Odin are only allowed in two contexts: <code>case</code>s and <code>for in</code> loops</li>
</ul>
<h2 id=how-do-i->How do I &mldr;? <a class=text-decoration-none href=#how-do-i->#</a></h2>
<h3 id=convert-an-integer-to-a-string-or-vice-versa>Convert an integer to a string or vice versa? <a class=text-decoration-none href=#convert-an-integer-to-a-string-or-vice-versa>#</a></h3>
<pre><code class=language-odin data-lang=odin>package numbers_example

import &quot;core:strconv&quot;

main :: proc() {
    // We'll shortly overwrite the part of this array that we need,
    // so we use `---` to tell the compiler it doesn't have to be zero-initialized.
    buf: [64]u8 = ---

    // Format the integer to a string, using memory backed by `buf`.
    a := 4815162342
    s := strconv.itoa(buf[:], a)

    // Parse it back into an integer. We assume it's a valid base-10 representation here.
    // If you want to check it was parsed correctly or parse binary, octal or hexadecimal,
    // look at the `parse_*` procedures.
    b := strconv.atoi(s)

    assert(a == b)
}
</code></pre><h2 id=implementation>Implementation <a class=text-decoration-none href=#implementation>#</a></h2>
<h3 id=what-does-the-compiler-use>What does the compiler use? <a class=text-decoration-none href=#what-does-the-compiler-use>#</a></h3>
<p>The compiler is written in C++ but in a very C style.
For the current backend, LLVM is used to translate code to platform specific code.</p>
<h2 id=changes-from-cc>Changes from C/C++ <a class=text-decoration-none href=#changes-from-cc>#</a></h2>
<h3 id=why-is-the-syntax-so-different-from-c>Why is the syntax so different from C? <a class=text-decoration-none href=#why-is-the-syntax-so-different-from-c>#</a></h3>
<p>Other than the declaration syntax, the differences are minor. When designing the syntax, it had to feel right and light. A minimal amount of keywords and syntactic sugar. The syntax has been designed to be very easy to parse without a symbol table. This makes it easier to create build and analysis tools for Odin.</p>
<h3 id=why-are-declarations-backwards>Why are declarations backwards? <a class=text-decoration-none href=#why-are-declarations-backwards>#</a></h3>
<p>Declarations are only backwards if you are used to C. In C, declarations follow the <a href=http://c-faq.com/decl/spiral.anderson.html>&ldquo;clockwise/spiral rule&rdquo;</a> to reflect the usage of the declaration. This can be confusing when reading.</p>
<p>Please see: <a href=https://odin-lang.org/news/declaration-syntax/>https://odin-lang.org/news/declaration-syntax/</a></p>
<p>In C, the declaration:</p>
<pre><code class=language-odin data-lang=odin>int *a, b;
</code></pre><p>declares <code>a</code> to be a &ldquo;pointer to int&rdquo; but b to be an &ldquo;int&rdquo;; in Odin</p>
<pre><code class=language-odin data-lang=odin>a, b: ^int
</code></pre><p>declares both to be a &ldquo;pointer to int&rdquo;. This is clearer and more regular. This syntax is borrowed from the Pascal family, along with using <code>^</code> to denote a pointer, as it is pointy.</p>
<p>Due to the style of value declarations, the type can be omitted and inferred from the declaration. The following are all equivalent:</p>
<pre><code class=language-odin data-lang=odin>a: int = 123
a :    = 123
a := 123
a := int(123)
</code></pre><h3 id=why-is-there-no-pointer-arithmetic>Why is there no pointer arithmetic? <a class=text-decoration-none href=#why-is-there-no-pointer-arithmetic>#</a></h3>
<p>Type safety and simplicity. Due to slices being a first-class datatype, a lot of the need for pointer arithmetic is reduced. However, if you still require it, the <code>mem</code> package provides some utility functions: <code>mem.ptr_offset</code> and <code>mem.ptr_sub</code>. Odin will allow the programmer to do unsafe things if they so wish.</p>
<p>If pointer arithmetic operations are still required and common (maybe due to interfacing with foreign C-like code), <a href=https://odin-lang.org/docs/overview/#multi-pointers>multi-pointers</a> may be a better option to use.</p>
<h3 id=why-are-there-no--or----operators>Why are there no <code>++</code> or <code>--</code> operators? <a class=text-decoration-none href=#why-are-there-no--or----operators>#</a></h3>
<p>Pre-increment and post-increment, and the decrement equivalents, look simple but are complex. They require knowledge of the evaluation order and lead to subtle bugs. <code>f(i++)</code> or <code>a[++i] = b[i]</code> are both confusing, even if the rules are well defined. Removing this is a significant simplification.</p>
<p><code>x += 1</code> is slightly longer but it is unambiguous.</p>
<h3 id=does-odin-have-c-style-constructors>Does Odin have C++-style constructors? <a class=text-decoration-none href=#does-odin-have-c-style-constructors>#</a></h3>
<p>No. The philosophy for Odin is that the zero value should be useful. By default, all variables are initialized to zero unless told otherwise with the <code>---</code> value.</p>
<pre><code class=language-odin data-lang=odin>x: int       // initialized to zero
y: int = 0   // explicitly initialized to zero
z: int = --- // uninitialized memory
</code></pre><h3 id=does-odin-have-c-style-copy-constructors>Does Odin have C++-style copy constructors? <a class=text-decoration-none href=#does-odin-have-c-style-copy-constructors>#</a></h3>
<p>No. All copies are byte-for-byte copies.</p>
<h3 id=does-odin-have-c-style-move-constructors>Does Odin have C++-style move constructors? <a class=text-decoration-none href=#does-odin-have-c-style-move-constructors>#</a></h3>
<p>No. There are no ownership semantics in Odin.</p>
<h3 id=does-odin-have-c-style-destructors>Does Odin have C++-style destructors? <a class=text-decoration-none href=#does-odin-have-c-style-destructors>#</a></h3>
<p>No. <code>defer</code> can be used to defer a statement till end of a scope. <code>defer</code> is explicit and much more flexible than a C++-style destructor in that it can be used for anything.</p>
<pre><code class=language-odin data-lang=odin>f, err := os.open(...)
if err != os.ERROR_NONE {
    // handle error
}
defer os.close(f) // will be executed at the end of the scope

...
</code></pre><h3 id=why-is-partial-switch-needed-when-there-is-a-catch-all-case>Why is <code>#partial switch</code> needed when there is a catch-all <code>case:</code>? <a class=text-decoration-none href=#why-is-partial-switch-needed-when-there-is-a-catch-all-case>#</a></h3>
<p>By default, <code>switch</code> statements which have an <code>enum</code> or <code>union</code> condition require the user to specify every case that the type defines. It is a very common mistake to forget to add a new case when a new variant is added in other languages, so Odin defaults to will tell the user of this mistake. If the user wants to explicitly opt-out of this behaviour, <code>#partial</code> can be applied to the <code>switch</code> statement directly to state that not all of the cases need to be specified.</p>
<p><code>case:</code> is the catch-all case which allows for anything not specified, which includes <code>nil</code> or even invalid cases (e.g. custom-user-values or corrupted cases). <code>#partial</code> and <code>case:</code> are orthogonal concepts which are used to achieve different things entirely. Each variant might be handled, but there might still be an invalid case not handled thus <code>case:</code> might still be required depending on the problem.</p>
<h3 id=why-does-reverse-not-work-on-ranges-in-for-in-loops>Why does <code>#reverse</code> not work on ranges in <code>for in</code> loops? <a class=text-decoration-none href=#why-does-reverse-not-work-on-ranges-in-for-in-loops>#</a></h3>
<ul>
<li>It is a lot clearer to write a normal C-style <code>for</code> loop
<ul>
<li><code>for i := hi; i >= lo; i -= 1 {...}</code></li>
</ul>
</li>
<li>It might not execute the way the user expects, especially for floats
<ul>
<li><code>for i in 1.2 ..&lt; 3.4 {...}</code> is valid in Odin</li>
</ul>
</li>
<li>It will cause off-by-one bugs in certain cases</li>
</ul>
<h4 id=deferred-attributes>Deferred Attributes <a class=text-decoration-none href=#deferred-attributes>#</a></h4>
<p>There is also the <code>deferred_*</code> attributes which can be attached to procedures to have very useful functionality, such as <a href=https://en.wikipedia.org/wiki/Immediate_Mode_GUI>IMGUIs</a>.</p>
<table>
<tbody>
<tr><td>deferred_none</td><td>the deferred procedure takes <em>none</em> of the parameters from the original procedure</td></tr>
<tr><td>deferred_in</td><td>the deferred procedure takes the <em>input</em> parameters from the original procedure</td></tr>
<tr><td>deferred_out</td><td>the deferred procedure takes the <em>return</em> values from the original procedure</td></tr>
</tbody>
</table>
<p>Example:</p>
<pre><code class=language-odin data-lang=odin>begin_menu :: proc(name: string, flags: Flags = nil) -&gt; (open: bool) {
    ...
}

end_menu :: proc(open := true) {
    if !open do return
    ...
}
@(deferred_out=end_menu)
menu :: proc(name: string, flags: Flags = nil) -&gt; (open: bool) {
    return begin_menu(name, flags)
}


if begin_menu(&quot;Hello&quot;) {
    defer end_menu()
}

if menu(&quot;Hello&quot;) {

}
</code></pre><h2 id=compiler>Compiler <a class=text-decoration-none href=#compiler>#</a></h2>
<h3 id=what-architectures-does-odin-support>What architectures does Odin support? <a class=text-decoration-none href=#what-architectures-does-odin-support>#</a></h3>
<p>The official implementation of Odin currently supports: amd64, arm64/aarch64, and wasm32/wasm64p32.</p>
<h3 id=is-the-odin-compiler-self-hosted>Is the Odin compiler self hosted? <a class=text-decoration-none href=#is-the-odin-compiler-self-hosted>#</a></h3>
<p>Odin is not currently self hosted nor will be until <em>after</em> version 1.0 when the main implementation of the Odin compiler adheres to a specification and is heavily tested. In general, self hosting before a stable language and compiler exists is masturbatory pleasure.</p>
<h3 id=where-is-the-odin-roadmap>Where is the Odin roadmap? <a class=text-decoration-none href=#where-is-the-odin-roadmap>#</a></h3>
<p>There is no official roadmap. Public roadmaps are pretty much a form of marketing for the language rather than being anything useful for the development team. The development team does have internal goals, many of which are not viewable by the public, and problems are dealt with when and as necessary.</p>
<p>Odin as a language is pretty much done, but Odin the compiler, toolchain, and core library are still in development and always improved. If you want to help out with any of this, try checking out the source code: <a href=https://github.com/odin-lang/Odin>https://github.com/odin-lang/Odin</a>.</p>
<h2 id=quotes>Quotes <a class=text-decoration-none href=#quotes>#</a></h2>
<blockquote>
<p>Show me your flowcharts and conceal your tables, and I shall continue to be mystified. Show me your tables, and I won’t usually need your flowcharts; they’ll be obvious.</p>
</blockquote>
<ul>
<li>Fred Brooks, <em>The Mythical Man-Month: Essays on Software Engineering</em> (1975, 1995)</li>
</ul>
<blockquote>
<p>A little retrospection shows that although many fine, useful software systems have been designed by committees and built as part of multipart projects, those software systems that have excited passionate fans are those that are the products of one or a few designing minds, great designers.</p>
</blockquote>
<ul>
<li>Fred Brooks, <em>No Silver Bullet</em></li>
</ul>
<blockquote>
<p>The language designer should be familiar with many alternative features designed by others, and should have excellent judgment in choosing the best and rejecting any that are mutually inconsistent&mldr; One thing he should not do is to include untried ideas of his own. His task is consolidation, not innovation.</p>
</blockquote>
<ul>
<li>C.A.R. Hoare</li>
</ul>
<blockquote>
<p>The most important property of a program is whether it accomplishes the intention of its user</p>
</blockquote>
<ul>
<li>C.A.R. Hoare</li>
</ul>
<blockquote>
<p>Most ideas come from previous ideas.</p>
</blockquote>
<ul>
<li>Alan C. Kay, <em>The Early History Of Smalltalk</em></li>
</ul>
<blockquote>
<p>Reliable and transparent programs are usually not in the interest of the designer.</p>
</blockquote>
<ul>
<li>Niklaus Wirth, <em>A Digital Contrarian Retires</em> (1999)</li>
</ul>
<blockquote>
<p>&mldr; we do not consider it as good engineering practice to consume a resource lavishly just because it happens to be cheap</p>
</blockquote>
<ul>
<li>Niklaus Wirth, <em>Project Oberon</em></li>
</ul>
<blockquote>
<p>Increasingly, people seem to interpret complexity as sophistication, which is baffling – the incomprehensible should cause suspicion, not admiration. Possibly this results from the mistaken belief that using a mysterious device confers [extra] power on the user.</p>
</blockquote>
<ul>
<li>Niklaus Wirth</li>
</ul>
</div>
</article>
<div id=TOC class="col-lg-2 odin-toc-border">
<div class="sticky-top odin-below-navbar py-3">
<nav id=TableOfContents>
<ul>
<li><a href=#general>General</a>
<ul>
<li><a href=#what-is-the-history-of-the-project>What is the history of the project?</a></li>
<li><a href=#what-have-been-the-major-influences-in-the-languages-design>What have been the major influences in the language&rsquo;s design?</a></li>
<li><a href=#how-is-odin-licensed>How is Odin licensed?</a></li>
<li><a href=#does-odin-have-any-third-party-library>Does Odin have any third-party library?</a></li>
<li><a href=#what-are-the-guiding-principles-behind-the-design-of-odin>What are the guiding principles behind the design of Odin?</a></li>
<li><a href=#what-does-odin-offer-over-other-languages>What does Odin offer over other languages?</a></li>
</ul>
</li>
<li><a href=#design>Design</a>
<ul>
<li><a href=#why-does-odin-not-have-feature-x>Why does Odin not have feature X?</a></li>
<li><a href=#why-does-odin-not-have-exceptions>Why does Odin not have exceptions?</a></li>
</ul>
</li>
<li><a href=#types>Types</a>
<ul>
<li><a href=#is-odin-an-object-oriented-language>Is Odin an object oriented language?</a></li>
<li><a href=#why-does-odin-not-have-uniform-function-call-syntax-ufcs>Why does Odin not have Uniform Function Call Syntax (UFCS)?</a></li>
<li><a href=#why-does-odin-have-explicit-procedure-overloading-but-not-implicit-procedure-overloading>Why does Odin have explicit procedure overloading but not implicit procedure overloading?</a></li>
<li><a href=#why-does-odin-not-have-operator-overloading>Why does Odin not have operator overloading?</a></li>
<li><a href=#what-does-distinct-do>What does <code>distinct</code> do?</a></li>
<li><a href=#what-is-the-type-of-x-in-x--123>What is the type of <code>x</code> in <code>x := 123</code>?</a></li>
<li><a href=#what-is-the-size-of-int>What is the size of <code>int</code>?</a></li>
<li><a href=#which-of-f32-and-f64-should-i-prefer-for-floating-point-mathematics>Which of <code>f32</code> and <code>f64</code> should I prefer for floating-point mathematics?</a></li>
<li><a href=#what-is-rune>What is <code>rune</code>?</a></li>
</ul>
</li>
<li><a href=#values>Values</a>
<ul>
<li><a href=#why-does-odin-not-have-implicit-numeric-type-conversions>Why does Odin not have implicit numeric type conversions?</a></li>
<li><a href=#why-are-slices-dynamic-arrays-and-maps-references-whilst-arrays-are-values>Why are slices, dynamic arrays, and maps references whilst arrays are values?</a></li>
</ul>
</li>
<li><a href=#procedures>Procedures</a>
<ul>
<li><a href=#why-is-it-named-proc>Why is it named <code>proc</code>?</a></li>
<li><a href=#why-does-odin-not-have-any-methods>Why does Odin not have any methods?</a></li>
<li><a href=#how-do-i-define-a-procedure-with-a-different-calling-convention>How do I define a procedure with a different calling convention?</a></li>
<li><a href=#does-odin-have-closures>Does Odin have closures?</a></li>
<li><a href=#why-are-maps-built-in>Why are maps built-in?</a></li>
</ul>
</li>
<li><a href=#context-system>Context System</a>
<ul>
<li><a href=#what-is-the-context-system-for>What is the context system for?</a></li>
</ul>
</li>
<li><a href=#pointers-and-allocation>Pointers and Allocation</a>
<ul>
<li><a href=#when-are-procedure-parameters-passed-by-value>When are procedure parameters passed by value?</a></li>
<li><a href=#what-is-the-difference-between-new-and-make>What is the difference between <code>new</code> and <code>make</code>?</a></li>
<li><a href=#what-is-the-difference-between-free-and-delete>What is the difference between <code>free</code> and <code>delete</code>?</a></li>
</ul>
</li>
<li><a href=#packages>Packages</a>
<ul>
<li><a href=#how-do-i-create-a-multiple-file-package>How do I create a multiple file package?</a></li>
<li><a href=#why-isnt-x-in-the-core-library>Why isn&rsquo;t X in the core library?</a></li>
</ul>
</li>
<li><a href=#syntax>Syntax</a>
<ul>
<li><a href=#what-does--mean>What does <code>:=</code> mean?</a></li>
<li><a href=#what-does--mean-1>What does <code>::</code> mean?</a></li>
<li><a href=#why-does-odin-not-use-keywords-to-prefix-declarations>Why does Odin not use keywords to prefix declarations?</a></li>
<li><a href=#why-are-there-two-ways-to-do-type-conversions>Why are there two ways to do type conversions?</a></li>
<li><a href=#why-curly-brackets>Why curly brackets?</a></li>
<li><a href=#why-do-slice-expressions-use--and-not-the-range-syntax>Why do slice expressions use <code>:</code> and not the range syntax?</a></li>
</ul>
</li>
<li><a href=#how-do-i->How do I &mldr;?</a>
<ul>
<li><a href=#convert-an-integer-to-a-string-or-vice-versa>Convert an integer to a string or vice versa?</a></li>
</ul>
</li>
<li><a href=#implementation>Implementation</a>
<ul>
<li><a href=#what-does-the-compiler-use>What does the compiler use?</a></li>
</ul>
</li>
<li><a href=#changes-from-cc>Changes from C/C++</a>
<ul>
<li><a href=#why-is-the-syntax-so-different-from-c>Why is the syntax so different from C?</a></li>
<li><a href=#why-are-declarations-backwards>Why are declarations backwards?</a></li>
<li><a href=#why-is-there-no-pointer-arithmetic>Why is there no pointer arithmetic?</a></li>
<li><a href=#why-are-there-no--or----operators>Why are there no <code>++</code> or <code>--</code> operators?</a></li>
<li><a href=#does-odin-have-c-style-constructors>Does Odin have C++-style constructors?</a></li>
<li><a href=#does-odin-have-c-style-copy-constructors>Does Odin have C++-style copy constructors?</a></li>
<li><a href=#does-odin-have-c-style-move-constructors>Does Odin have C++-style move constructors?</a></li>
<li><a href=#does-odin-have-c-style-destructors>Does Odin have C++-style destructors?</a></li>
<li><a href=#why-is-partial-switch-needed-when-there-is-a-catch-all-case>Why is <code>#partial switch</code> needed when there is a catch-all <code>case:</code>?</a></li>
<li><a href=#why-does-reverse-not-work-on-ranges-in-for-in-loops>Why does <code>#reverse</code> not work on ranges in <code>for in</code> loops?</a>
<ul>
<li><a href=#deferred-attributes>Deferred Attributes</a></li>
</ul>
</li>
</ul>
</li>
<li><a href=#compiler>Compiler</a>
<ul>
<li><a href=#what-architectures-does-odin-support>What architectures does Odin support?</a></li>
<li><a href=#is-the-odin-compiler-self-hosted>Is the Odin compiler self hosted?</a></li>
<li><a href=#where-is-the-odin-roadmap>Where is the Odin roadmap?</a></li>
</ul>
</li>
<li><a href=#quotes>Quotes</a></li>
</ul>
</nav>
</div>
</div>
</div>
</div>
</main>
<footer class=odin-footer>
<div class="container pb-5 pt-5">
<div class="row g-4">
<div class=col>
<a class=navbar-brand href=/>
<img class=mb-3 src=/logo.svg height=30 alt=Odin></a>
<p>
The Data-Oriented Language for Sane Software Development.
</p>
</div>
<nav class=col-md-auto>
<h4 class=fw-normal>Resources</h4>
<ul class=list-unstyled>
<li><a href=/docs class=link-light>Docs</a></li>
<li><a href=https://pkg.odin-lang.org/ class=link-light>Packages</a></li>
<li><a href=/news class=link-light>News</a></li>
</ul>
</nav>
<nav class=col-md-auto>
<h4 class=fw-normal>Community</h4>
<ul class=list-unstyled>
<li><a href=https://github.com/odin-lang/Odin target=_blank class=link-light>GitHub</a></li>
<li><a href=https://discord.com/invite/sVBPHEv target=_blank class=link-light>Discord</a></li>
<li><a href=https://www.twitch.tv/ginger_bill target=_blank class=link-light>Twitch</a></li>
<li><a href=https://www.youtube.com/channel/UCUSck1dOH7VKmG4lRW7tZXg target=_blank class=link-light>YouTube</a></li>
<li><a href=/showcase target=_blank class=link-light>Showcase</a></li>
</ul>
</nav>
<nav class=col-md-auto>
<h4 class=fw-normal>Contribute</h4>
<ul class=list-unstyled>
<li><a href=https://github.com/odin-lang/Odin/issues target=_blank class=link-light>Issues</a></li>
<li><a href=https://www.patreon.com/gingerbill target=_blank class=link-light>Donate</a></li>
</ul>
</nav>
</div>
<div class="mt-4 text-muted">© 2016–2024 Ginger Bill</div>
</div>
</footer>
<script src=/lib/bootstrap/js/bootstrap.min.js></script>
<script src=/js/script.js></script>
</body>
</html>
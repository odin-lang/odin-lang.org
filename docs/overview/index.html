<!doctype html><html>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<link rel=icon href=/favicon.svg>
<meta property="og:title" content="Overview">
<meta property="og:description" content="An overview of the Odin programming language and its features.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://odin-lang.org/docs/overview/">
<meta property="og:image" content="https://odin-lang.org/images/logo-slim.png">
<link rel=stylesheet href=https://odin-lang.org/scss/custom.min.css>
<link rel=stylesheet href=/lib/highlight/styles/github-dark.min.css>
<script src=/lib/highlight/highlight.min.js></script>
<script>hljs.registerLanguage("odin",function(a){return{aliases:["odin","odinlang","odin-lang"],keywords:{keyword:"auto_cast bit_set break case cast context continue defer distinct do dynamic else enum fallthrough for foreign if import in map matrix not_in or_else or_return package proc return struct switch transmute type_of typeid union using when where",literal:"true false nil",built_in:"abs align_of cap clamp complex conj expand_to_tuple imag jmag kmag len max min offset_of quaternion real size_of soa_unzip soa_zip swizzle type_info_of type_of typeid_of"},illegal:"</",contains:[a.C_LINE_COMMENT_MODE,a.C_BLOCK_COMMENT_MODE,{className:"string",variants:[a.QUOTE_STRING_MODE,{begin:"'",end:"[^\\\\]'"},{begin:"`",end:"`"}]},{className:"number",variants:[{begin:a.C_NUMBER_RE+"[ijk]",relevance:1},a.C_NUMBER_MODE]}]}})</script>
<script>hljs.highlightAll()</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-67516878-2"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','UA-67516878-2')</script>
<link href=/css/style.css rel=stylesheet>
<title>Overview | Odin Programming Language </title>
<body><header class=sticky-top>
<nav class="navbar navbar-expand-lg navbar-dark bg-primary odin-menu">
<div class=container>
<a class=navbar-brand href=/>
<img src=/logo.svg height=30 alt=Odin></a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#odin-navbar-content aria-controls=odin-navbar-content aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span>
</button>
<div class="collapse navbar-collapse" id=odin-navbar-content>
<ul class="navbar-nav ms-md-auto">
<li class=nav-item>
<a class=nav-link href=/>Home</a>
</li>
<li class=nav-item>
<a class="nav-link active" href=/docs aria-current=page>Docs</a>
</li>
<li class=nav-item>
<a class=nav-link href=https://pkg.odin-lang.org/>Packages</a>
</li>
<li class=nav-item>
<a class=nav-link href=/news>News</a>
</li>
<li class=nav-item>
<a class=nav-link href=/showcase>Showcase</a>
</li>
<li class=nav-item>
<a class=nav-link href=/community>Community</a>
</li>
<li class=nav-item>
<a class=nav-link href=https://github.com/odin-lang/Odin target=_blank>GitHub</a>
</li>
</ul>
</div>
</div>
</nav>
</header>
<main>
<div class=container>
<div class="row odin-main">
<nav class="col-lg-2 odin-sidebar-border navbar-light">
<div class="sticky-top odin-below-navbar py-3">
<ul class="nav nav-pills d-flex flex-column">
<li class=nav-item>
<a class=nav-link href=/docs/install/>Getting Started</a>
</li>
<li class=nav-item>
<a class="nav-link active" href=/docs/overview/ aria-current=page>Overview</a>
</li>
<li class=nav-item>
<a class=nav-link href=/docs/faq/>FAQ</a>
</li>
<li class=nav-item>
<a class=nav-link href=/docs/packages/>Packages</a>
</li>
<li class=nav-item>
<a class=nav-link href=/docs/nightly/>Nightly Builds</a>
</li>
<li class=nav-item>
<a class=nav-link href=/docs/spec/>Specification</a>
</li>
</ul>
</div>
</nav>
<article class="col-lg-8 p-4">
<header>
<nav aria-label=breadcrumb>
<ol class=breadcrumb>
<li class=breadcrumb-item><a href=/docs>Docs</a></li>
<li class=breadcrumb-item><a href=/overview>Overview</a></li>
</ol>
</nav>
<h1>Overview</h1>
</header>
<div class=odin-article>
<h2 id=introduction>Introduction <a class=text-decoration-none href=#introduction>#</a></h2>
<p>This article is a basic tutorial for the programming language <em>Odin</em>. This tutorial assumes a basic knowledge of programming concepts such as variables, statements, and types. It is recommend to read the <a href=https://github.com/odin-lang/Odin/wiki#getting-started-with-odin>Getting started with Odin</a> guide.</p>
<h2 id=hellope>Hellope! <a class=text-decoration-none href=#hellope>#</a></h2>
<p>To begin this tour, let us start with a modified version of the famous &ldquo;hello world&rdquo; program:</p>
<pre><code class=language-odin data-lang=odin>package main

import &quot;core:fmt&quot;

main :: proc() {
	fmt.println(&quot;Hellope!&quot;)
}
</code></pre><p>Save this code to the file &ldquo;hellope.odin&rdquo;. Now compile and run it:</p>
<pre><code>odin run hellope.odin
</code></pre><p>The <code>run</code> command compiles the <code>.odin</code> file to an executable and then runs that executable after compilation. If you do not wish to run the executable after compilation, the <code>build</code> command can be used.</p>
<pre><code>odin build hellope.odin
</code></pre><h2 id=lexical-elements-and-literals>Lexical elements and literals <a class=text-decoration-none href=#lexical-elements-and-literals>#</a></h2>
<h3 id=comments>Comments <a class=text-decoration-none href=#comments>#</a></h3>
<p>Comments can be anywhere outside of a string or character literal. Single line comments begin with <code>//</code>:</p>
<pre><code class=language-odin data-lang=odin>// A comment

my_integer_variable: int // A comment for documentation
</code></pre><p>Multi-line comments begin with <code>/*</code> and end with <code>*/</code>. Multi-line comments can be also be nested (unlike in C):</p>
<pre><code class=language-odin data-lang=odin>/*
	You can have any text or code here and
	have it be commented.
	/*
		NOTE: comments can be nested!
	*/
*/
</code></pre><p>Comments are parsed as tokens within the compiler. This is to allow for future work on automatic documentation tools.</p>
<h3 id=string-and-character-literals>String and character literals <a class=text-decoration-none href=#string-and-character-literals>#</a></h3>
<p>String literals are enclosed in double quotes and character literals in single quotes. Special characters are escaped with a backslash <code>\</code>.</p>
<pre><code class=language-odin data-lang=odin>&quot;This is a string&quot;
'A'
'\n' // newline character
&quot;C:\\Windows\\notepad.exe&quot;
</code></pre><p>Raw string literals are enclosed in single back ticks.</p>
<pre><code class=language-odin data-lang=odin>`C:\Windows\notepad.exe`
</code></pre><p>The length of a string can be found using the built-in <code>len</code> proc:</p>
<pre><code class=language-odin data-lang=odin>len(&quot;Foo&quot;)
len(some_string)
</code></pre><p>If the string passed to <code>len</code> is a compile-time constant, the value from <code>len</code> will be a compile-time constant.</p>
<h4 id=escape-characters>Escape Characters <a class=text-decoration-none href=#escape-characters>#</a></h4>
<ul>
<li><code>\a</code> - bell (BEL)</li>
<li><code>\b</code> - backspace (BS)</li>
<li><code>\e</code> - escape (ESC)</li>
<li><code>\f</code> - form feed (FF)</li>
<li><code>\n</code> - newline</li>
<li><code>\r</code> - carriage return</li>
<li><code>\t</code> - tab</li>
<li><code>\v</code> - vertical tab (VT)</li>
<li><code>\\</code> - backslash</li>
<li><code>\"</code> - double quote (if needed)</li>
<li><code>\'</code> - single quote (if needed)</li>
<li><code>\NN</code>- octal 4 bit character (2 digits)</li>
<li><code>\xNN</code> - hexadecimal 8 bit character (2 digits)</li>
<li><code>\uNNNN</code> - hexadecimal 16-bit Unicode character UTF-8 encoded (4 digits)</li>
<li><code>\UNNNNNN</code> - hexadecimal 24-bit Unicode character UTF-8 encoded (6 digits)</li>
</ul>
<h3 id=numbers>Numbers <a class=text-decoration-none href=#numbers>#</a></h3>
<p>Numerical literals are written similar to most other programming languages. A useful feature in Odin is that underscores are allowed for better readability: <code>1_000_000_000</code> (one billion). A number that contains a dot is a floating point literal: <code>1.0e9</code> (one billion). If a number literal is suffixed with <code>i</code>, it is an imaginary number literal: <code>2i</code> (2 multiply the square root of -1).</p>
<p>Binary literals are prefixed with <code>0b</code>, octal literals with <code>0o</code>, and hexadecimal literals with <code>0x</code>. A leading zero does not produce an octal constant (unlike C).</p>
<p>In Odin, if a number constant can be represented by a type without precision loss, it will automatically convert to that type.</p>
<pre><code class=language-odin data-lang=odin>x: int = 1.0 // A float literal but it can be represented by an integer without precision loss
</code></pre><p>Constant literals are &ldquo;untyped&rdquo; which means that they can implicitly convert to a type.</p>
<pre><code class=language-odin data-lang=odin>x: int // `x` is typed of type `int`
x = 1 // `1` is an untyped integer literal which can implicitly convert to `int`
</code></pre><h2 id=variable-declarations>Variable declarations <a class=text-decoration-none href=#variable-declarations>#</a></h2>
<p>A variable declaration declares a new variable for the current scope.</p>
<pre><code class=language-odin data-lang=odin>x: int // declares x to have type `int`
y, z: int // declares y and z to have type `int`
</code></pre><p>Variables are initialized to zero by default unless specified otherwise.</p>
<h2 id=assignment-statements>Assignment statements <a class=text-decoration-none href=#assignment-statements>#</a></h2>
<p>The assignment statement assigns a new value to a variable/location:</p>
<pre><code class=language-odin data-lang=odin>x: int = 123 // declares a new variable `x` with type `int` and assigns a value to it
x = 637 // assigns a new value to `x`
</code></pre><p><code>=</code> is the assignment operator.</p>
<p>You can assign multiple variables with it:</p>
<pre><code class=language-odin data-lang=odin>x, y := 1, &quot;hello&quot; // declares `x` and `y` and infers the types from the assignments
y, x = &quot;bye&quot;, 5
</code></pre><p><strong>Note:</strong> <code>:=</code> is two tokens, <code>:</code> and <code>=</code>. The following are all equivalent:</p>
<pre><code class=language-odin data-lang=odin>x: int = 123
x:     = 123 // default type for an integer literal is `int`
x := 123
</code></pre><h2 id=constant-declarations>Constant declarations <a class=text-decoration-none href=#constant-declarations>#</a></h2>
<p>Constants are entities (symbols) which have an assigned value. The constant&rsquo;s value cannot be changed. The constant&rsquo;s value must be able to be evaluated at compile time:</p>
<pre><code class=language-odin data-lang=odin>x :: &quot;what&quot; // constant `x` has the untyped string value &quot;what&quot;
</code></pre><p>Constants can be explicitly typed like a variable declaration:</p>
<pre><code class=language-odin data-lang=odin>y : int : 123
z :: y + 7 // constant computations are possible
</code></pre><p>For more information regarding value declarations in general, please see the <a href=/docs/faq>Odin FAQ</a> and Ginger Bill&rsquo;s article <a href=https://www.gingerbill.org/article/2018/03/12/on-the-aesthetics-of-the-syntax-of-declarations/>On the Aesthetics of the Syntax of Declarations</a>.</p>
<h2 id=packages>Packages <a class=text-decoration-none href=#packages>#</a></h2>
<p>Every Odin program is made up of packages. Programs begin running in the package <code>main</code>.</p>
<h3 id=import-statement><code>import</code> statement <a class=text-decoration-none href=#import-statement>#</a></h3>
<p>The following program imports the the <code>fmt</code> and <code>os</code> packages from the <code>core</code> library collection.</p>
<pre><code class=language-odin data-lang=odin>package main

import &quot;core:fmt&quot;
import &quot;core:os&quot;

main :: proc() {
}
</code></pre><p>The <code>core:</code> prefix is used to state where the import is meant to look; this is called a library collection. If no prefix is present, the import will look relative to the current file.</p>
<p><strong>Note</strong>: By convention, the package name is the same as the last element in the import path. <code>"core:fmt"</code> package comprises of files that begin with the statement <code>package fmt</code>. However, this is not enforced by the compiler, which means the default name for the import name will be determined by the last element in the import path if possible.</p>
<p>A different import name can be used over the default package name:</p>
<pre><code>import &quot;core:fmt&quot;
import foo &quot;core:fmt&quot; // reference a package by a different name
</code></pre><h3 id=exported-names>Exported names <a class=text-decoration-none href=#exported-names>#</a></h3>
<p>All declarations in a package are exported by default.</p>
<p>The <code>private</code> attribute can be applied to an entity to prevent it from being exported from a package.</p>
<pre><code class=language-odin data-lang=odin>@(private)
my_variable: int // cannot be accessed outside this package.
</code></pre><p>You may also make an entity private to <em>the file</em> instead of the package.</p>
<pre><code class=language-odin data-lang=odin>@(private=&quot;file&quot;)
my_variable: int // cannot be accessed outside this file.
</code></pre><p><code>@(private)</code> is equivalent to <code>@(private="package")</code>.</p>
<h2 id=control-flow-statements>Control flow statements <a class=text-decoration-none href=#control-flow-statements>#</a></h2>
<h3 id=for-statement><code>for</code> statement <a class=text-decoration-none href=#for-statement>#</a></h3>
<p>Odin has only one loop statement, the <code>for</code> loop.</p>
<h4 id=basic-for-loop>Basic for loop <a class=text-decoration-none href=#basic-for-loop>#</a></h4>
<p>A basic <code>for</code> loop has three components separated by semicolons:</p>
<ul>
<li>The initial statement: executed before the first iteration</li>
<li>The condition expression: evaluated before every iteration</li>
<li>The post statement: executed at the end of every iteration</li>
</ul>
<p>The loop will stop executing when the condition is evaluated to <code>false</code>.</p>
<pre><code class=language-odin data-lang=odin>for i := 0; i &lt; 10; i += 1 {
	fmt.println(i)
}
</code></pre><p><strong>Note:</strong> Unlike other languages like C, there are no parentheses <code>( )</code> surrounding the three components. Braces <code>{ }</code> or a <code>do</code> are always required.</p>
<pre><code class=language-odin data-lang=odin>for i := 0; i &lt; 10; i += 1 { }
for i := 0; i &lt; 10; i += 1 do single_statement()
</code></pre><p>The initial and post statements are optional:</p>
<pre><code class=language-odin data-lang=odin>i := 0
for ; i &lt; 10; {
	i += 1
}
</code></pre><p>These semicolons can be dropped. This <code>for</code> loop is equivalent to C&rsquo;s <code>while</code> loop:</p>
<pre><code class=language-odin data-lang=odin>i := 0
for i &lt; 10 {
	i += 1
}
</code></pre><p>If the condition is omitted, this produces an infinite loop:</p>
<pre><code class=language-odin data-lang=odin>for {
}
</code></pre><h4 id=range-based-for-loop>Range-based for loop <a class=text-decoration-none href=#range-based-for-loop>#</a></h4>
<p>The basic for loop</p>
<pre><code class=language-odin data-lang=odin>for i := 0; i &lt; 10; i += 1 {
	fmt.println(i)
}
</code></pre><p>can also be written</p>
<pre><code class=language-odin data-lang=odin>for i in 0..&lt;10 {
	fmt.println(i)
}
// or
for i in 0..9 {
	fmt.println(i)
}
</code></pre><p>where <code>a..b</code> denotes a closed interval <code>[a,b]</code>, i.e. the upper limit is <em>inclusive</em>, and <code>a..&lt;b</code> denotes a half-open interval <code>[a,b)</code>, i.e. the upper limit is <em>exclusive</em>.</p>
<p>Certain built-in types can be iterated over:</p>
<pre><code class=language-odin data-lang=odin>for character in some_string {
	fmt.println(character)
}
for value in some_array {
	fmt.println(value)
}
for value in some_slice {
	fmt.println(value)
}
for value in some_dynamic_array {
	fmt.println(value)
}
for value in some_map {
	fmt.println(value)
}
</code></pre><p>Alternatively a second index value can be added:</p>
<pre><code class=language-odin data-lang=odin>for character, index in some_string {
	fmt.println(index, character)
}
for value, index in some_array {
	fmt.println(index, value)
}
for value, index in some_slice {
	fmt.println(index, value)
}
for value, index in some_dynamic_array {
	fmt.println(index, value)
}
for key, value in some_map {
	fmt.println(key, value)
}
</code></pre><p>The iterated values are <em>copies</em> and cannot be written to. The following idiom is useful for iterating over a container in a by-reference manner:</p>
<pre><code class=language-odin data-lang=odin>for _, i in some_slice {
	some_slice[i] = something
}
</code></pre><p><strong>Note:</strong> When iterating across a string, the characters will be <code>rune</code>s and not bytes. <code>for in</code> assumes the string is encoded as UTF-8.</p>
<h3 id=if-statement><code>if</code> statement <a class=text-decoration-none href=#if-statement>#</a></h3>
<p>Odin&rsquo;s <code>if</code> statements do not need to be surrounded by parentheses <code>( )</code> but braces <code>{ }</code> or <code>do</code> are required.</p>
<pre><code class=language-odin data-lang=odin>if x &gt;= 0 {
	fmt.println(&quot;x is positive&quot;)
}
</code></pre><p>Like <code>for</code>, the <code>if</code> statement can start with an initial statement to execute before the condition. Variables declared by the initial statement are only in the scope of that <code>if</code> statement.</p>
<pre><code class=language-odin data-lang=odin>if x := foo(); x &lt; 0 {
	fmt.println(&quot;x is negative&quot;)
}
</code></pre><p>Variables declared inside an <code>if</code> initial statement are also available to any of the <code>else</code> blocks:</p>
<pre><code class=language-odin data-lang=odin>if x := foo(); x &lt; 0 {
	fmt.println(&quot;x is negative&quot;)
} else if x == 0 {
	fmt.println(&quot;x is zero&quot;)
} else {
	fmt.println(&quot;x is positive&quot;)
}
</code></pre><h3 id=switch-statement><code>switch</code> statement <a class=text-decoration-none href=#switch-statement>#</a></h3>
<p>A switch statement is another way to write a sequence of if-else statements. In Odin, the default case is denoted as a case without any expression.</p>
<pre><code class=language-odin data-lang=odin>package main

import &quot;core:fmt&quot;
import &quot;core:os&quot;

main :: proc() {
	switch arch := ODIN_ARCH; arch {
	case &quot;386&quot;:
		fmt.println(&quot;32 bit&quot;)
	case &quot;amd64&quot;:
		fmt.println(&quot;64 bit&quot;)
	case: // default
		fmt.println(&quot;Unsupported architecture&quot;)
	}
}
</code></pre><p>Odin&rsquo;s <code>switch</code> is like the one in C or C++, except that Odin only runs the selected case. This means that a <code>break</code> statement is not needed at the end of each case. Another important difference is that the case values need not be integers nor constants.</p>
<p>To achieve a C-like fall through into the next case block, the keyword <a href=#fallthrough-statement><code>fallthrough</code></a> can be used.</p>
<p>Switch cases are evaluated from top to bottom, stopping when a case succeeds. For example:</p>
<pre><code class=language-odin data-lang=odin>switch i {
case 0:
case foo():
}
</code></pre><p><code>foo()</code> does not get called if <code>i==0</code>. If all the case values are constants, the compiler may optimize the switch statement into a jump table (like C).</p>
<p>A <code>switch</code> statement without a condition is the same as <code>switch true</code>. This can be used to write a clean and long if-else chain and have the ability to <a href=#fallthrough-statement><code>break</code></a> if needed</p>
<pre><code class=language-odin data-lang=odin>switch {
case x &lt; 0:
	fmt.println(&quot;x is negative&quot;)
case x == 0:
	fmt.println(&quot;x is zero&quot;)
case:
	fmt.println(&quot;x is positive&quot;)
}
</code></pre><p>A <code>switch</code> statement can also use ranges like a range-based loop:</p>
<pre><code class=language-odin data-lang=odin>switch c {
case 'A'..'Z', 'a'..'z', '0'..'9':
	fmt.println(&quot;c is alphanumeric&quot;)
}

switch x {
case 0..&lt;10:
	fmt.println(&quot;units&quot;)
case 10..&lt;13:
	fmt.println(&quot;pre-teens&quot;)
case 13..&lt;20:
	fmt.println(&quot;teens&quot;)
case 20..&lt;30:
	fmt.println(&quot;twenties&quot;)
}
</code></pre><h4 id=partial-switch><code>#partial switch</code> <a class=text-decoration-none href=#partial-switch>#</a></h4>
<p>With <code>enum</code> values:</p>
<pre><code class=language-odin data-lang=odin>Foo :: enum {
	A,
	B,
	C,
	D,
}

f := Foo.A
switch f {
case .A: fmt.println(&quot;A&quot;)
case .B: fmt.println(&quot;B&quot;)
case .C: fmt.println(&quot;C&quot;)
case .D: fmt.println(&quot;D&quot;)
case:    fmt.println(&quot;?&quot;)
}

#partial switch f {
case .A: fmt.println(&quot;A&quot;)
case .D: fmt.println(&quot;D&quot;)
}
</code></pre><p>With <code>union</code> types (see <a href=#type-switch-statement>Type switch statement</a>)</p>
<pre><code class=language-odin data-lang=odin>Foo :: union {int, bool}
f: Foo = 123
switch in f {
case int:  fmt.println(&quot;int&quot;)
case bool: fmt.println(&quot;bool&quot;)
case:
}

#partial switch in f {
case bool: fmt.println(&quot;bool&quot;)
}
</code></pre><h3 id=defer-statement><code>defer</code> statement <a class=text-decoration-none href=#defer-statement>#</a></h3>
<p>A defer statement defers the execution of a statement until the end of the scope it is in.</p>
<p>The following will print <code>4</code> then <code>234</code>:</p>
<pre><code class=language-odin data-lang=odin>package main

import &quot;core:fmt&quot;

main :: proc() {
	x := 123
	defer fmt.println(x)
	{
		defer x = 4
		x = 2
	}
	fmt.println(x)

	x = 234
}
</code></pre><p>You can defer an entire block too:</p>
<pre><code class=language-odin data-lang=odin>{
	defer {
		foo()
		bar()
	}
	defer if cond {
		bar()
	}
}
</code></pre><p>Defer statements are executed in the reverse order that they were declared:</p>
<pre><code class=language-odin data-lang=odin>defer fmt.println(&quot;1&quot;)
defer fmt.println(&quot;2&quot;)
defer fmt.println(&quot;3&quot;)
</code></pre><p>Will print <code>3</code>, <code>2</code>, and then <code>1</code>.</p>
<p>A real world use case for <code>defer</code> may be something like the following:</p>
<pre><code class=language-odin data-lang=odin>f, err := os.open(&quot;my_file.txt&quot;)
if err != os.ERROR_NONE {
	// handle error
}
defer os.close(f)
// rest of code
</code></pre><p>In this case, it acts akin to an explicit C++ destructor however, the error handling is basic control flow.</p>
<p><strong>Note:</strong> The <code>defer</code> construct in Odin differs from Go&rsquo;s <code>defer</code>, which is function-exit and relies on a closure stack system.</p>
<h3 id=when-statement><code>when</code> statement <a class=text-decoration-none href=#when-statement>#</a></h3>
<p>The <code>when</code> statement is almost identical to the <code>if</code> statement but with some differences:</p>
<ul>
<li>Each condition must be a constant expression as a <code>when</code> statement is evaluated at compile time.</li>
<li>The statements within a branch do not create a new scope</li>
<li>The compiler checks the semantics and code <strong>only</strong> for statements that belong to the first condition that is <code>true</code></li>
<li>An initial statement is not allowed in a <code>when</code> statement</li>
<li><code>when</code> statements are allowed at file scope</li>
</ul>
<p>Example:</p>
<pre><code class=language-odin data-lang=odin>when ODIN_ARCH == &quot;386&quot; {
	fmt.println(&quot;32 bit&quot;)
} else when ODIN_ARCH == &quot;amd64&quot; {
	fmt.println(&quot;64 bit&quot;)
} else {
	fmt.println(&quot;Unsupported architecture&quot;)
}
</code></pre><p>The <code>when</code> statement is very useful for writing platform specific code. This is akin to the <code>#if</code> construct in C&rsquo;s preprocessor. However, in Odin, it is type checked.</p>
<h3 id=branch-statements>Branch statements <a class=text-decoration-none href=#branch-statements>#</a></h3>
<h4 id=break-statement><code>break</code> statement <a class=text-decoration-none href=#break-statement>#</a></h4>
<p>A for loop or a switch statement can be left prematurely with a <code>break</code> statement. It leaves the innermost construct, unless a label of a construct is given:</p>
<pre><code class=language-odin data-lang=odin>for cond {
	switch {
	case:
		if cond {
			break // break out of the `switch` statement
		}
	}

	break; // break out of the `for` statement
}

loop: for cond1 {
	for cond2 {
		break loop // leaves both loops
	}
}
</code></pre><h4 id=continue-statement><code>continue</code> statement <a class=text-decoration-none href=#continue-statement>#</a></h4>
<p>As in many programming languages, a <code>continue</code> statement starts the next iteration of a loop prematurely:</p>
<pre><code class=language-odin data-lang=odin>for cond {
	if get_foo() {
		continue
	}
	fmt.println(&quot;Hellope&quot;)
}
</code></pre><h4 id=fallthrough-statement><code>fallthrough</code> statement <a class=text-decoration-none href=#fallthrough-statement>#</a></h4>
<p>Odin&rsquo;s <code>switch</code> is like the one in C or C++, except that Odin only runs the selected case. This means that a <code>break</code> statement is not needed at the end of each case. Another important difference is that the case values need not be integers nor constants.</p>
<p><code>fallthrough</code> can be used to explicitly fall through into the next case block:</p>
<pre><code class=language-odin data-lang=odin>switch i {
case 0:
	foo()
	fallthrough
case 1:
	bar()
}
</code></pre><h2 id=procedures>Procedures <a class=text-decoration-none href=#procedures>#</a></h2>
<p>In Odin, a procedure is something that can do work, which some languages call <em>functions</em> or <em>methods</em>. A procedure literal in Odin is defined with the <code>proc</code> keyword:</p>
<pre><code class=language-odin data-lang=odin>fibonacci :: proc(n: int) -&gt; int {
	switch {
	case n &lt; 1:
		return 0
	case n == 1:
		return 1
	}
	return fibonacci(n-1) + fibonacci(n-2)
}

fmt.println(fibonacci(3))
</code></pre><p>For more information regarding value declarations in general, please see the <a href=/docs/faq>Odin FAQ</a>.</p>
<h3 id=parameters>Parameters <a class=text-decoration-none href=#parameters>#</a></h3>
<p>Procedures can take zero or many parameters. The following example is a basic procedure that multiplies two integers together:</p>
<pre><code class=language-odin data-lang=odin>multiply :: proc(x: int, y: int) -&gt; int {
	return x * y
}
fmt.println(multiply(137, 432))
</code></pre><p>When two or more consecutive parameters share a type, you can omit the other types from previous names, like with variable declarations. In this example: <code>x: int, y: int</code> can be shortened to <code>x, y: int</code>, for example:</p>
<pre><code class=language-odin data-lang=odin>multiply :: proc(x, y: int) -&gt; int {
	return x * y
}
fmt.println(multiply(137, 432))
</code></pre><p>Continuing the C family tradition, everything in Odin is passed by value. The procedure always gets a copy of the thing that has been passed, as if there was an assignment statement to the procedure parameter.</p>
<p>Passing a pointer value makes a copy of the pointer, not the data it points to. Slices, dynamic arrays, and maps behave like pointers in this case (Internally they are structures that contain values, which include pointers, and the &ldquo;structure&rdquo; is passed by value).</p>
<p>Parameters in a procedure body will be mutable, but as they are copies, they will not affect the original values.</p>
<h3 id=multiple-results>Multiple results <a class=text-decoration-none href=#multiple-results>#</a></h3>
<p>A procedure in Odin can return any number of results. For example:</p>
<pre><code class=language-odin data-lang=odin>swap :: proc(x, y: int) -&gt; (int, int) {
	return y, x
}
a, b := swap(1, 2)
fmt.println(a, b) // 2 1
</code></pre><h3 id=named-results>Named results <a class=text-decoration-none href=#named-results>#</a></h3>
<p>Return values in Odin may be named. If so, they are treated as variables defined at the top of the procedure, like input parameters. A <code>return</code> statement without arguments returns the named return value. &ldquo;Naked&rdquo; return statements should only be used in short procedures as it reduces clarity when reading.</p>
<pre><code class=language-odin data-lang=odin>do_math :: proc(input: int) -&gt; (x, y: int) {
	x = 2*input + 1
	y = 3*input / 5
	return x, y
}
do_math_with_naked_return :: proc(input: int) -&gt; (x, y: int) {
	x = 2*input + 1
	y = 3*input / 5
	return
}
</code></pre><h3 id=named-arguments>Named arguments <a class=text-decoration-none href=#named-arguments>#</a></h3>
<p>When calling a procedure, it is not clear in which order parameters might appear. Therefore, the arguments can be named, like a struct literal, to make it clear which argument a parameter is for:</p>
<pre><code class=language-odin data-lang=odin>create_window :: proc(title: string, x, y: int, width, height: int, monitor: ^Monitor) -&gt; (^Window, Window_Error) {...}

window, err := create_window(title=&quot;Hellope Title&quot;, monitor=nil, width=854, height=480, x=0, y=0)
</code></pre><p><strong>Note:</strong> Currently, mixing named and non-named arguments is not allowed. This is subject to change if it is deemed necessary.</p>
<h3 id=default-values>Default values <a class=text-decoration-none href=#default-values>#</a></h3>
<p>The <code>create_window</code> procedure may be easier to use if default values are provided, which will be used if they are not specified:</p>
<pre><code class=language-odin data-lang=odin>create_window :: proc(title: string, x := 0, y := 0, width := 854, height := 480, monitor: ^Monitor = nil) -&gt; (^Window, Window_Error) {...}

window1, err1 := create_window(&quot;Title1&quot;)
window2, err2 := create_window(title=&quot;Title1&quot;, width=640, height=360)
</code></pre><p><strong>Note:</strong> These default values must be compile time known values, such as a constant value or <code>nil</code> (if the type supports it).</p>
<h3 id=explicit-procedure-overloading>Explicit procedure overloading <a class=text-decoration-none href=#explicit-procedure-overloading>#</a></h3>
<p>Unlike other languages, Odin provides the ability to explicitly overload procedures:</p>
<pre><code class=language-odin data-lang=odin>bool_to_string :: proc(b: bool) -&gt; string {...}
int_to_string  :: proc(i: int)  -&gt; string {...}

to_string :: proc{bool_to_string, int_to_string}
</code></pre><h4 id=rationale-behind-explicit-overloading>Rationale behind explicit overloading <a class=text-decoration-none href=#rationale-behind-explicit-overloading>#</a></h4>
<p>The design goals of Odin were explicitness and simplicity. Implicit procedure overloading complicates the scoping system. In C++, you cannot nest procedures within procedures, so all procedure look-ups are done at the global scope. In Odin, procedures can be nested within procedures and, as a result, determining which procedure should be used, in the case of implicit overloading, is complex.</p>
<p>Explicit overloading has many advantages:</p>
<ul>
<li>Explicitness of what is overloaded</li>
<li>Able to refer to the specific procedure if needed</li>
<li>Clear which scope the entity name belongs to</li>
<li>Ability to specialize parametric polymorphic procedures if necessary, which have the same parameter but different bounds (see <a href=#where-clauses><code>where</code> clauses</a>)</li>
</ul>
<pre><code class=language-odin data-lang=odin>foo :: proc{
	foo_bar,
	foo_baz,
	foo_baz2,
	another_thing_entirely,
}
</code></pre><h2 id=basic-types>Basic types <a class=text-decoration-none href=#basic-types>#</a></h2>
<p>Odin&rsquo;s basic types are:</p>
<pre><code class=language-odin data-lang=odin>bool b8 b16 b32 b64 // booleans

// integers
int  i8 i16 i32 i64 i128
uint u8 u16 u32 u64 u128 uintptr

// endian specific integers
i16le i32le i64le i128le u16le u32le u64le u128le // little endian
i16be i32be i64be i128be u16be u32be u64be u128be // big endian

f16 f32 f64 // floating point numbers

// endian specific floating point numbers
f16le f32le f64le // little endian
f16be f32be f64be // big endian

complex32 complex64 complex128 // complex numbers

quaternion64 quaternion128 quaternion256 // quaternion numbers

rune // signed 32 bit integer
	 // represents a Unicode code point
	 // is a distinct type to `i32`

// strings
string cstring

// raw pointer type
rawptr

// runtime type information specific type
typeid
any
</code></pre><p>The <code>int</code>, <code>uint</code>, and <code>uintptr</code> types are pointer sized. When you need an integer value, you should default to using <code>int</code> unless you have a specific reason to use a sized or unsigned integer type</p>
<p><strong>Note:</strong> The Odin <code>string</code> type stores the pointer to the data and the length of the string. <code>cstring</code> is used to interface with foreign libraries written in/for C that use zero-terminated strings.</p>
<h3 id=zero-values>Zero values <a class=text-decoration-none href=#zero-values>#</a></h3>
<p>Variables declared without an explicit initial value are given their <em>zero</em> value.</p>
<p>The zero value is:</p>
<ul>
<li><code>0</code> for numeric and rune types</li>
<li><code>false</code> for boolean types</li>
<li><code>""</code> (the empty string) for strings</li>
<li><code>nil</code> for pointer, typeid, and any types.</li>
</ul>
<p>The expression <code>{}</code> can be used for all types to act as a zero type. This is not recommended as it is not clear and if a type has a specific zero value shown above, please prefer that.</p>
<h3 id=type-conversion>Type conversion <a class=text-decoration-none href=#type-conversion>#</a></h3>
<p>The expression <code>T(v)</code> converts the value <code>v</code> to the type <code>T</code>.</p>
<pre><code class=language-odin data-lang=odin>i: int = 123
f: f64 = f64(i)
u: u32 = u32(f)
</code></pre><p>or with type inference:</p>
<pre><code class=language-odin data-lang=odin>i := 123
f := f64(i)
u := u32(f)
</code></pre><p>Unlike C, assignments between values of a different type require an explicit conversion.</p>
<h4 id=cast-operator>Cast operator <a class=text-decoration-none href=#cast-operator>#</a></h4>
<p>The <code>cast</code> operator can also be used to do the same thing:</p>
<pre><code class=language-odin data-lang=odin>i := 123
f := cast(f64)i
u := cast(u32)f
</code></pre><p>This is useful is some contexts but has the same semantic meaning.</p>
<h4 id=transmute-operator>Transmute operator <a class=text-decoration-none href=#transmute-operator>#</a></h4>
<p>The <code>transmute</code> operator is a bit cast conversion between two types of the same size:</p>
<pre><code class=language-odin data-lang=odin>f := f32(123)
u := transmute(u32)f
</code></pre><p>This is akin to doing the following pointer cast manipulations:</p>
<pre><code class=language-odin data-lang=odin>f := f32(123)
u := (^u32)(&amp;f)^
</code></pre><p>However, <code>transmute</code> does not require taking the address of the value in question, which may not be possible for many expressions.</p>
<h3 id=untyped-types>Untyped types <a class=text-decoration-none href=#untyped-types>#</a></h3>
<p>In the Odin type system, certain expressions will have an &ldquo;untyped&rdquo; type. An untyped type can implicitly convert to a &ldquo;typed&rdquo; type. The following are the</p>
<h3 id=auto-cast-operation>Auto cast operation <a class=text-decoration-none href=#auto-cast-operation>#</a></h3>
<p>The <code>auto_cast</code> operator automatically casts an expression to the destination&rsquo;s type if possible:</p>
<pre><code class=language-odin data-lang=odin>x: f32 = 123
y: int = auto_cast x
</code></pre><p><strong>Note:</strong> This operation is only recommended to be used for prototyping and quick tests. Please do not abuse it.</p>
<h3 id=built-in-constants-and-values>Built-in constants and values <a class=text-decoration-none href=#built-in-constants-and-values>#</a></h3>
<p>There are a few built-in constants and values in Odin which have different uses:</p>
<pre><code class=language-odin data-lang=odin>false // untyped boolean constant equivalent to the expression 0!=0
true  // untyped boolean constant equivalent to the expression 0==0
nil   // untyped nil value used for certain values
---   // untyped undefined value used to explicitly not initialize a variable
</code></pre><p><code>---</code> is useful if you want to explicitly not initialize a variable with any default value:</p>
<pre><code class=language-odin data-lang=odin>x: int // initialized with its zero value
y: int = --- // uses uninitialized memory
</code></pre><p>This is the default behaviour in C.</p>
<h3 id=cstring-type><code>cstring</code> type <a class=text-decoration-none href=#cstring-type>#</a></h3>
<p>The <code>cstring</code> type is a c-style string value, which is zero-terminated. It is equivalent to <code>char const *</code> in C. Its primary purpose is for easy interfacing with C. Please see the <a href=#foreign-system>foreign system</a> for more information.</p>
<p>A <code>cstring</code> is easily convertible to an Odin <code>string</code>. However, to convert a <code>string</code> to a <code>cstring</code>, it requires allocations if the value is not constant.</p>
<pre><code class=language-odin data-lang=odin>str:  string  = &quot;Hellope&quot;
cstr: cstring = &quot;Hellope&quot; // constant literal
cstr2 := string(cstr)     // O(n) conversion as it requires search from the zero-terminator
nstr  := len(str)  // O(1)
ncstr := len(cstr) // O(n)
</code></pre><h2 id=advanced-types>Advanced types <a class=text-decoration-none href=#advanced-types>#</a></h2>
<h3 id=type-alias>Type alias <a class=text-decoration-none href=#type-alias>#</a></h3>
<p>You can alias a named type with another name:</p>
<pre><code class=language-odin data-lang=odin>My_Int :: int
#assert(My_Int == int)
</code></pre><h3 id=distinct-types>Distinct types <a class=text-decoration-none href=#distinct-types>#</a></h3>
<p>A distinct type allows for the creation of a new type with the same underlying semantics.</p>
<pre><code class=language-odin data-lang=odin>My_Int :: distinct int
#assert(My_Int != int)
</code></pre><p>Aggregate types (struct, enum, union) will always be distinct even when named.</p>
<pre><code class=language-odin data-lang=odin>Foo :: struct {}
#assert(Foo != struct{})
</code></pre><h3 id=fixed-arrays>Fixed arrays <a class=text-decoration-none href=#fixed-arrays>#</a></h3>
<p>An array is a simplified fixed length container. Each element in an array has the same type. An array&rsquo;s index can be any integer, character, or enumeration type.</p>
<p>An array can be constructed like the following:</p>
<pre><code class=language-odin data-lang=odin>x := [5]int{1, 2, 3, 4, 5}
for i in 0..4 {
	fmt.println(x[i])
}
</code></pre><p>The notation <code>x[i]</code> is used to access the i-th element of <code>x</code>; and 0-index based (like C).</p>
<p>The built-in <code>len</code> proc returns the array&rsquo;s length.</p>
<pre><code class=language-odin data-lang=odin>x: [5]int
#assert(len(x) == 5)
</code></pre><p>Array access is always bounds checked (at compile-time and at runtime). This can be disabled and enabled at a per block level with the <code>#no_bounds_check</code> and <code>#bounds_check</code> directives, respectively:</p>
<pre><code class=language-odin data-lang=odin>#no_bounds_check {
	x[n] = 123 // n could be in or out of range of valid indices
}
</code></pre><p><code>#no_bounds_check</code> can be used to improve performance when the bounds are known to not exceed.</p>
<h4 id=array-programming>Array programming <a class=text-decoration-none href=#array-programming>#</a></h4>
<p>Odin&rsquo;s fixed length arrays support <a href=https://en.wikipedia.org/wiki/Array_programming>array programming</a>.</p>
<p>Example:</p>
<pre><code class=language-odin data-lang=odin>Vector3 :: [3]f32
a := Vector3{1, 4, 9}
b := Vector3{2, 4, 8}
c := a + b  // {3, 8, 17}
d := a * b  // {2, 16, 72}
e := c != d // true
</code></pre><p><strong>n.b.</strong> Odin also supports <a href=/docs/overview/#matrix-type><code>matrix</code> types</a>.</p>
<h5 id=swizzle-operations>Swizzle Operations <a class=text-decoration-none href=#swizzle-operations>#</a></h5>
<pre><code class=language-odin data-lang=odin>a := [3]f32{1, 2, 3}
b := swizzle(a, 2, 1, 0)
assert(b == [3]f32{3, 2, 1})

c := swizzle(a, 0, 0)
assert(c == [2]f32{1, 1})
assert(c == 1)
</code></pre><pre><code class=language-odin data-lang=odin>Vector3 :: distinct [3]f32
a := Vector3{1, 2, 3}
b := Vector3{5, 6, 7}
c := (a * b)/2 + 1
d := c.x + c.y + c.z
fmt.printf(&quot;%.1f\n&quot;, d) // 22.0

cross :: proc(a, b: Vector3) -&gt; Vector3 {
	i := swizzle(a, 1, 2, 0) * swizzle(b, 2, 0, 1)
	j := swizzle(a, 2, 0, 1) * swizzle(b, 1, 2, 0)
	return i - j
}

cross_shorter :: proc(a, b: Vector3) -&gt; Vector3 {
	i := a.yzx * b.zxy
	j := a.zxy * b.yzx
	return i - j
}

blah :: proc(a: Vector3) -&gt; f32 {
	return a.x + a.y + a.z
}

x := cross(a, b)
fmt.println(x)
fmt.println(blah(x))
</code></pre><h3 id=slices>Slices <a class=text-decoration-none href=#slices>#</a></h3>
<p>Slices look similar to arrays however, their length is not known at compile time. The type <code>[]T</code> is a slice with elements of type <code>T</code>. In practice, slices are much more common than arrays.</p>
<p>A slice is formed by specifying two indices, a low and high bound, separated by a colon:</p>
<pre><code class=language-odin data-lang=odin>a[low : high]
</code></pre><p>This selects a half-open range which includes the lower element, but excludes the higher element.</p>
<pre><code class=language-odin data-lang=odin>fibonaccis := [6]int{0, 1, 1, 2, 3, 5}
s: []int = fibonaccis[1:4] // creates a slice which includes elements 1 through 3
fmt.println(s) // 1, 1, 2
</code></pre><p>Slices are like references to arrays; they do not store any data, rather they describe a section, or slice, of underlying data.</p>
<p>Internally, a slice stores a pointer to the data and an integer to store the length of the slice.</p>
<p>The built-in <code>len</code> proc returns the array&rsquo;s length.</p>
<pre><code class=language-odin data-lang=odin>x: []int = ...
length_of_x := len(x)
</code></pre><h4 id=slice-literals>Slice literals <a class=text-decoration-none href=#slice-literals>#</a></h4>
<p>A slice literal is like an array literal without the length.
This is an array literal:</p>
<pre><code class=language-odin data-lang=odin>[3]int{1, 6, 3}
</code></pre><p>This is a slice literal which creates the same array as above, and then creates a slice that references it:</p>
<pre><code class=language-odin data-lang=odin>[]int{1, 6, 3}
</code></pre><h4 id=slice-shorthand>Slice shorthand <a class=text-decoration-none href=#slice-shorthand>#</a></h4>
<p>For the array:</p>
<pre><code class=language-odin data-lang=odin>a: [6]int
</code></pre><p>these slice expressions are equivalent:</p>
<pre><code class=language-odin data-lang=odin>a[0:6]
a[:6]
a[0:]
a[:]
</code></pre><h4 id=nil-slices>Nil slices <a class=text-decoration-none href=#nil-slices>#</a></h4>
<p>The zero value of a slice is <code>nil</code>. A nil slice has a length of 0 and does not point to any underlying memory. Slices can be compared against <code>nil</code> and nothing else.</p>
<pre><code class=language-odin data-lang=odin>s: []int
if s == nil {
	fmt.println(&quot;s is nil!&quot;)
}
</code></pre><h3 id=dynamic-arrays>Dynamic arrays <a class=text-decoration-none href=#dynamic-arrays>#</a></h3>
<p>Dynamic arrays are similar to slices, but their lengths may change during runtime. Dynamic arrays are resizeable and they are allocated using the current <a href=#implicit-context-system>context</a>&rsquo;s allocator.</p>
<pre><code class=language-odin data-lang=odin>x: [dynamic]int
</code></pre><p>Along with the built-in proc <code>len</code>, dynamic arrays also have <code>cap</code> which can used to determine the dynamic array&rsquo;s current underlying capacity.</p>
<h4 id=appending-to-a-dynamic-array>Appending to a dynamic array <a class=text-decoration-none href=#appending-to-a-dynamic-array>#</a></h4>
<p>It is common to append new elements to a dynamic array; this can be done so with the built-in <code>append</code> proc.</p>
<pre><code class=language-odin data-lang=odin>x: [dynamic]int
append(&amp;x, 123)
append(&amp;x, 4, 1, 74, 3) // append multiple values at once
</code></pre><h4 id=making-and-deleting-slices-and-dynamic-arrays>Making and deleting slices and dynamic arrays <a class=text-decoration-none href=#making-and-deleting-slices-and-dynamic-arrays>#</a></h4>
<p>Slices and dynamic arrays can be explicitly allocated with the built-in <code>make</code> proc.</p>
<pre><code class=language-odin data-lang=odin>a := make([]int, 6)           // len(a) == 6
b := make([dynamic]int, 6)    // len(b) == 6, cap(b) == 6
c := make([dynamic]int, 0, 6) // len(c) == 0, cap(c) == 6
</code></pre><p>Slices and dynamic arrays can be deleted with the built-in <code>delete</code> proc.</p>
<pre><code class=language-odin data-lang=odin>delete(a)
delete(b)
delete(c)
</code></pre><p><strong>Note:</strong> Slices created with <code>make</code> must be deallocated with <code>delete</code>, whereas a slice literal does not need to be deleted since it is just a slice of an underlying array.</p>
<p><strong>Note:</strong> There is not automatic memory management in Odin. Slices may not be allocated using an <a href=#allocators>allocator</a>.</p>
<h3 id=enumerations>Enumerations <a class=text-decoration-none href=#enumerations>#</a></h3>
<p>Enumeration types define a new type whose values consist of the ones specified. The values are ordered, for example:</p>
<pre><code class=language-odin data-lang=odin>Direction :: enum{North, East, South, West}
</code></pre><p>The following holds:</p>
<pre><code class=language-odin data-lang=odin>int(Direction.North) == 0
int(Direction.East)  == 1
int(Direction.South) == 2
int(Direction.West)  == 3
</code></pre><p>Enum fields can be assigned an explicit value:</p>
<pre><code class=language-odin data-lang=odin>Foo :: enum {
	A,
	B = 4, // Holes are valid
	C = 7,
	D = 1337,
}
</code></pre><p>If an enumeration requires a specific size, a backing integer type can be specified. By default, <code>int</code> is used as the backing type for an enumeration.</p>
<pre><code class=language-odin data-lang=odin>Foo :: enum u8 {A, B, C} // Foo will only be 8 bits
</code></pre><p>Odin supports implicit selector expressions for enums:</p>
<pre><code class=language-odin data-lang=odin>Foo :: enum {A, B, C}

f: Foo
f = .A

BAR :: bit_set[Foo]{.B, .C}

switch f {
case .A:
	fmt.println(&quot;foo&quot;)
case .B:
	fmt.println(&quot;bar&quot;)
case .C:
	fmt.println(&quot;baz&quot;)
}
</code></pre><p><a href=#using-statement><code>using</code></a> can also be used with an enumeration to bring the fields into the current scope:</p>
<pre><code class=language-odin data-lang=odin>main :: proc() {
	Foo :: enum {A, B, C}
	using Foo
	a := A

	using Bar :: enum {X, Y, Z}
	x := X
}
</code></pre><h4 id=implicit-selector-expression>Implicit Selector Expression <a class=text-decoration-none href=#implicit-selector-expression>#</a></h4>
<p>An <em>implicit selector expression</em> is an abbreviated way to access a member of an enumeration, in a context where type inference can determine the implied type. It has the following form:</p>
<pre><code class=language-odin data-lang=odin>.member_name
</code></pre><p>For example:</p>
<pre><code class=language-odin data-lang=odin>Direction :: enum{North, East, South, West}
d: Direction
d = Direction.East
d = .East
</code></pre><p><strong>Note:</strong> This is preferred to <a href=#using-statement><code>using</code></a> an enumeration as <code>using</code> does pollute the current scope.</p>
<h3 id=bit-sets>Bit sets <a class=text-decoration-none href=#bit-sets>#</a></h3>
<p>The <code>bit_set</code> type models the mathematical notion of a set. A bit_set&rsquo;s element type can be either an enumeration or a range:</p>
<pre><code class=language-odin data-lang=odin>Direction :: enum{North, East, South, West}

Direction_Set :: bit_set[Direction]

Char_Set :: bit_set['A'..'Z']

Number_Set :: bit_set[0..&lt;10] // bit_set[0..9]
</code></pre><p>Bit sets are implemented as bit vectors internally for high performance. The zero value of a bit set is either <code>nil</code> or <code>{}</code>.</p>
<pre><code class=language-odin data-lang=odin>x: Char_Set
x = {'A', 'B', 'Y'}
y: Direction_Set
y = {.North, .West}
</code></pre><p>Bit sets support the following operations:</p>
<ul>
<li><code>A + B</code> - union of two sets (equivalent to <code>A | B</code>)</li>
<li><code>A - B</code> - difference of two sets (A without B&rsquo;s elements) (equivalent to <code>A &~ B</code>)</li>
<li><code>A & B</code> - intersection of two sets</li>
<li><code>A | B</code> - union of two sets (equivalent to <code>A + B</code>)</li>
<li><code>A &~ B</code> - difference of two sets (A without B&rsquo;s elements) (equivalent to <code>A - B</code>)</li>
<li><code>A ~ B</code> - symmetric difference (Elements that are in A and B but not both)</li>
<li><code>A == B</code> - set equality</li>
<li><code>A != B</code> - set inequality</li>
<li><code>A &lt;= B</code> - subset relation (A is a subset of B or equal to B)</li>
<li><code>A &lt; B</code> - strict subset relation (A is a proper subset of B)</li>
<li><code>A >= B</code> - superset relation (A is a superset of B or equal to B)</li>
<li><code>A > B</code> - strict superset relation (A is a proper superset of B)</li>
<li><code>e in A</code> - set membership (A contains element e)</li>
<li><code>e not_in A</code> - A does not contain element e</li>
<li><code>incl(&A, elem)</code> - same as <code>A += {elem}</code></li>
<li><code>excl(&A, elem)</code> - same as <code>A -= {elem}</code></li>
</ul>
<p>Bit sets are often used to denote flags. This is much cleaner than defining integer constants that need to be bitwise or-ed together.</p>
<p>If a bit set requires a specific size, the underlying integer type can be specified:</p>
<pre><code class=language-odin data-lang=odin>Char_Set :: bit_set['A'..'Z'; u64];
#assert(size_of(Char_Set) == size_of(u64))
</code></pre><h3 id=pointers>Pointers <a class=text-decoration-none href=#pointers>#</a></h3>
<p>Odin has pointers. A pointer is a memory address of a value. The type <code>^T</code> is a pointer to a <code>T</code> value. Its zero value is <code>nil</code>.</p>
<pre><code class=language-odin data-lang=odin>p: ^int
</code></pre><p>The <code>&</code> operator takes the address to its operand (if possible):</p>
<pre><code class=language-odin data-lang=odin>i := 123;
p := &amp;i;
</code></pre><p>The <code>^</code> operator dereferences the pointer&rsquo;s underlying value:</p>
<pre><code class=language-odin data-lang=odin>fmt.println(p^) // read  i through the pointer p
p^ = 1337;       // write i through the pointer p
</code></pre><p><strong>Note:</strong> C programmers may be used to using <code>*</code> to denote pointers. In Odin, the <code>^</code> syntax is borrowed from Pascal. This is to keep the convention of the type on the left and its usage on the right:</p>
<pre><code class=language-odin data-lang=odin>p: ^int // ^ on the left
x := p^; // ^ on the right
</code></pre><p><strong>Note:</strong> Unlike C, Odin has no pointer arithmetic. If you need a form of pointer arithmetic, please use the <code>ptr_offset</code> and <code>ptr_sub</code> procedures in the <code>"core:mem"</code> package.</p>
<h3 id=structs>Structs <a class=text-decoration-none href=#structs>#</a></h3>
<p>A <code>struct</code> is a record type in Odin. It is a collection of fields. Struct fields are accessed by using a dot:</p>
<pre><code class=language-odin data-lang=odin>Vector2 :: struct {
	x: f32,
	y: f32,
}
v := Vector2{1, 2}
v.x = 4
fmt.println(v.x)
</code></pre><p>Struct fields can be accessed through a struct pointer:</p>
<pre><code class=language-odin data-lang=odin>v := Vector2{1, 2}
p := &amp;v
p.x = 1335
fmt.println(v)
</code></pre><p>We could write <code>p^.x</code>, however, it is to nice abstract the ability to not explicitly dereference the pointer. This is very useful when refactoring code to use a pointer rather than a value, and vice versa.</p>
<h4 id=struct-literals>Struct literals <a class=text-decoration-none href=#struct-literals>#</a></h4>
<p>A struct literal can be denoted by providing the struct&rsquo;s type followed by <code>{}</code>. A struct literal must either provide all the arguments or none:</p>
<pre><code class=language-odin data-lang=odin>Vector3 :: struct {
	x, y, z: f32,
}
v: Vector3
v = Vector3{} // Zero value
v = Vector3{1, 4, 9}
</code></pre><p>You can list just a subset of the fields if you specify the field by name (the order of the named fields does not matter):</p>
<pre><code class=language-odin data-lang=odin>v := Vector3{z=1, y=2}
assert(v.x == 0)
assert(v.y == 2)
assert(v.z == 1)
</code></pre><h4 id=struct-tags>Struct tags <a class=text-decoration-none href=#struct-tags>#</a></h4>
<p>Structs can be tagged with different memory layout and alignment requirements:</p>
<pre><code class=language-odin data-lang=odin>struct #align 4 {...} // align to 4 bytes
struct #packed {...} // remove padding between fields
struct #raw_union {...} // all fields share the same offset (0). This is the same as C's union
</code></pre><h3 id=unions>Unions <a class=text-decoration-none href=#unions>#</a></h3>
<p>A <code>union</code> in Odin is a discriminated union, also known as a tagged union or sum type. The zero value of a union is <code>nil</code>.</p>
<pre><code class=language-odin data-lang=odin>Value :: union {
	bool,
	i32,
	f32,
	string,
}
v: Value
v = &quot;Hellope&quot;

// type assert that `v` is a `string` and panic otherwise
s1 := v.(string)

// type assert but with an explicit boolean check. This will not panic
s2, ok := v.(string)
</code></pre><h4 id=type-switch-statement>Type switch statement <a class=text-decoration-none href=#type-switch-statement>#</a></h4>
<p>A type switch is a construct that allows several type assertions in series. A type switch is like a regular switch statement, but the cases are types (not values). For a union, the only case types allowed are that of the union.</p>
<pre><code class=language-odin data-lang=odin>value: Value = ...
switch v in value {
case string:
	#assert(type_of(v) == string)

case bool:
	#assert(type_of(v) == bool)

case i32, f32:
	// This case allows for multiple types, therefore we cannot know which type to use
	// `v` remains the original union value.
	#assert(type_of(v) == Value)
case:
	// Default case
	// In this case, it is `nil`
}
</code></pre><h4 id=union-tags>Union tags <a class=text-decoration-none href=#union-tags>#</a></h4>
<p>The <code>#no_nil</code> tag can be applied to the union type to state that it does not have a <code>nil</code> value, and the first variant is its default type:</p>
<pre><code class=language-odin data-lang=odin>Value :: union #no_nil {bool, string}
v: Value
_, ok := v.(bool)
assert(ok)
</code></pre><p>This is useful in very limited cases, and if it is added, there must be at least two variants.</p>
<p>Unions also have the <code>#align</code> tag, like structures:</p>
<pre><code class=language-odin data-lang=odin>union #align 4 {...} // align to 4 bytes
</code></pre><h3 id=maps>Maps <a class=text-decoration-none href=#maps>#</a></h3>
<p>A <code>map</code> maps keys to values. The zero value of a map is <code>nil</code>. A <code>nil</code> map has no keys. The built-in <code>make</code> proc returns an initialized map using the current <a href=#implicit-context-system>context</a>, and <code>delete</code> can be used to delete a map.</p>
<pre><code class=language-odin data-lang=odin>m := make(map[string]int)
defer delete(m)
m[&quot;Bob&quot;] = 2
fmt.println(m[&quot;Bob&quot;])
</code></pre><p>To insert or update an element of a map:</p>
<pre><code class=language-odin data-lang=odin>m[key] = elem
</code></pre><p>To retrieve an element:</p>
<pre><code class=language-odin data-lang=odin>elem = m[key]
</code></pre><p>To remove an element:</p>
<pre><code class=language-odin data-lang=odin>delete_key(&amp;m, key)
</code></pre><p>If an element of a key does not exist, the zero value of the element will be returned. Checking to see if an element exists can be done in two ways:</p>
<pre><code class=language-odin data-lang=odin>elem, ok := m[key] // `ok` is true if the element for that key exists
</code></pre><p>or</p>
<pre><code class=language-odin data-lang=odin>ok := key in m // `ok` is true if the element for that key exists
</code></pre><p>The first approach is called the &ldquo;comma ok idiom&rdquo;.</p>
<p>You can also initialize maps with map literals:</p>
<pre><code class=language-odin data-lang=odin>m := map[string]int{
	&quot;Bob&quot; = 2,
	&quot;Chloe&quot; = 5,
}
</code></pre><h3 id=procedure-type>Procedure type <a class=text-decoration-none href=#procedure-type>#</a></h3>
<p>A procedure type is internally a pointer to a procedure in memory. <code>nil</code> is the zero value a procedure type.</p>
<p>Examples:</p>
<pre><code class=language-odin data-lang=odin>proc(x: int) -&gt; bool
proc(c: proc(x: int) -&gt; bool) -&gt; (i32, f32)
</code></pre><h4 id=calling-conventions>Calling conventions <a class=text-decoration-none href=#calling-conventions>#</a></h4>
<p>Odin supports the following calling conventions:</p>
<ul>
<li><strong>odin</strong> - default convention used for an Odin <strong>proc</strong>. It is the same as <strong>cdecl</strong> but passes an implicit <code>context</code> pointer on each call. (<strong>Note:</strong> This is subject to change)</li>
<li><strong>contextless</strong> - This is the same as <strong>odin</strong> but without the implicit <code>context</code> pointer.</li>
<li><strong>stdcall</strong> or <strong>std</strong> &ndash; This is the stdcall convention as specified by Microsoft.</li>
<li><strong>cdecl</strong> or <strong>c</strong> &ndash; This is the default calling convention generated of a procedure in C.</li>
<li><strong>fastcall</strong> or <strong>fast</strong> - This is a compiler dependent calling convention.</li>
<li><strong>none</strong> - This is a compiler dependent calling convention which will do nothing to parameters.</li>
</ul>
<p>Most calling conventions exist only to interface with foreign Windows code.</p>
<p>The default calling convention is <strong>odin</strong>, unless it is within a <code>foreign</code> block, where it is then <strong>cdecl</strong>.</p>
<p>A procedure type with a different calling convention can be declared like the following:</p>
<pre><code class=language-odin data-lang=odin>proc &quot;c&quot; (n: i32, data: rawptr)
proc &quot;contextless&quot; (s: []int)
</code></pre><p>Procedure types are only compatible with the procedures that have the same calling convention and parameter types.</p>
<h3 id=typeid-type>&lsquo;typeid&rsquo; type <a class=text-decoration-none href=#typeid-type>#</a></h3>
<p>A <code>typeid</code> is a unique identifier for an Odin type. This construct is used by the <code>any</code> type to denote what the underlying data&rsquo;s type is.</p>
<pre><code class=language-odin data-lang=odin>a := typeid_of(bool)
i: int = 123
b := typeid_of(type_of(i))
</code></pre><p>A <code>typeid</code> can be mapped to relevant type information which can be used in applications such as printing types and editing data:</p>
<pre><code class=language-odin data-lang=odin>import &quot;core:runtime&quot;

main :: proc() {
	u := u8(123)
	id := typeid_of(type_of(u))
	info: ^runtime.Type_Info
	info = type_info_of(id)
}
</code></pre><h3 id=any-type>&lsquo;any&rsquo; Type <a class=text-decoration-none href=#any-type>#</a></h3>
<p>An <code>any</code> type can reference any data type. Internally it contains a pointer to the underlying data and its relevant <code>typeid</code>. This is a very useful construct in order to have a runtime type safe printing procedure.</p>
<p><strong>Note:</strong> The <code>any</code> value is only valid for as long as the underlying data is still valid. Passing a literal to an <code>any</code> will allocate the literal in the current stack frame.</p>
<p><strong>Note:</strong> It is highly recommended that you <strong>do not</strong> use this unless you know what you are doing. Its primary use is for printing procedures.</p>
<h3 id=multi-pointers>Multi Pointers <a class=text-decoration-none href=#multi-pointers>#</a></h3>
<p>Multi-Pointers in Odin are a way to describe <a href=#foreign-system><code>foreign</code></a> (C-like) pointers which act like arrays (pointers that map to multiple items). The type <code>[^]T</code> is a multi-pointer to T value(s). Its zero value is <code>nil</code>.</p>
<pre><code class=language-odin data-lang=odin>p: [^]int
</code></pre><p>What multi-pointers support:</p>
<ul>
<li>Index (without any bounds checking)</li>
<li>Slicing (bounds checking on if both the low and high operands are given)</li>
<li>Implicit conversions between <code>^T</code> and <code>[^]T</code></li>
<li>Implicit conversion to <code>rawptr</code> (like all pointers)</li>
</ul>
<p>What multi-pointers DO NOT SUPPORT:</p>
<ul>
<li>Dereferencing (which makes it closer to a slim-slice than a pointer)</li>
</ul>
<p>The main purpose of this type is to aid with <code>foreign</code> code and act as a way to auto-document functionality and allow for easier transition to Odin code, especially converting pointers into slices.</p>
<p>The following are the rules for indexing and slicing for multi-pointers, and what type they produce depending on the operands given:</p>
<pre><code>x: [^]T = ...

x[i]   -&gt; T
x[:]   -&gt; [^]T
x[i:]  -&gt; [^]T
x[:n]  -&gt; []T
x[i:n] -&gt; []T
</code></pre><p><strong>Note:</strong> The name of mutli-pointers may be subject to change.</p>
<h3 id=soa-data-types>SOA Data Types <a class=text-decoration-none href=#soa-data-types>#</a></h3>
<p><em>Array of Structures (AoS)</em>, <em>Structure of Arrays (SoA)</em>, and <em>Array of Structures of Arrays (AoSoA)</em> refer to differing ways to arrange a sequence of data records in memory, with regard to interleaving. These are of interest in SIMD and SIMT programming.</p>
<h4 id=soa-struct-arrays>SOA Struct Arrays <a class=text-decoration-none href=#soa-struct-arrays>#</a></h4>
<pre><code class=language-odin data-lang=odin>Vector3 :: struct {x, y, z: f32}

N :: 2
v_aos: [N]Vector3
v_aos[0].x = 1
v_aos[0].y = 4
v_aos[0].z = 9

fmt.println(len(v_aos))
fmt.println(v_aos[0])
fmt.println(v_aos[0].x)
fmt.println(&amp;v_aos[0].x)

v_aos[1] = {0, 3, 4}
v_aos[1].x = 2
fmt.println(v_aos[1])
fmt.println(v_aos)

v_soa: #soa[N]Vector3

v_soa[0].x = 1
v_soa[0].y = 4
v_soa[0].z = 9


// Same syntax as AOS and treat as if it was an array
fmt.println(len(v_soa))
fmt.println(v_soa[0])
fmt.println(v_soa[0].x)
fmt.println(&amp;v_soa[0].x)
v_soa[1] = {0, 3, 4}
v_soa[1].x = 2
fmt.println(v_soa[1])

// Can use SOA syntax if necessary
v_soa.x[0] = 1
v_soa.y[0] = 4
v_soa.z[0] = 9
fmt.println(v_soa.x[0])

// Same pointer addresses with both syntaxes
assert(&amp;v_soa[0].x == &amp;v_soa.x[0])


// Same fmt printing
fmt.println(v_aos)
fmt.println(v_soa)
</code></pre><p>Works with arrays of length &lt;= 4 which have the implicit fields xyzw/rgba</p>
<pre><code class=language-odin data-lang=odin>Vector3 :: distinct [3]f32

N :: 2
v_aos: [N]Vector3
v_aos[0].x = 1
v_aos[0].y = 4
v_aos[0].z = 9

v_soa: #soa[N]Vector3

v_soa[0].x = 1
v_soa[0].y = 4
v_soa[0].z = 9
</code></pre><h4 id=soa-struct-slices-and-dynamic-arrays>SOA Struct Slices and Dynamic Arrays <a class=text-decoration-none href=#soa-struct-slices-and-dynamic-arrays>#</a></h4>
<p>Fixed-length SOA types can be sliced to produce SOA slices.</p>
<pre><code class=language-odin data-lang=odin>Vector3 :: struct {x: i8, y: i16, z: f32};

N :: 3
v: #soa[N]Vector3
v[0].x = 1
v[0].y = 4
v[0].z = 9

s: #soa[]Vector3
s = v[:]
assert(len(s) == N)
fmt.println(s)
fmt.println(s[0].x)

a := s[1:2]
assert(len(a) == 1)
fmt.println(a)
</code></pre><p>To be complete with SOA slices, Odin also supports SOA dynamic arrays.</p>
<pre><code class=language-odin data-lang=odin>d: #soa[dynamic]Vector3;

append_soa(&amp;d, Vector3{1, 2, 3}, Vector3{4, 5, 9}, Vector3{-4, -4, 3})
fmt.println(d)
fmt.println(len(d))
fmt.println(cap(d))
fmt.println(d[:])
</code></pre><h4 id=soa_zip-and-soa_unzip><code>soa_zip</code> and <code>soa_unzip</code> <a class=text-decoration-none href=#soa_zip-and-soa_unzip>#</a></h4>
<p>SOA is not just useful for high performance scenarios but also for everyday tasks which are normally only achieveable in higher level languages. <code>soa_zip</code> is a built-in procedure which allows the user to treat multiple slices as if they are part of the same data structures, utilizing the power of SOA.</p>
<pre><code class=language-odin data-lang=odin>x := []i32{1, 3, 9}
y := []f32{2, 4, 16}
z := []b32{true, false, true}

// produce an #soa slice with the normal slices passed
s := soa_zip(a=x, b=y, c=z)

// iterate over the #soa slice
for v, i in s {
	fmt.println(v, i) // exactly the same as s[i]
	// NOTE: 'v' is NOT a temporary value but has a specialized addressing mode
	// which means that when accessing v.a etc, it does the correct transformation
	// internally:
	//         s[i].a === s.a[i]
	fmt.println(v.a, v.b, v.c)
}
</code></pre><p><code>soa_unzip</code> is a built-in procedure which allows the user to recover the slices from an <code>#soa</code> slice.</p>
<pre><code class=language-odin data-lang=odin>// Recover the slices from the #soa slice
a, b, c := soa_unzip(s)
fmt.println(a, b, c)
</code></pre><h3 id=matrix-type><code>matrix</code> type <a class=text-decoration-none href=#matrix-type>#</a></h3>
<p>A <code>matrix</code> is a <a href=https://wikipedia.org/wiki/Matrix_(mathematics)>mathematical type</a> built into Odin. It is a regular array of numbers, arranged in rows and columns.</p>
<p>The following represents a matrix that has 2 rows and 3 columns:</p>
<pre><code class=language-odin data-lang=odin>m: matrix[2, 3]f32

m = matrix[2, 3]f32{
	1, 9, -13,
	20, 5, -6,
}
</code></pre><p>Element types of integers, float, and complex numbers are supported by matrices. There is no support for booleans, quaternions, or any compound type.</p>
<p>Indexing a matrix can be used with the matrix indexing syntax This mirrors othe type usages: type on the left, usage on the right.</p>
<pre><code class=language-odin data-lang=odin>elem := m[1, 2] // row 1, column 2
</code></pre><p>Scalars act as if they are scaled identity matrices and can be assigned to matrices as them</p>
<pre><code class=language-odin data-lang=odin>b := matrix[2, 2]f32{}
f := f32(3)
b = f

fmt.println(&quot;b&quot;, b)
fmt.println(&quot;b == f&quot;, b == f)
</code></pre><p>Matrices support multiplication between matrices:</p>
<pre><code class=language-odin data-lang=odin>a := matrix[2, 3]f32{
	2, 3, 1,
	4, 5, 0,
}

b := matrix[3, 2]f32{
	1, 2,
	3, 4,
	5, 6,
}

fmt.println(&quot;a&quot;, a)
fmt.println(&quot;b&quot;, b)

c := a * b
#assert(type_of(c) == matrix[2, 2]f32)
fmt.tprintln(&quot;c = a * b&quot;, c)		
</code></pre><p>Matrices support multiplication between matrices and arrays:</p>
<pre><code class=language-odin data-lang=odin>m := matrix[4, 4]f32{
	1, 2, 3, 4, 
	5, 5, 4, 2, 
	0, 1, 3, 0, 
	0, 1, 4, 1,
}

v := [4]f32{1, 5, 4, 3}

// treating 'v' as a column vector
fmt.println(&quot;m * v&quot;, m * v)

// treating 'v' as a row vector
fmt.println(&quot;v * m&quot;, v * m)

// Support with non-square matrices
s := matrix[2, 4]f32{ // [4][2]f32
	2, 4, 3, 1, 
	7, 8, 6, 5, 
}

w := [2]f32{1, 2}
r: [4]f32 = w * s
fmt.println(&quot;r&quot;, r)
</code></pre><p>Component-wise operations:</p>
<pre><code class=language-odin data-lang=odin>// if the element type supports it
// Not support for '/', '%', or '%%' operations

a := matrix[2, 2]i32{
	1, 2,
	3, 4,
}

b := matrix[2, 2]i32{
	-5,  1,
	 9, -7,
}

c0 := a + b
c1 := a - b
c2 := a &amp; b
c3 := a | b
c4 := a ~ b
c5 := a &amp;~ b

// component-wise multiplication
// since a * b would be a standard matrix multiplication
c6 := hadamard_product(a, b) 

fmt.println(&quot;a + b&quot;,  c0)
fmt.println(&quot;a - b&quot;,  c1)
fmt.println(&quot;a &amp; b&quot;,  c2)
fmt.println(&quot;a | b&quot;,  c3)
fmt.println(&quot;a ~ b&quot;,  c4)
fmt.println(&quot;a &amp;~ b&quot;, c5)
fmt.println(&quot;hadamard_product(a, b)&quot;, c6)
</code></pre><h4 id=submatrix-casting>Submatrix Casting <a class=text-decoration-none href=#submatrix-casting>#</a></h4>
<h5 id=submatrix-casting-square-matrices>Submatrix casting square matrices <a class=text-decoration-none href=#submatrix-casting-square-matrices>#</a></h5>
<p>Casting a square matrix to another square matrix with same element type is supported.</p>
<ul>
<li>If the cast is to a smaller matrix type, the top-left submatrix is taken.</li>
<li>If the cast is to a larger matrix type, the matrix is extended with zeros everywhere and ones in the diagonal for the unfilled elements of the extended matrix.</li>
</ul>
<pre><code class=language-odin data-lang=odin>mat2 :: distinct matrix[2, 2]f32
mat4 :: distinct matrix[4, 4]f32

m2 := mat2{
	1, 3,
	2, 4,
}

m4 := mat4(m2)
assert(m4[2, 2] == 1)
assert(m4[3, 3] == 1)
fmt.printf(&quot;m2 %#v\n&quot;, m2)
fmt.println(&quot;m4&quot;, m4)
fmt.println(&quot;mat2(m4)&quot;, mat2(m4))
assert(mat2(m4) == m2)

b4 := mat4{
	1, 2, 0, 0,
	3, 4, 0, 0,
	5, 0, 6, 0,
	0, 7, 0, 8,
}
fmt.println(&quot;b4&quot;, matrix_flatten(b4))
</code></pre><h5 id=casting-non-square-matrices>Casting non-square matrices <a class=text-decoration-none href=#casting-non-square-matrices>#</a></h5>
<p>Casting a matrix to another matrix is allowed as long as they share the same element type and the number of elements (rows*columns). Matrices in Odin are stored in column-major order, which means the casts will preserve this element order.</p>
<pre><code class=language-odin data-lang=odin>mat2x4 :: distinct matrix[2, 4]f32
mat4x2 :: distinct matrix[4, 2]f32

x := mat2x4{
	1, 3, 5, 7, 
	2, 4, 6, 8,
}

y := mat4x2(x)
fmt.println(&quot;x&quot;, x)
fmt.println(&quot;y&quot;, y)
</code></pre><h4 id=technial-information-of-matrix-types>Technial Information of <code>matrix</code> Types <a class=text-decoration-none href=#technial-information-of-matrix-types>#</a></h4>
<p>The internal representation of a matrix in Odin is stored in column-major format
e.g. <code>matrix[2, 3]f32</code> is internally <code>[3][2]f32</code> (with different a alignment requirement).</p>
<p>Column-major is used in order to utilize (SIMD) vector instructions effectively on modern hardware, if possible.</p>
<p>Unlike normal arrays, matrices try to maximize alignment to allow for the (SIMD) vectorization properties whilst keeping zero padding (either between columns or at the end of the type).</p>
<p>Zero padding is a compromise for use with third-party libraries, instead of optimizing for performance. Padding between columns was not taken even if that would have allowed each column to be loaded individually into a SIMD register with the correct alignment properties.</p>
<p>Currently, matrices are limited to a maximum of 16 elements (rows*columns), and a minimum of 1 element. This is because matrices are stored as values (not a reference type), and thus operations on them will be stored on the stack. Restricting the maximum element count minimizing the possibility of stack overflows.</p>
<p>Built-in Procedures (Compiler Level):</p>
<ul>
<li><code>transpose(m)</code>
transposes a matrix</li>
<li><code>outer_product(a, b)</code>
takes two array-like data types and returns the outer product
of the values in a matrix</li>
<li><code>hadamard_product(a, b)</code>
component-wise multiplication of two matrices of the same type</li>
<li><code>matrix_flatten(m)</code>
<ul>
<li>converts the matrix into a flatten array of elements in column-major order.</li>
</ul>
</li>
<li><code>conj(x)</code>
<ul>
<li>conjugates the elements of a matrix for complex element types only</li>
</ul>
</li>
</ul>
<p>Built-in Procedures (Runtime Level) (all square matrix procedures):</p>
<ul>
<li><code>determinant(m)</code></li>
<li><code>adjugate(m)</code></li>
<li><code>inverse(m)</code></li>
<li><code>inverse_transpose(m)</code></li>
<li><code>hermitian_adjoint(m)</code></li>
<li><code>matrix_trace(m)</code></li>
<li><code>matrix_minor(m)</code></li>
</ul>
<h2 id=using-statement><code>using</code> statement <a class=text-decoration-none href=#using-statement>#</a></h2>
<p><code>using</code> can be used to bring entities declared in a scope/namespace into the current scope. This can be applied to import names, struct fields, procedure fields, and struct values.</p>
<pre><code class=language-odin data-lang=odin>import &quot;foo&quot;
bar :: proc() {
	// imports all the exported entities from the `foo` package into this scope
	using foo
}
</code></pre><h3 id=using-statement-with-structs>Using statement with structs <a class=text-decoration-none href=#using-statement-with-structs>#</a></h3>
<p>Let&rsquo;s take a very simple entity struct:</p>
<pre><code class=language-odin data-lang=odin>Vector3 :: struct{x, y, z: f32}
Entity :: struct {
	position: Vector3,
	orientation: quaternion128,
}
</code></pre><p>It can used like this:</p>
<pre><code class=language-odin data-lang=odin>foo :: proc(entity: ^Entity) {
	fmt.println(entity.position.x, entity.position.y, entity.position.z)
}
</code></pre><p>The entity members can be brought into the procedure scope by <code>using</code> it:</p>
<pre><code class=language-odin data-lang=odin>foo :: proc(entity: ^Entity) {
	using entity
	fmt.println(position.x, position.y, position.z)
}
</code></pre><p>The <code>using</code> can be applied to the parameter directly:</p>
<pre><code class=language-odin data-lang=odin>foo :: proc(using entity: ^Entity) {
	fmt.println(position.x, position.y, position.z)
}
</code></pre><p>It can also be applied to sub-fields:</p>
<pre><code class=language-odin data-lang=odin>foo :: proc(entity: ^Entity) {
	using entity.position
	fmt.println(x, y, z)
}
</code></pre><p>We can also apply the <code>using</code> statement to the struct fields directly, making all the fields of <code>position</code> appear as if they on <code>Entity</code> itself:</p>
<pre><code class=language-odin data-lang=odin>Entity :: struct {
	using position: Vector3,
	orientation: quaternion128,
}
foo :: proc(entity: ^Entity) {
	fmt.println(entity.x, entity.y, entity.z)
}
</code></pre><h3 id=subtype-polymorphism>Subtype polymorphism <a class=text-decoration-none href=#subtype-polymorphism>#</a></h3>
<p>It is possible to get subtype polymorphism, similar to inheritance-like functionality in C++, but without the requirement of vtables or unknown struct layout:</p>
<pre><code class=language-odin data-lang=odin>foo :: proc(entity: Entity) {
	fmt.println(entity.x, entity.y, entity.z)
}

Frog :: struct {
	ribbit_volume: f32,
	using entity: Entity,
}

frog: Frog
// Both work
frog.x = 123
foo(frog)
</code></pre><p><strong>Note:</strong> <code>using</code> can be applied to arbitrarily many things, which allows the ability to have multiple subtype polymorphism (but also its issues).</p>
<p><strong>Note:</strong> <code>using</code>&rsquo;d fields can still be referred by name.</p>
<h2 id=or_else-expression><code>or_else</code> expression <a class=text-decoration-none href=#or_else-expression>#</a></h2>
<p><code>or_else</code> is an infix binary operator that allows the user to define default values for certain expressions with optional-ok semantics.</p>
<pre><code class=language-odin data-lang=odin>m: map[string]int
i: int
ok: bool

if i, ok = m[&quot;hellope&quot;]; !ok {
	i = 123
}
// The above can be mapped to 'or_else'
i = m[&quot;hellope&quot;] or_else 123

assert(i == 123)
</code></pre><p><code>or_else</code> can be used with type assertions too, as they have optional-ok semantics.</p>
<pre><code class=language-odin data-lang=odin>v: union{int, f64}
i: int
i = v.(int) or_else 123
i = v.? or_else 123 // Type inference magic
assert(i == 123)

m: Maybe(int)
i = m.? or_else 456
assert(i == 456)
</code></pre><h2 id=or_return-statement><code>or_return</code> statement <a class=text-decoration-none href=#or_return-statement>#</a></h2>
<p>The concept of <code>or_return</code> will work by popping off the end value in a multiple valued expression and checking whether it was not <code>nil</code> or <code>false</code>, and if so, set the end return value to value if possible. If the procedure only has one return value, it will do a simple return. If the procedure had multiple return values, <code>or_return</code> will require that all parameters be named so that the end value could be assigned to by name and then an empty return could be called.</p>
<pre><code class=language-odin data-lang=odin>Error :: enum {
	None,
	Something_Bad,
	Something_Worse,
	The_Worst,
	Your_Mum,
};

caller_1 :: proc() -&gt; Error {
	return .None
}

caller_2 :: proc() -&gt; (int, Error) {
	return 123, .None
}
caller_3 :: proc() -&gt; (int, int, Error) {
	return 123, 345, .None
}

foo_1 :: proc() -&gt; Error {
	// This can be a common idiom in many code bases
	n0, err := caller_2()
	if err != nil {
		return err
	}

	// The above idiom can be transformed into the following
	n1 := caller_2() or_return


	// And if the expression is 1-valued, it can be used like this
	caller_1() or_return
	// which is functionally equivalent to
	if err1 := caller_1(); err1 != nil {
		return err1
	}

	// Multiple return values still work with 'or_return' as it only
	// pops off the end value in the multi-valued expression
	n0, n1 = caller_3() or_return

	return .None
}
foo_2 :: proc() -&gt; (n: int, err: Error) {
	// It is more common that your procedure turns multiple values
	// If 'or_return' is used within a procedure multiple parameters (2+),
	// then all the parameters must be named so that the remaining parameters
	// so that a bare 'return' statement can be used

	// This can be a common idiom in many code bases
	x: int
	x, err = caller_2()
	if err != nil {
		return
	}

	// The above idiom can be transformed into the following
	y := caller_2() or_return
	_ = y

	// And if the expression is 1-valued, it can be used like this
	caller_1() or_return

	// which is functionally equivalent to
	if err1 := caller_1(); err1 != nil {
		err = err1
		return
	}

	// If using a non-bare 'return' statement is required, setting the return values
	// using the normal idiom is a better choice and clearer to read.
	if z, zerr := caller_2(); zerr != nil {
		return -345 * z, zerr
	}

	// If the other return values need to be set depending on what the end value is,
	// the 'defer if' idiom is can be used
	defer if err != nil {
		n = -1
	}

	n = 123
	return
}
</code></pre><h2 id=implicit-context-system>Implicit context system <a class=text-decoration-none href=#implicit-context-system>#</a></h2>
<p>In each scope, there is an implicit value named <code>context</code>. This <code>context</code> variable is local to each scope and is implicitly passed by pointer to any procedure call in that scope (if the procedure has the Odin calling convention).</p>
<p>The main purpose of the implicit <code>context</code> system is for the ability to intercept third-party code and libraries and modify their functionality. One such case is modifying how a library allocates something or logs something. In C, this was usually achieved with the library defining macros which could be overridden so that the user could define what he wanted. However, not many libraries supported this in many languages by default which meant intercepting third-party code to see what it does and to change how it does it was not possible.</p>
<pre><code class=language-odin data-lang=odin>main :: proc() {
	c := context // copy the current scope's context

	context.user_index = 456
	{
		context.allocator = my_custom_allocator()
		context.user_index = 123
		supertramp() // the `context` for this scope is implicitly passed to `supertramp`
	}

	// `context` value is local to the scope it is in
	assert(context.user_index == 456)
}

supertramp :: proc() {
	c := context // this `context` is the same as the parent procedure that it was called from
	// From this example, context.user_index == 123
	// A context.allocator is assigned to the return value of `my_custom_allocator()`

	// The memory management procedure use the `context.allocator` by default unless explicitly specified otherwise
	ptr := new(int)
	free(ptr)
}
</code></pre><p>By default, the <code>context</code> value has default values for its parameters which is decided in the package runtime. These defaults are compiler specific.</p>
<p>To see what the implicit <code>context</code> value contains, please see the definition of the <code>Context</code> struct in <a href=https://github.com/odin-lang/Odin/blob/master/core/runtime/core.odin>package runtime</a>.</p>
<h3 id=allocators>Allocators <a class=text-decoration-none href=#allocators>#</a></h3>
<p>Odin is a manual memory management based language. This means that Odin programmers must manage their own memory, allocations, and tracking. To aid with memory management, Odin has huge support for custom allocators, especially through the implicit <code>context</code> system.</p>
<p>The built-in types of dynamic arrays and <code>map</code> both contain a custom allocator. This allocator can be either manually set or the allocator from the current <code>context</code> will be assigned to the data type.</p>
<p>All allocations in Odin are preferably done through allocators. The core library of Odin takes advantage of allocators through the implicit <code>context</code> system. The following call:</p>
<pre><code class=language-odin data-lang=odin>ptr := new(int)
</code></pre><p>is equivalent to this:</p>
<pre><code>ptr := new(int, context.allocator)
</code></pre><p>The allocator from the <code>context</code> is implicitly assigned as a default parameter to the built-in procedure <code>new</code>.</p>
<p>The implicit <code>context</code> stores two different forms of allocators: <code>context.allocator</code> and <code>context.temp_allocator</code>. Both can be reassigned to any kind of allocator. However, these allocators are to be treated slightly differently.</p>
<ul>
<li><code>context.allocator</code> is for &ldquo;general&rdquo; allocations, for the subsystem it is used within.</li>
<li><code>context.temp_allocator</code> is for temporary and short lived allocations, which are to be freed once per cycle/frame/etc.</li>
</ul>
<p>By default, the <code>context.allocator</code> is a OS heap allocator and the <code>context.temp_allocator</code> is assigned to a scratch allocator (a ring-buffer based allocator).</p>
<p>The following procedures are built-in (and also available in <code>package mem</code>) and are encouraged for managing memory:</p>
<ul>
<li><code>alloc</code> - allocates memory of a given size (and alignment) in bytes. The result value is a rawptr.</li>
</ul>
<pre><code class=language-odin data-lang=odin>ptr: rawptr = alloc(64) // allocate 64 bytes aligned to the default alignment
x := alloc(128, 16) // allocate 128 bytes aligned to 16 bytes

i := cast(^int)alloc(size_of(int), align_of(int)) // the equivalent of the `new` procedure explained next
</code></pre><ul>
<li><code>new</code> - allocates a value of the type given. The result value is a pointer to the type given.</li>
</ul>
<pre><code class=language-odin data-lang=odin>ptr := new(int)
ptr^ = 123
x: int = ptr^
</code></pre><ul>
<li><code>new_clone</code> - allocates a clone of the value passed to it. The resulting value of the type will be a pointer to the type of the value passed.</li>
</ul>
<pre><code class=language-odin data-lang=odin>x: int = 123
ptr: int
ptr = new_clone(x)
assert(ptr^ == 123)
</code></pre><ul>
<li><code>make</code> - allocates memory for a backing data structure of either a <a href=#slices>slice</a>, <a href=#dynamic-arrays>dynamic array</a>, or <a href=#maps>map</a>.</li>
</ul>
<pre><code class=language-odin data-lang=odin>slice := make([]int, 65)

dynamic_array_zero_length := make([dynamic]int)
dynamic_array_with_length := make([dynamic]int, 32)
dynamic_array_with_length_and_capacity := make([dynamic]int, 16, 64)

made_map := make(map[string]int)
made_map_with_reservation := make(map[string]int, 64)
</code></pre><ul>
<li><code>free</code> - frees the memory at the pointer given. <strong>Note:</strong> only free memory with the allocator it was allocated with.</li>
</ul>
<pre><code class=language-odin data-lang=odin>ptr := new(int)
free(ptr)
</code></pre><ul>
<li><code>free_all</code> - frees all the memory of the context&rsquo;s allocator (or given allocator). <strong>Note:</strong> not all allocators support this procedure.</li>
</ul>
<pre><code class=language-odin data-lang=odin>free_all()
free_all(context.temp_allocator)
free_all(my_allocator)
</code></pre><ul>
<li><code>delete</code> - deletes the backing memory of a value allocated with make or a string that was allocated through an allocator.</li>
</ul>
<pre><code class=language-odin data-lang=odin>delete(my_slice)
delete(my_dynamic_array)
delete(my_map)
delete(my_string)
delete(my_cstring)
</code></pre><ul>
<li><code>realloc</code> - reallocates a block of memory with a different size. <strong>Note:</strong> only realloc memory with the same allocator the original pointer was allocated with; not all allocators may support <code>realloc</code> in-place.</li>
</ul>
<pre><code class=language-odin data-lang=odin>ptr := alloc(16)
ptr = realloc(ptr, 32)
</code></pre><p>To see more uses of allocators, please see <a href=https://github.com/odin-lang/Odin/tree/master/core/mem><code>package mem</code></a> in the core library.</p>
<p>For more information regarding memory allocation strategies in general, please see <a href=https://www.gingerbill.org/series/memory-allocation-strategies/>Ginger Bill&rsquo;s Memory Allocation Strategy</a> series.</p>
<h4 id=explicit-context-definition>Explicit <code>context</code> Definition <a class=text-decoration-none href=#explicit-context-definition>#</a></h4>
<p>Procedures which do not use the <code>"odin"</code> calling convention must explicitly assign the <code>context</code> if something within its body requires it.</p>
<pre><code class=language-odin data-lang=odin>explicit_context_definition :: proc &quot;c&quot; () {
	// Try commenting the following statement out below
	context = runtime.default_context()

	fmt.println(&quot;\n#explicit context definition&quot;)
	dummy_procedure()
}

dummy_procedure :: proc() {
	fmt.println(&quot;dummy_procedure&quot;)
}
</code></pre><h3 id=logging-system>Logging System <a class=text-decoration-none href=#logging-system>#</a></h3>
<p>As part of the implicit <code>context</code> system, there is a built-in logging system.</p>
<p>To see more uses of loggers, please see <a href=https://github.com/odin-lang/Odin/tree/master/core/log><code>package log</code></a> in the core library.</p>
<h2 id=foreign-system>Foreign system <a class=text-decoration-none href=#foreign-system>#</a></h2>
<p>It is sometimes necessary to interface with foreign code, such as a C library. In Odin, this is achieved through the <code>foreign</code> system. You can &ldquo;import&rdquo; a library into the code using the same semantics as a normal import declaration:</p>
<pre><code class=language-odin data-lang=odin>foreign import kernel32 &quot;system:kernel32.lib&quot;
</code></pre><p>This <code>foreign import</code> declaration will create a &ldquo;foreign import name&rdquo; which can then be used to associate entities within a foreign block.</p>
<pre><code class=language-odin data-lang=odin>foreign import kernel32 &quot;system:kernel32.lib&quot;
foreign kernel32 {
	ExitProcess :: proc &quot;stdcall&quot; (exit_code:  u32) ---
}
</code></pre><p>Foreign procedure declarations have the <strong>cdecl</strong>/<strong>c</strong> calling convention by default unless specified otherwise. Due to foreign procedures not having a body declared within this code, you need to append the <code>---</code> symbol to the end to distinguish it as a procedure literal without a body and not a procedure type.</p>
<p>The attributes system can be used to change specific properties of entities declared within a block:</p>
<pre><code class=language-odin data-lang=odin>@(default_calling_convention = &quot;std&quot;)
foreign kernel32 {
	@(link_name=&quot;GetLastError&quot;) get_last_error :: proc() -&gt; i32 ---
}
</code></pre><p>Available attributes for foreign blocks:</p>
<pre><code class=language-odin data-lang=odin>default_calling_convention=&lt;string&gt;
	default calling convention for procedures declared within this foreign block
link_prefix=&lt;string&gt;
	prefix that needs to be appended to the linkage names of the entities except where the link name has been explicitly overridden
</code></pre><h2 id=parametric-polymorphism>Parametric polymorphism <a class=text-decoration-none href=#parametric-polymorphism>#</a></h2>
<p>Parametric polymorphism, commonly referred to as &ldquo;generics&rdquo;, allow the user to create a procedure or data that can be written <em>generically</em> so it can handle values in the same manner.</p>
<p>Note: Within the Odin code base and documentation, the nickname &ldquo;parapoly&rdquo; is usually used.</p>
<h3 id=explicit-parametric-polymorphism>Explicit parametric polymorphism <a class=text-decoration-none href=#explicit-parametric-polymorphism>#</a></h3>
<p>Explicit parametric polymorphism means that the types of the parameters must be explicitly provided.</p>
<h4 id=procedures-1>Procedures <a class=text-decoration-none href=#procedures-1>#</a></h4>
<p>To specify that a parameter is &ldquo;constant&rdquo;, the parameters name must be prefixed with a dollar sign <code>$</code>. The following example takes two constant parameters to initialize an array of known length:</p>
<pre><code class=language-odin data-lang=odin>make_f32_array :: #force_inline proc($N: int, $val: f32) -&gt; (res: [N]f32) {
	for _, i in res {
		res[i] = val*val
	}
	return
}

array := make_f32_array(3, 2)
</code></pre><p>Types can also be explicitly passed with specifying that the <code>typeid</code> parameter is constant:</p>
<pre><code class=language-odin data-lang=odin>my_new :: proc($T: typeid) -&gt; ^T {
	return (^T)(alloc(size_of(T), align_of(T)))
}

ptr := my_new(int)
</code></pre><h4 id=data-types>Data types <a class=text-decoration-none href=#data-types>#</a></h4>
<p>Structures and unions may have polymorphic parameters. The <code>$</code> prefix is optional for record data types as all parameters must be &ldquo;constant&rdquo;.
Parapoly struct:</p>
<pre><code class=language-odin data-lang=odin>Table_Slot :: struct($Key, $Value: typeid) {
	occupied: bool,
	hash:    u32,
	key:     Key,
	value:   Value,
}
slot: Table_Slot(string, int)
</code></pre><p>Parapoly union:</p>
<pre><code class=language-odin data-lang=odin>Error :: enum {Foo0, Foo1, Foo2}
Param_Union :: union($T: typeid) #no_nil {T, Error}
r: Param_Union(int)
r = 123
r = Error.Foo0
</code></pre><h3 id=implicit-parametric-polymorphism>Implicit parametric polymorphism <a class=text-decoration-none href=#implicit-parametric-polymorphism>#</a></h3>
<p>Implicit implies that the type of a parameter is inferred from its input. In this case, the dollar sign <code>$</code> can be placed on the type.</p>
<p>Note: Within the Odin code base and documentation, the name &ldquo;polymorphic name&rdquo; is usually used.</p>
<h4 id=procedures-2>Procedures <a class=text-decoration-none href=#procedures-2>#</a></h4>
<pre><code class=language-odin data-lang=odin>foo :: proc($N: $I, $T: typeid) -&gt; (res: [N]T) {
	// `N` is the constant value passed
	// `I` is the type of N
	// `T` is the type passed
	fmt.printf(&quot;Generating an array of type %v from the value %v of type %v\n&quot;,
			   typeid_of(type_of(res)), N, typeid_of(I))
	for i in 0..&lt;N {
		res[i] = i*i
	}
	return
}

T :: int
array := foo(4, T)
for v, i in array {
	assert(v == T(i*i))
}
</code></pre><h4 id=specialization>Specialization <a class=text-decoration-none href=#specialization>#</a></h4>
<p>In some cases, you may want to specify that a type must be a specialization of a certain type.</p>
<pre><code class=language-odin data-lang=odin>// Only allow types that are specializations of a (polymorphic) slice
make_slice :: proc($T: typeid/[]$E, len: int) -&gt; T {
	return make(T, len)
}
</code></pre><pre><code class=language-odin data-lang=odin>Table_Slot :: struct($Key, $Value: typeid) {
	occupied: bool,
	hash:     u32,
	key:      Key,
	value:    Value,
}
Table :: struct($Key, $Value: typeid) {
	count:     int,
	allocator: mem.Allocator,
	slots:     []Table_Slot(Key, Value),
}

// Only allow types that are specializations of `Table`
allocate :: proc(table: ^$T/Table, capacity: int) {
	...
}

// find :: proc(table: ^$T/Table, key: T.Key) -&gt; (T.Value, bool) {
find :: proc(table: ^Table($Key, $Value), key: Key) -&gt; (Value, bool) {
	...
}
</code></pre><h3 id=where-clauses><code>where</code> clauses <a class=text-decoration-none href=#where-clauses>#</a></h3>
<p>A bound on polymorphic parameters to a procedure or record can be expressed using a <code>where</code> clause immediately before opening <code>{</code>, rather than at the type&rsquo;s or constant&rsquo;s first mention. Additionally, <code>where</code> clauses can apply bounds to arbitrary types, rather than just polymorphic type parameters.</p>
<p>Some cases that a <code>where</code> clause may be useful:</p>
<ul>
<li>Sanity checks for parameters:</li>
</ul>
<pre><code class=language-odin data-lang=odin>simple_sanity_check :: proc(x: [2]int)
	where len(x) &gt; 1,
		  type_of(x) == [2]int {
	fmt.println(x)
}
</code></pre><ul>
<li>Parameter polymorphism checks for procedures:</li>
</ul>
<pre><code class=language-odin data-lang=odin>cross_2d :: proc(a, b: $T/[2]$E) -&gt; E
	where intrinsics.type_is_numeric(E) {
	return a.x*b.y - a.y*b.x
}
cross_3d :: proc(a, b: $T/[3]$E) -&gt; T
	where intrinsics.type_is_numeric(E) {
	x := a.y*b.z - a.z*b.y
	y := a.z*b.x - a.x*b.z
	z := a.x*b.y - a.y*b.z
	return T{x, y, z}
}

a := [2]int{1, 2}
b := [2]int{5, -3}
fmt.println(cross_2d(a, b))

x := [3]f32{1, 4, 9}
y := [3]f32{-5, 0, 3}
fmt.println(cross_3d(x, y))

// Failure case
// i := [2]bool{true, false}
// j := [2]bool{false, true}
// fmt.println(cross_2d(i, j))
</code></pre><ul>
<li>Solving disambiguations with polymorphic procedures in a procedure grouping:</li>
</ul>
<pre><code class=language-odin data-lang=odin>foo :: proc(x: [$N]int) -&gt; bool
	where N &gt; 2 {
	fmt.println(#procedure, &quot;was called with the parameter&quot;, x)
	return true
}

bar :: proc(x: [$N]int) -&gt; bool
	where 0 &lt; N,
		  N &lt;= 2 {
	fmt.println(#procedure, &quot;was called with the parameter&quot;, x)
	return false
}

baz :: proc{foo, bar}

x := [3]int{1, 2, 3}
y := [2]int{4, 9}
ok_x := baz(x)
ok_y := baz(y)
assert(ok_x == true)
assert(ok_y == false)
</code></pre><ul>
<li>Restrictions on parametric polymorphic parameters for record types:</li>
</ul>
<pre><code class=language-odin data-lang=odin>Foo :: struct($T: typeid, $N: int)
	where intrinsics.type_is_integer(T),
	      N &gt; 2 {
	x: [N]T,
	y: [N-2]T,
}

T :: i32
N :: 5
f: Foo(T, N)
#assert(size_of(f) == (N+N-2)*size_of(T))
</code></pre><h2 id=useful-idioms>Useful idioms <a class=text-decoration-none href=#useful-idioms>#</a></h2>
<p>The following are useful idioms which are emergent from the semantics on the language.</p>
<h3 id=basic-idioms>Basic idioms <a class=text-decoration-none href=#basic-idioms>#</a></h3>
<h4 id=if-statements-with-initialization>If-statements with initialization <a class=text-decoration-none href=#if-statements-with-initialization>#</a></h4>
<pre><code class=language-odin data-lang=odin>if str, ok := value.(string) ok {
	...
} else {
   ...
}
</code></pre><h4 id=iterating-through-slices-of-structs-by-value-or-by-reference>Iterating through slices of structs by value or by reference <a class=text-decoration-none href=#iterating-through-slices-of-structs-by-value-or-by-reference>#</a></h4>
<pre><code class=language-odin data-lang=odin>Foo :: struct {
	f: float,
	i: int,
}

foos := make([]Foo, num)

// By-value basic ranged-based loop, with implicit indexing
for v, j in foos {
	using v
	fmt.println(i, v, f, i)
}

// Alternative range-based loop, with explicit indexing
for _, j in foos {
	using foo := foos[j] // copy
	fmt.println(j, foo, f, i)
}

// By-reference range-based explicit indexing loop
for _, j in foos {
	using foo := &amp;foos[j] // &quot;reference&quot;, changes to `f` or `i` are visible outside this scope
	fmt.println(j, foo, f, i)
}


// By-reference range-based through pointer
for v, j in &amp;foos {
	using v // v is now a variable reference as `foos` was passed by pointer
	fmt.println(j, foo, f, i)
}
</code></pre><h4 id=defer-if>&lsquo;defer if&rsquo; <a class=text-decoration-none href=#defer-if>#</a></h4>
<pre><code class=language-odin data-lang=odin>defer if cond {
}
</code></pre><h3 id=advanced-idioms>Advanced idioms <a class=text-decoration-none href=#advanced-idioms>#</a></h3>
<p>Subtype polymorphism with runtime type safe down casting:</p>
<pre><code class=language-odin data-lang=odin>Entity :: struct {
	id:   u64,
	name: string,

	variant: union{^Frog},
}

Frog :: struct {
	using entity: Entity,
	volume: f32,
	jump_height: i32,
}


new_entity :: proc($T: typeid) -&gt; ^T {
	e := new(T)
	e.variant = e
	return e
}

entity: ^Entity = new_entity(Frog)
switch e in entity.variant {
case ^Frog:
	fmt.println(&quot;Ribbit:&quot;, e.volume)
}
</code></pre><h2 id=extra-information>Extra information <a class=text-decoration-none href=#extra-information>#</a></h2>
<p>More details can be found on the <a href=https://github.com/odin-lang/Odin/wiki>Github wiki for Odin</a>.
Some of this information includes:</p>
<ul>
<li><a href=https://github.com/odin-lang/Odin/wiki/Compiler-Flags>Compiler Flags</a></li>
<li><a href=https://github.com/odin-lang/Odin/wiki/Attributes-and-Directives>Attributes-and-Directives</a></li>
<li><a href=https://github.com/odin-lang/Odin/wiki/Built-in-Procedures>Built in Procedures</a></li>
<li><a href=https://github.com/odin-lang/Odin/wiki/Keywords-and-Operators>Keywords and Operators</a></li>
<li>&mldr;and more</li>
</ul>
</div>
</article>
<div class="col-lg-2 odin-toc-border navbar-light">
<div class="sticky-top odin-below-navbar py-3">
<nav id=TableOfContents>
<ul>
<li><a href=#introduction>Introduction</a></li>
<li><a href=#hellope>Hellope!</a></li>
<li><a href=#lexical-elements-and-literals>Lexical elements and literals</a>
<ul>
<li><a href=#comments>Comments</a></li>
<li><a href=#string-and-character-literals>String and character literals</a></li>
<li><a href=#numbers>Numbers</a></li>
</ul>
</li>
<li><a href=#variable-declarations>Variable declarations</a></li>
<li><a href=#assignment-statements>Assignment statements</a></li>
<li><a href=#constant-declarations>Constant declarations</a></li>
<li><a href=#packages>Packages</a>
<ul>
<li><a href=#import-statement><code>import</code> statement</a></li>
<li><a href=#exported-names>Exported names</a></li>
</ul>
</li>
<li><a href=#control-flow-statements>Control flow statements</a>
<ul>
<li><a href=#for-statement><code>for</code> statement</a></li>
<li><a href=#if-statement><code>if</code> statement</a></li>
<li><a href=#switch-statement><code>switch</code> statement</a></li>
<li><a href=#defer-statement><code>defer</code> statement</a></li>
<li><a href=#when-statement><code>when</code> statement</a></li>
<li><a href=#branch-statements>Branch statements</a></li>
</ul>
</li>
<li><a href=#procedures>Procedures</a>
<ul>
<li><a href=#parameters>Parameters</a></li>
<li><a href=#multiple-results>Multiple results</a></li>
<li><a href=#named-results>Named results</a></li>
<li><a href=#named-arguments>Named arguments</a></li>
<li><a href=#default-values>Default values</a></li>
<li><a href=#explicit-procedure-overloading>Explicit procedure overloading</a></li>
</ul>
</li>
<li><a href=#basic-types>Basic types</a>
<ul>
<li><a href=#zero-values>Zero values</a></li>
<li><a href=#type-conversion>Type conversion</a></li>
<li><a href=#untyped-types>Untyped types</a></li>
<li><a href=#auto-cast-operation>Auto cast operation</a></li>
<li><a href=#built-in-constants-and-values>Built-in constants and values</a></li>
<li><a href=#cstring-type><code>cstring</code> type</a></li>
</ul>
</li>
<li><a href=#advanced-types>Advanced types</a>
<ul>
<li><a href=#type-alias>Type alias</a></li>
<li><a href=#distinct-types>Distinct types</a></li>
<li><a href=#fixed-arrays>Fixed arrays</a></li>
<li><a href=#slices>Slices</a></li>
<li><a href=#dynamic-arrays>Dynamic arrays</a></li>
<li><a href=#enumerations>Enumerations</a></li>
<li><a href=#bit-sets>Bit sets</a></li>
<li><a href=#pointers>Pointers</a></li>
<li><a href=#structs>Structs</a></li>
<li><a href=#unions>Unions</a></li>
<li><a href=#maps>Maps</a></li>
<li><a href=#procedure-type>Procedure type</a></li>
<li><a href=#typeid-type>&lsquo;typeid&rsquo; type</a></li>
<li><a href=#any-type>&lsquo;any&rsquo; Type</a></li>
<li><a href=#multi-pointers>Multi Pointers</a></li>
<li><a href=#soa-data-types>SOA Data Types</a></li>
<li><a href=#matrix-type><code>matrix</code> type</a></li>
</ul>
</li>
<li><a href=#using-statement><code>using</code> statement</a>
<ul>
<li><a href=#using-statement-with-structs>Using statement with structs</a></li>
<li><a href=#subtype-polymorphism>Subtype polymorphism</a></li>
</ul>
</li>
<li><a href=#or_else-expression><code>or_else</code> expression</a></li>
<li><a href=#or_return-statement><code>or_return</code> statement</a></li>
<li><a href=#implicit-context-system>Implicit context system</a>
<ul>
<li><a href=#allocators>Allocators</a></li>
<li><a href=#logging-system>Logging System</a></li>
</ul>
</li>
<li><a href=#foreign-system>Foreign system</a></li>
<li><a href=#parametric-polymorphism>Parametric polymorphism</a>
<ul>
<li><a href=#explicit-parametric-polymorphism>Explicit parametric polymorphism</a></li>
<li><a href=#implicit-parametric-polymorphism>Implicit parametric polymorphism</a></li>
<li><a href=#where-clauses><code>where</code> clauses</a></li>
</ul>
</li>
<li><a href=#useful-idioms>Useful idioms</a>
<ul>
<li><a href=#basic-idioms>Basic idioms</a></li>
<li><a href=#advanced-idioms>Advanced idioms</a></li>
</ul>
</li>
<li><a href=#extra-information>Extra information</a></li>
</ul>
</nav>
</div>
</div>
</div>
</div>
</main>
<footer class=odin-footer>
<div class="container pb-5 pt-5">
<div class="row g-4">
<div class=col>
<a class=navbar-brand href=/>
<img class=mb-3 src=/logo.svg height=30 alt=Odin></a>
<p>
The Data-Oriented Language for Sane Software Development.
</p>
</div>
<nav class=col-md-auto>
<h4 class=fw-normal>Resources</h4>
<ul class=list-unstyled>
<li><a href=/docs class=link-light>Docs</a></li>
<li><a href=https://pkg.odin-lang.org/ class=link-light>Packages</a></li>
<li><a href=/news class=link-light>News</a></li>
</ul>
</nav>
<nav class=col-md-auto>
<h4 class=fw-normal>Community</h4>
<ul class=list-unstyled>
<li><a href=https://github.com/odin-lang/Odin target=_blank class=link-light>GitHub</a></li>
<li><a href=https://discord.com/invite/sVBPHEv target=_blank class=link-light>Discord</a></li>
<li><a href=https://www.twitch.tv/ginger_bill target=_blank class=link-light>Twitch</a></li>
<li><a href=https://www.youtube.com/channel/UCUSck1dOH7VKmG4lRW7tZXg target=_blank class=link-light>YouTube</a></li>
<li><a href=/showcase target=_blank class=link-light>Showcase</a></li>
</ul>
</nav>
<nav class=col-md-auto>
<h4 class=fw-normal>Contribute</h4>
<ul class=list-unstyled>
<li><a href=https://github.com/odin-lang/Odin/issues target=_blank class=link-light>Issues</a></li>
<li><a href=https://www.patreon.com/gingerbill target=_blank class=link-light>Donate</a></li>
</ul>
</nav>
</div>
<div class="mt-4 text-muted"> 20162022 Ginger Bill</div>
</div>
</footer>
<script src=/lib/bootstrap/js/bootstrap.min.js></script>
<script src=/js/script.js></script>
</body>
</html>
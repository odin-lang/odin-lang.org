<!doctype html><html><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon href=/favicon.svg><meta name=color-scheme content="only dark"><meta property="og:title" content="Demo File"><meta property="og:description" content="The original demonstration of the Odin in a single file, including numerous examples of concepts and features of the programming language."><meta property="og:type" content="article"><meta property="og:url" content="https://odin-lang.org/docs/demo/"><meta property="og:image" content="https://odin-lang.org/images/logo-slim.png"><link rel=stylesheet href=https://odin-lang.org/scss/custom.min.css><link rel=stylesheet href=/lib/highlight/styles/github-dark.min.css><script src=/lib/highlight/highlight.min.js></script><script src=/lib/highlight/languages/x86asm.min.js></script><script>hljs.registerLanguage("odin",function(e){return{aliases:["odin","odinlang","odin-lang"],keywords:{keyword:"auto_cast bit_field bit_set break case cast context continue defer distinct do dynamic else enum fallthrough for foreign if import in map matrix not_in or_else or_return package proc return struct switch transmute type_of typeid union using when where",literal:"true false nil",built_in:"abs align_of cap clamp complex conj expand_to_tuple imag jmag kmag len max min offset_of quaternion real size_of soa_unzip soa_zip swizzle type_info_of type_of typeid_of"},illegal:"</",contains:[e.C_LINE_COMMENT_MODE,e.C_BLOCK_COMMENT_MODE,{className:"string",variants:[e.QUOTE_STRING_MODE,{begin:"'",end:"[^\\\\]'"},{begin:"`",end:"`"}]},{className:"number",variants:[{begin:e.C_NUMBER_RE+"[ijk]",relevance:1},e.C_NUMBER_MODE]}]}})</script><script>hljs.highlightAll()</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-67516878-2"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-67516878-2")</script><link href=/css/style.css rel=stylesheet><title>Demo File | Odin Programming Language </title><link rel=alternate type=application/rss+xml href=https://odin-lang.org//categories/newsletter/index.xml title="Odin Newsletter"><body data-bs-spy=scroll data-bs-target=#TOC data-bs-offset=0 tabindex=0><script>window.localStorage.getItem("theme")||window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches&&(window.localStorage.setItem("theme","dark"),document.body.classList.add("dark-mode")),window.localStorage.getItem("theme")==="dark"&&document.body.classList.add("dark-mode");function toggleDarkMode(){document.body.classList.toggle("dark-mode")?window.localStorage.setItem("theme","dark"):window.localStorage.setItem("theme","light")}</script><header class=sticky-top><nav class="navbar navbar-expand-lg navbar-dark bg-primary odin-menu"><div class=container-xxl><a class=navbar-brand href=/><img src=/logo.svg height=30 alt=Odin id=navbar-logo>
</a><button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#odin-navbar-content aria-controls=odin-navbar-content aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=odin-navbar-content><ul class="navbar-nav ms-md-auto"><li class=nav-item><a class=nav-link href=/>Home</a></li><li class=nav-item><a class="nav-link active" href=/docs aria-current=page>Docs</a></li><li class=nav-item><a class=nav-link href=https://pkg.odin-lang.org/>Packages</a></li><li class=nav-item><a class=nav-link href=/news>News</a></li><li class=nav-item><a class=nav-link href=/showcase>Showcase</a></li><li class=nav-item><a class=nav-link href=https://forum.odin-lang.org>Forum</a></li><li class=nav-item><a class=nav-link href=/community>Community</a></li><li class=nav-item><a class=nav-link href=https://github.com/odin-lang/Odin target=_blank>GitHub</a></li><li class=nav-item><a class="nav-link btn-dark-mode" onclick=toggleDarkMode() title="Toggle Light/Dark Mode"><span class=dark-mode-appearance>Appearance:</span><svg fill="#fff" id="dark-mode-icon" viewBox="0 0 384 512"><path d="M223.5 32C1e2 32 0 132.3.0 256S1e2 480 223.5 480c60.6.0 115.5-24.2 155.8-63.4 5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6-96.9.0-175.5-78.8-175.5-176 0-65.8 36-123.1 89.3-153.3 6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"/></svg><svg fill="#fff" id="light-mode-icon" viewBox="0 0 16 16"><path d="M8 12a4 4 0 100-8 4 4 0 000 8M8 0a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 0m0 13a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 13m8-5a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2a.5.5.0 01.5.5M3 8a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2A.5.5.0 013 8m10.657-5.657a.5.5.0 010 .707l-1.414 1.415a.5.5.0 11-.707-.708l1.414-1.414a.5.5.0 01.707.0m-9.193 9.193a.5.5.0 010 .707L3.05 13.657a.5.5.0 01-.707-.707l1.414-1.414a.5.5.0 01.707.0m9.193 2.121a.5.5.0 01-.707.0l-1.414-1.414a.5.5.0 01.707-.707l1.414 1.414a.5.5.0 010 .707M4.464 4.465a.5.5.0 01-.707.0L2.343 3.05a.5.5.0 11.707-.707l1.414 1.414a.5.5.0 010 .708"/></svg></button></a></li></ul></div></div></nav></header><main><div class=container-xxl><div class="row odin-main"><nav class="col-lg-2 odin-sidebar-border navbar-light"><div class="sticky-top odin-below-navbar py-3"><ul class="nav nav-pills d-flex flex-column"><li class=nav-item><a class=nav-link href=/docs/install/>Getting Started</a></li><li class=nav-item><a class=nav-link href=/docs/overview/>Overview</a></li><li class=nav-item><a class=nav-link href=/docs/packages/>Packages</a></li><li class=nav-item><a class=nav-link href=/docs/examples/>Examples</a></li><li class=nav-item><a class="nav-link active" href=/docs/demo/ aria-current=page>Demo File</a></li><li class=nav-item><a class=nav-link href=/docs/odin-book/>Books [External]</a></li><li class=nav-item><a class=nav-link href=/docs/testing/>Running Tests</a></li><li class=nav-item><a class=nav-link href=/docs/nightly/>Nightly Builds</a></li><li class=nav-item><a class=nav-link href=/docs/faq/>FAQ</a></li></ul></div></nav><article class="col-lg-8 p-4"><header><nav aria-label=breadcrumb><ol class=breadcrumb><li class=breadcrumb-item><a href=/docs>Docs</a></li><li class=breadcrumb-item><a href=/docs/demo>Demo</a></li></ol><h1>Demo File</h1></header><div class=odin-article><p>Source: <a href=https://github.com/odin-lang/Odin/blob/master/examples/demo/demo.odin>demo.odin</a></p><p>The original demonstration of the Odin in a single file, including numerous examples of concepts and features of the programming language.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-odin data-lang=odin><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#f92672>+</span>vet <span style=color:#960050;background-color:#1e0010>!</span><span style=color:#66d9ef>using</span><span style=color:#f92672>-</span>stmt <span style=color:#960050;background-color:#1e0010>!</span><span style=color:#66d9ef>using</span><span style=color:#f92672>-</span>param
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#f92672>+</span>feature <span style=color:#66d9ef>dynamic</span><span style=color:#f92672>-</span>literals
</span></span><span style=display:flex><span><span style=color:#f92672>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;core:fmt&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;core:mem&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;core:os&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;core:thread&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;core:time&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;core:reflect&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;base:runtime&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;base:intrinsics&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;core:math/big&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>	Odin is a general-purpose programming language with distinct typing built
</span></span></span><span style=display:flex><span><span style=color:#75715e>	for high performance, modern systems and data-oriented programming.
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>	Odin is the C alternative for the Joy of Programming.
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>	# Installing Odin
</span></span></span><span style=display:flex><span><span style=color:#75715e>	Getting Started - https://odin-lang.org/docs/install/
</span></span></span><span style=display:flex><span><span style=color:#75715e>		Instructions for downloading and install the Odin compiler and libraries.
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>	# Learning Odin
</span></span></span><span style=display:flex><span><span style=color:#75715e>	Getting Started - https://odin-lang.org/docs/install/
</span></span></span><span style=display:flex><span><span style=color:#75715e>		Getting Started with Odin. Downloading, installing, and getting your
</span></span></span><span style=display:flex><span><span style=color:#75715e>		first program to compile and run.
</span></span></span><span style=display:flex><span><span style=color:#75715e>	Overview of Odin - https://odin-lang.org/docs/overview/
</span></span></span><span style=display:flex><span><span style=color:#75715e>		An overview of the Odin programming language and its features.
</span></span></span><span style=display:flex><span><span style=color:#75715e>	Frequently Asked Questions (FAQ) - https://odin-lang.org/docs/faq/
</span></span></span><span style=display:flex><span><span style=color:#75715e>		Answers to common questions about Odin.
</span></span></span><span style=display:flex><span><span style=color:#75715e>	Packages - https://pkg.odin-lang.org/
</span></span></span><span style=display:flex><span><span style=color:#75715e>		Documentation for all the official packages part of the
</span></span></span><span style=display:flex><span><span style=color:#75715e>		core and vendor library collections.
</span></span></span><span style=display:flex><span><span style=color:#75715e>	Nightly Builds - https://odin-lang.org/docs/nightly/
</span></span></span><span style=display:flex><span><span style=color:#75715e>		Get the latest nightly builds of Odin.
</span></span></span><span style=display:flex><span><span style=color:#75715e>	More Odin Examples - https://github.com/odin-lang/examples
</span></span></span><span style=display:flex><span><span style=color:#75715e>		This repository contains examples of how certain things can be accomplished
</span></span></span><span style=display:flex><span><span style=color:#75715e>		in idiomatic Odin, allowing you learn its semantics, as well as how to use
</span></span></span><span style=display:flex><span><span style=color:#75715e>		parts of the core and vendor package collections.
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>the_basics <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() {
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;\n# the basics&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	{ <span style=color:#75715e>// The Basics
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// os.args holds the path to the current executable and any arguments passed to it.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#66d9ef>len</span>(os.args) <span style=color:#f92672>==</span> <span style=color:#a6e22e>1</span> {
</span></span><span style=display:flex><span>			fmt.printf(<span style=color:#e6db74>&#34;Hellope from %v.\n&#34;</span>, os.args[<span style=color:#a6e22e>0</span>])
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>len</span>(os.args) <span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>2</span> {
</span></span><span style=display:flex><span>			fmt.printf(<span style=color:#e6db74>&#34;%v, %v! from %v.\n&#34;</span>, os.args[<span style=color:#a6e22e>1</span>], os.args[<span style=color:#a6e22e>2</span>], os.args[<span style=color:#a6e22e>0</span>])
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Lexical elements and literals
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// A comment
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		my_integer_variable<span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span> <span style=color:#75715e>// A comment for documentaton
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Multi-line comments begin with /* and end with */. Multi-line comments can
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// also be nested (unlike in C):
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>			You can have any text or code here and
</span></span></span><span style=display:flex><span><span style=color:#75715e>			have it be commented.
</span></span></span><span style=display:flex><span><span style=color:#75715e>			/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>				NOTE: comments can be nested!
</span></span></span><span style=display:flex><span><span style=color:#75715e>			*/
</span></span></span><span style=display:flex><span><span style=color:#75715e>		*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// String literals are enclosed in double quotes and character literals in single quotes.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// Special characters are escaped with a backslash \
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		some_string <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;This is a string&#34;</span>
</span></span><span style=display:flex><span>		_ <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;A&#39;</span> <span style=color:#75715e>// unicode codepoint literal
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		_ <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;\n&#39;</span>
</span></span><span style=display:flex><span>		_ <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;C:\\Windows\\notepad.exe&#34;</span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Raw string literals are enclosed with single back ticks
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		_ <span style=color:#f92672>=</span> <span style=color:#e6db74>`C:\Windows\notepad.exe`</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// The length of a string in bytes can be found using the built-in `len` procedure:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		_ <span style=color:#f92672>=</span> <span style=color:#66d9ef>len</span>(<span style=color:#e6db74>&#34;Foo&#34;</span>)
</span></span><span style=display:flex><span>		_ <span style=color:#f92672>=</span> <span style=color:#66d9ef>len</span>(some_string)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Numbers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Numerical literals are written similar to most other programming languages.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// A useful feature in Odin is that underscores are allowed for better
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// readability: 1_000_000_000 (one billion). A number that contains a dot is a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// floating point literal: 1.0e9 (one billion). If a number literal is suffixed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// with i, is an imaginary number literal: 2i (2 multiply the square root of -1).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Binary literals are prefixed with 0b, octal literals with 0o, and hexadecimal
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// literals 0x. A leading zero does not produce an octal constant (unlike C).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// In Odin, if a numeric constant can be represented by a type without
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// precision loss, it will automatically convert to that type.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		x<span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>1</span><span style=color:#ae81ff>.0</span> <span style=color:#75715e>// A float literal but it can be represented by an integer without precision loss
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// Constant literals are “untyped” which means that they can implicitly convert to a type.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		y<span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span> <span style=color:#75715e>// `y` is typed of type `int`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		y <span style=color:#f92672>=</span> <span style=color:#a6e22e>1</span>  <span style=color:#75715e>// `1` is an untyped integer literal which can implicitly convert to `int`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		z<span style=color:#f92672>:</span> <span style=color:#66d9ef>f64</span> <span style=color:#75715e>// `z` is typed of type `f64` (64-bit floating point number)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		z <span style=color:#f92672>=</span> <span style=color:#a6e22e>1</span>  <span style=color:#75715e>// `1` is an untyped integer literal which can be implicitly converted to `f64`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#75715e>// No need for any suffixes or decimal places like in other languages
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#75715e>// (with the exception of negative zero, which must be given as `-0.0`)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#75715e>// CONSTANTS JUST WORK!!!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Assignment statements
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		h<span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>123</span> <span style=color:#75715e>// declares a new variable `h` with type `int` and assigns a value to it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		h <span style=color:#f92672>=</span> <span style=color:#a6e22e>637</span> <span style=color:#75715e>// assigns a new value to `h`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// `=` is the assignment operator
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// You can assign multiple variables with it:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		a, b <span style=color:#f92672>:=</span> <span style=color:#a6e22e>1</span>, <span style=color:#e6db74>&#34;hello&#34;</span> <span style=color:#75715e>// declares `a` and `b` and infers the types from the assignments
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		b, a <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;byte&#34;</span>, <span style=color:#a6e22e>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Note: `:=` is two tokens, `:` and `=`. The following are equivalent,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>			i: int = 123
</span></span></span><span style=display:flex><span><span style=color:#75715e>			i:     = 123
</span></span></span><span style=display:flex><span><span style=color:#75715e>			i := 123
</span></span></span><span style=display:flex><span><span style=color:#75715e>		*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Constant declarations
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// Constants are entities (symbols) which have an assigned value.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// The constant’s value cannot be changed.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// The constant’s value must be able to be evaluated at compile time:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		X <span style=color:#f92672>::</span> <span style=color:#e6db74>&#34;what&#34;</span> <span style=color:#75715e>// constant `X` has the untyped string value &#34;what&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Constants can be explicitly typed like a variable declaration:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		Y <span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>:</span> <span style=color:#a6e22e>123</span>
</span></span><span style=display:flex><span>		Z <span style=color:#f92672>::</span> Y <span style=color:#f92672>+</span> <span style=color:#a6e22e>7</span> <span style=color:#75715e>// constant computations are possible
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		_ <span style=color:#f92672>=</span> my_integer_variable
</span></span><span style=display:flex><span>		_ <span style=color:#f92672>=</span> x
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>control_flow <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() {
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;\n# control flow&#34;</span>)
</span></span><span style=display:flex><span>	{ <span style=color:#75715e>// Control flow
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// For loop
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// Odin has only one loop statement, the `for` loop
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Basic for loop
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>for</span> i <span style=color:#f92672>:=</span> <span style=color:#a6e22e>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>10</span>; i <span style=color:#f92672>+=</span> <span style=color:#a6e22e>1</span> {
</span></span><span style=display:flex><span>			fmt.println(i)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// NOTE: Unlike other languages like C, there are no parentheses `( )` surrounding the three components.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// Braces `{ }` or a `do` are always required
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>for</span> i <span style=color:#f92672>:=</span> <span style=color:#a6e22e>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>10</span>; i <span style=color:#f92672>+=</span> <span style=color:#a6e22e>1</span> { }
</span></span><span style=display:flex><span>		<span style=color:#75715e>// for i := 0; i &lt; 10; i += 1 do fmt.print()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// The initial and post statements are optional
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		i <span style=color:#f92672>:=</span> <span style=color:#a6e22e>0</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> ; i <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>10</span>; {
</span></span><span style=display:flex><span>			i <span style=color:#f92672>+=</span> <span style=color:#a6e22e>1</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// These semicolons can be dropped. This `for` loop is equivalent to C&#39;s `while` loop
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		i <span style=color:#f92672>=</span> <span style=color:#a6e22e>0</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> i <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>10</span> {
</span></span><span style=display:flex><span>			i <span style=color:#f92672>+=</span> <span style=color:#a6e22e>1</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// If the condition is omitted, an infinite loop is produced:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Range-based for loop
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// The basic for loop
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>for</span> j <span style=color:#f92672>:=</span> <span style=color:#a6e22e>0</span>; j <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>10</span>; j <span style=color:#f92672>+=</span> <span style=color:#a6e22e>1</span> {
</span></span><span style=display:flex><span>			fmt.println(j)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#75715e>// can also be written
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>for</span> j <span style=color:#66d9ef>in</span> <span style=color:#a6e22e>0</span><span style=color:#f92672>..&lt;</span><span style=color:#a6e22e>10</span> {
</span></span><span style=display:flex><span>			fmt.println(j)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> j <span style=color:#66d9ef>in</span> <span style=color:#a6e22e>0</span><span style=color:#f92672>..=</span><span style=color:#a6e22e>9</span> {
</span></span><span style=display:flex><span>			fmt.println(j)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Certain built-in types can be iterated over
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		some_string <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;Hello, 世界&#34;</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> character <span style=color:#66d9ef>in</span> some_string { <span style=color:#75715e>// Strings are assumed to be UTF-8
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			fmt.println(character)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		some_array <span style=color:#f92672>:=</span> [<span style=color:#a6e22e>3</span>]<span style=color:#66d9ef>int</span>{<span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>4</span>, <span style=color:#a6e22e>9</span>}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> value <span style=color:#66d9ef>in</span> some_array {
</span></span><span style=display:flex><span>			fmt.println(value)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		some_slice <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>4</span>, <span style=color:#a6e22e>9</span>}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> value <span style=color:#66d9ef>in</span> some_slice {
</span></span><span style=display:flex><span>			fmt.println(value)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		some_dynamic_array <span style=color:#f92672>:=</span> [<span style=color:#66d9ef>dynamic</span>]<span style=color:#66d9ef>int</span>{<span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>4</span>, <span style=color:#a6e22e>9</span>}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>delete</span>(some_dynamic_array)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> value <span style=color:#66d9ef>in</span> some_dynamic_array {
</span></span><span style=display:flex><span>			fmt.println(value)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		some_map <span style=color:#f92672>:=</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span>{<span style=color:#e6db74>&#34;A&#34;</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>1</span>, <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>9</span>, <span style=color:#e6db74>&#34;B&#34;</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>4</span>}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>delete</span>(some_map)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> key <span style=color:#66d9ef>in</span> some_map {
</span></span><span style=display:flex><span>			fmt.println(key)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Alternatively a second index value can be added
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>for</span> character, index <span style=color:#66d9ef>in</span> some_string {
</span></span><span style=display:flex><span>			fmt.println(index, character)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> value, index <span style=color:#66d9ef>in</span> some_array {
</span></span><span style=display:flex><span>			fmt.println(index, value)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> value, index <span style=color:#66d9ef>in</span> some_slice {
</span></span><span style=display:flex><span>			fmt.println(index, value)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> value, index <span style=color:#66d9ef>in</span> some_dynamic_array {
</span></span><span style=display:flex><span>			fmt.println(index, value)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> key, value <span style=color:#66d9ef>in</span> some_map {
</span></span><span style=display:flex><span>			fmt.println(key, value)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// The iterated values are copies and cannot be written to.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// The following idiom is useful for iterating over a container in a by-reference manner:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>for</span> _, idx <span style=color:#66d9ef>in</span> some_slice {
</span></span><span style=display:flex><span>			some_slice[idx] <span style=color:#f92672>=</span> (idx<span style=color:#f92672>+</span><span style=color:#a6e22e>1</span>)<span style=color:#f92672>*</span>(idx<span style=color:#f92672>+</span><span style=color:#a6e22e>1</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// If statements
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		x <span style=color:#f92672>:=</span> <span style=color:#a6e22e>123</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> x <span style=color:#f92672>&gt;=</span> <span style=color:#a6e22e>0</span> {
</span></span><span style=display:flex><span>			fmt.println(<span style=color:#e6db74>&#34;x is positive&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> y <span style=color:#f92672>:=</span> <span style=color:#f92672>-</span><span style=color:#a6e22e>34</span>; y <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>0</span> {
</span></span><span style=display:flex><span>			fmt.println(<span style=color:#e6db74>&#34;y is negative&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> y <span style=color:#f92672>:=</span> <span style=color:#a6e22e>123</span>; y <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>0</span> {
</span></span><span style=display:flex><span>			fmt.println(<span style=color:#e6db74>&#34;y is negative&#34;</span>)
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> y <span style=color:#f92672>==</span> <span style=color:#a6e22e>0</span> {
</span></span><span style=display:flex><span>			fmt.println(<span style=color:#e6db74>&#34;y is zero&#34;</span>)
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			fmt.println(<span style=color:#e6db74>&#34;y is positive&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Switch statement
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// A switch statement is another way to write a sequence of if-else statements.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// In Odin, the default case is denoted as a case without any expression.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>#partial</span> <span style=color:#66d9ef>switch</span> arch <span style=color:#f92672>:=</span> ODIN_ARCH; arch {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> .i386<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>			fmt.println(<span style=color:#e6db74>&#34;32-bit&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> .amd64<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>			fmt.println(<span style=color:#e6db74>&#34;64-bit&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span><span style=color:#f92672>:</span> <span style=color:#75715e>// default
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			fmt.println(<span style=color:#e6db74>&#34;Unsupported architecture&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Odin’s `switch` is like one in C or C++, except that Odin only runs the selected case.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// This means that a `break` statement is not needed at the end of each case.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// Another important difference is that the case values need not be integers nor constants.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// To achieve a C-like fall through into the next case block, the keyword `fallthrough` can be used.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		one_angry_dwarf <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>			fmt.println(<span style=color:#e6db74>&#34;one_angry_dwarf was called&#34;</span>)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>1</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>switch</span> j <span style=color:#f92672>:=</span> <span style=color:#a6e22e>0</span>; j {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>0</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> one_angry_dwarf()<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// A switch statement without a condition is the same as `switch true`.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// This can be used to write a clean and long if-else chain and have the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// ability to break if needed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>switch</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> x <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>0</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>			fmt.println(<span style=color:#e6db74>&#34;x is negative&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> x <span style=color:#f92672>==</span> <span style=color:#a6e22e>0</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>			fmt.println(<span style=color:#e6db74>&#34;x is zero&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>			fmt.println(<span style=color:#e6db74>&#34;x is positive&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// A `switch` statement can also use ranges like a range-based loop:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>switch</span> c <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#39;j&#39;</span>; c {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;A&#39;</span><span style=color:#f92672>..=</span><span style=color:#e6db74>&#39;Z&#39;</span>, <span style=color:#e6db74>&#39;a&#39;</span><span style=color:#f92672>..=</span><span style=color:#e6db74>&#39;z&#39;</span>, <span style=color:#e6db74>&#39;0&#39;</span><span style=color:#f92672>..=</span><span style=color:#e6db74>&#39;9&#39;</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>			fmt.println(<span style=color:#e6db74>&#34;c is alphanumeric&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>switch</span> x {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>0</span><span style=color:#f92672>..&lt;</span><span style=color:#a6e22e>10</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>			fmt.println(<span style=color:#e6db74>&#34;units&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>10</span><span style=color:#f92672>..&lt;</span><span style=color:#a6e22e>13</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>			fmt.println(<span style=color:#e6db74>&#34;pre-teens&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>13</span><span style=color:#f92672>..&lt;</span><span style=color:#a6e22e>20</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>			fmt.println(<span style=color:#e6db74>&#34;teens&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>20</span><span style=color:#f92672>..&lt;</span><span style=color:#a6e22e>30</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>			fmt.println(<span style=color:#e6db74>&#34;twenties&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	{ <span style=color:#75715e>// Defer statement
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// A defer statement defers the execution of a statement until the end of
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// the scope it is in.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// The following will print 4 then 234:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		{
</span></span><span style=display:flex><span>			x <span style=color:#f92672>:=</span> <span style=color:#a6e22e>123</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>defer</span> fmt.println(x)
</span></span><span style=display:flex><span>			{
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>defer</span> x <span style=color:#f92672>=</span> <span style=color:#a6e22e>4</span>
</span></span><span style=display:flex><span>				x <span style=color:#f92672>=</span> <span style=color:#a6e22e>2</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			fmt.println(x)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			x <span style=color:#f92672>=</span> <span style=color:#a6e22e>234</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// You can defer an entire block too:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		{
</span></span><span style=display:flex><span>			bar <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>defer</span> {
</span></span><span style=display:flex><span>				fmt.println(<span style=color:#e6db74>&#34;1&#34;</span>)
</span></span><span style=display:flex><span>				fmt.println(<span style=color:#e6db74>&#34;2&#34;</span>)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			cond <span style=color:#f92672>:=</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>if</span> cond {
</span></span><span style=display:flex><span>				bar()
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Defer statements are executed in the reverse order that they were declared:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		{
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>defer</span> fmt.println(<span style=color:#e6db74>&#34;1&#34;</span>)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>defer</span> fmt.println(<span style=color:#e6db74>&#34;2&#34;</span>)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>defer</span> fmt.println(<span style=color:#e6db74>&#34;3&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Will print 3, 2, and then 1.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#66d9ef>false</span> {
</span></span><span style=display:flex><span>			f, err <span style=color:#f92672>:=</span> os.open(<span style=color:#e6db74>&#34;my_file.txt&#34;</span>)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> err <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>				<span style=color:#75715e>// handle error
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			}
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>defer</span> os.close(f)
</span></span><span style=display:flex><span>			<span style=color:#75715e>// rest of code
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	{ <span style=color:#75715e>// When statement
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>			The when statement is almost identical to the if statement but with some differences:
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>			* Each condition must be a constant expression as a when
</span></span></span><span style=display:flex><span><span style=color:#75715e>			  statement is evaluated at compile time.
</span></span></span><span style=display:flex><span><span style=color:#75715e>			* The statements within a branch do not create a new scope
</span></span></span><span style=display:flex><span><span style=color:#75715e>			* The compiler checks the semantics and code only for statements
</span></span></span><span style=display:flex><span><span style=color:#75715e>			  that belong to the first condition that is true
</span></span></span><span style=display:flex><span><span style=color:#75715e>			* An initial statement is not allowed in a when statement
</span></span></span><span style=display:flex><span><span style=color:#75715e>			* when statements are allowed at file scope
</span></span></span><span style=display:flex><span><span style=color:#75715e>		*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Example
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>when</span> ODIN_ARCH <span style=color:#f92672>==</span> .i386 {
</span></span><span style=display:flex><span>			fmt.println(<span style=color:#e6db74>&#34;32 bit&#34;</span>)
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>when</span> ODIN_ARCH <span style=color:#f92672>==</span> .amd64 {
</span></span><span style=display:flex><span>			fmt.println(<span style=color:#e6db74>&#34;64 bit&#34;</span>)
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			fmt.println(<span style=color:#e6db74>&#34;Unknown architecture&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#75715e>// The when statement is very useful for writing platform specific code.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// This is akin to the #if construct in C’s preprocessor however, in Odin,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// it is type checked.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	{ <span style=color:#75715e>// Branch statements
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		cond, cond1, cond2 <span style=color:#f92672>:=</span> <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>		one_step <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() { fmt.println(<span style=color:#e6db74>&#34;one_step&#34;</span>) }
</span></span><span style=display:flex><span>		beyond <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() { fmt.println(<span style=color:#e6db74>&#34;beyond&#34;</span>) }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Break statement
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>for</span> cond {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>switch</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>case</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> cond {
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>break</span> <span style=color:#75715e>// break out of the `switch` statement
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				}
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span> <span style=color:#75715e>// break out of the `for` statement
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		loop<span style=color:#f92672>:</span> <span style=color:#66d9ef>for</span> cond1 {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>for</span> cond2 {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span> loop <span style=color:#75715e>// leaves both loops
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Continue statement
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>for</span> cond {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> cond2 {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			fmt.println(<span style=color:#e6db74>&#34;Hellope&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Fallthrough statement
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Odin’s switch is like one in C or C++, except that Odin only runs the selected
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// case. This means that a break statement is not needed at the end of each case.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// Another important difference is that the case values need not be integers nor
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// constants.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// fallthrough can be used to explicitly fall through into the next case block:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>switch</span> i <span style=color:#f92672>:=</span> <span style=color:#a6e22e>0</span>; i {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>0</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>			one_step()
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>fallthrough</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>1</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>			beyond()
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>named_proc_return_parameters <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() {
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;\n# named proc return parameters&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	foo0 <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>123</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	foo1 <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() <span style=color:#f92672>-&gt;</span> (a<span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>		a <span style=color:#f92672>=</span> <span style=color:#a6e22e>123</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	foo2 <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() <span style=color:#f92672>-&gt;</span> (a, b<span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Named return values act like variables within the scope
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		a <span style=color:#f92672>=</span> <span style=color:#a6e22e>321</span>
</span></span><span style=display:flex><span>		b <span style=color:#f92672>=</span> <span style=color:#a6e22e>567</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> b, a
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;foo0 =&#34;</span>, foo0()) <span style=color:#75715e>// 123
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	fmt.println(<span style=color:#e6db74>&#34;foo1 =&#34;</span>, foo1()) <span style=color:#75715e>// 123
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	fmt.println(<span style=color:#e6db74>&#34;foo2 =&#34;</span>, foo2()) <span style=color:#75715e>// 567 321
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>variadic_procedures <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() {
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;\n# variadic procedures&#34;</span>)
</span></span><span style=display:flex><span>	sum <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(nums<span style=color:#f92672>:</span> ..<span style=color:#66d9ef>int</span>, init_value<span style=color:#f92672>:=</span> <span style=color:#a6e22e>0</span>) <span style=color:#f92672>-&gt;</span> (result<span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>		result <span style=color:#f92672>=</span> init_value
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> n <span style=color:#66d9ef>in</span> nums {
</span></span><span style=display:flex><span>			result <span style=color:#f92672>+=</span> n
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;sum(()) =&#34;</span>, sum())
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;sum(1, 2) =&#34;</span>, sum(<span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>2</span>))
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;sum(1, 2, 3, 4, 5) =&#34;</span>, sum(<span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>2</span>, <span style=color:#a6e22e>3</span>, <span style=color:#a6e22e>4</span>, <span style=color:#a6e22e>5</span>))
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;sum(1, 2, 3, 4, 5, init_value = 5) =&#34;</span>, sum(<span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>2</span>, <span style=color:#a6e22e>3</span>, <span style=color:#a6e22e>4</span>, <span style=color:#a6e22e>5</span>, init_value <span style=color:#f92672>=</span> <span style=color:#a6e22e>5</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// pass a slice as varargs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	odds <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>3</span>, <span style=color:#a6e22e>5</span>}
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;odds =&#34;</span>, odds)
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;sum(..odds) =&#34;</span>, sum(..odds))
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;sum(..odds, init_value = 5) =&#34;</span>, sum(..odds, init_value <span style=color:#f92672>=</span> <span style=color:#a6e22e>5</span>))
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>explicit_procedure_overloading <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() {
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;\n# explicit procedure overloading&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	add_ints <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(a, b<span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>		x <span style=color:#f92672>:=</span> a <span style=color:#f92672>+</span> b
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#e6db74>&#34;add_ints&#34;</span>, x)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> x
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	add_floats <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(a, b<span style=color:#f92672>:</span> <span style=color:#66d9ef>f32</span>) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>f32</span> {
</span></span><span style=display:flex><span>		x <span style=color:#f92672>:=</span> a <span style=color:#f92672>+</span> b
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#e6db74>&#34;add_floats&#34;</span>, x)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> x
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	add_numbers <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(a<span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>, b<span style=color:#f92672>:</span> <span style=color:#66d9ef>f32</span>, c<span style=color:#f92672>:</span> <span style=color:#66d9ef>u8</span>) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>		x <span style=color:#f92672>:=</span> <span style=color:#66d9ef>int</span>(a) <span style=color:#f92672>+</span> <span style=color:#66d9ef>int</span>(b) <span style=color:#f92672>+</span> <span style=color:#66d9ef>int</span>(c)
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#e6db74>&#34;add_numbers&#34;</span>, x)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> x
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	add <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>{add_ints, add_floats, add_numbers}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	add(<span style=color:#66d9ef>int</span>(<span style=color:#a6e22e>1</span>), <span style=color:#66d9ef>int</span>(<span style=color:#a6e22e>2</span>))
</span></span><span style=display:flex><span>	add(<span style=color:#66d9ef>f32</span>(<span style=color:#a6e22e>1</span>), <span style=color:#66d9ef>f32</span>(<span style=color:#a6e22e>2</span>))
</span></span><span style=display:flex><span>	add(<span style=color:#66d9ef>int</span>(<span style=color:#a6e22e>1</span>), <span style=color:#66d9ef>f32</span>(<span style=color:#a6e22e>2</span>), <span style=color:#66d9ef>u8</span>(<span style=color:#a6e22e>3</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	add(<span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>2</span>)     <span style=color:#75715e>// untyped ints coerce to int tighter than f32
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	add(<span style=color:#a6e22e>1</span><span style=color:#ae81ff>.0</span>, <span style=color:#a6e22e>2</span><span style=color:#ae81ff>.0</span>) <span style=color:#75715e>// untyped floats coerce to f32 tighter than int
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	add(<span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>2</span>, <span style=color:#a6e22e>3</span>)  <span style=color:#75715e>// three parameters
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Ambiguous answers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// add(1.0, 2)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// add(1, 2.0)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>struct_type <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() {
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;\n# struct type&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#75715e>// A struct is a record type in Odin. It is a collection of fields.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Struct fields are accessed by using a dot:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	{
</span></span><span style=display:flex><span>		Vector2 <span style=color:#f92672>::</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>			x<span style=color:#f92672>:</span> <span style=color:#66d9ef>f32</span>,
</span></span><span style=display:flex><span>			y<span style=color:#f92672>:</span> <span style=color:#66d9ef>f32</span>,
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		v <span style=color:#f92672>:=</span> Vector2{<span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>2</span>}
</span></span><span style=display:flex><span>		v.x <span style=color:#f92672>=</span> <span style=color:#a6e22e>4</span>
</span></span><span style=display:flex><span>		fmt.println(v.x)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Struct fields can be accessed through a struct pointer:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		v <span style=color:#f92672>=</span> Vector2{<span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>2</span>}
</span></span><span style=display:flex><span>		p <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span>v
</span></span><span style=display:flex><span>		p.x <span style=color:#f92672>=</span> <span style=color:#a6e22e>1335</span>
</span></span><span style=display:flex><span>		fmt.println(v)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// We could write p^.x, however, it is nice to abstract the ability
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// to not explicitly dereference the pointer. This is very useful when
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// refactoring code to use a pointer rather than a value, and vice versa.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#75715e>// A struct literal can be denoted by providing the struct’s type
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// followed by {}. A struct literal must either provide all the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// arguments or none:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		Vector3 <span style=color:#f92672>::</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>			x, y, z<span style=color:#f92672>:</span> <span style=color:#66d9ef>f32</span>,
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		v<span style=color:#f92672>:</span> Vector3
</span></span><span style=display:flex><span>		v <span style=color:#f92672>=</span> Vector3{} <span style=color:#75715e>// Zero value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		v <span style=color:#f92672>=</span> Vector3{<span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>4</span>, <span style=color:#a6e22e>9</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// You can list just a subset of the fields if you specify the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// field by name (the order of the named fields does not matter):
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		v <span style=color:#f92672>=</span> Vector3{z<span style=color:#f92672>=</span><span style=color:#a6e22e>1</span>, y<span style=color:#f92672>=</span><span style=color:#a6e22e>2</span>}
</span></span><span style=display:flex><span>		assert(v.x <span style=color:#f92672>==</span> <span style=color:#a6e22e>0</span>)
</span></span><span style=display:flex><span>		assert(v.y <span style=color:#f92672>==</span> <span style=color:#a6e22e>2</span>)
</span></span><span style=display:flex><span>		assert(v.z <span style=color:#f92672>==</span> <span style=color:#a6e22e>1</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Structs can tagged with different memory layout and alignment requirements:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		a <span style=color:#f92672>::</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>#align</span>(<span style=color:#a6e22e>4</span>)  {} <span style=color:#75715e>// align to 4 bytes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		b <span style=color:#f92672>::</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>#packed</span>    {} <span style=color:#75715e>// remove padding between fields
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		c <span style=color:#f92672>::</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>#raw_union</span> {} <span style=color:#75715e>// all fields share the same offset (0). This is the same as C&#39;s union
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>union_type <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() {
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;\n# union type&#34;</span>)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		val<span style=color:#f92672>:</span> <span style=color:#66d9ef>union</span>{<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>bool</span>}
</span></span><span style=display:flex><span>		val <span style=color:#f92672>=</span> <span style=color:#a6e22e>137</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> i, ok <span style=color:#f92672>:=</span> val.(<span style=color:#66d9ef>int</span>); ok {
</span></span><span style=display:flex><span>			fmt.println(i)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		val <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>		fmt.println(val)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		val <span style=color:#f92672>=</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>switch</span> v <span style=color:#66d9ef>in</span> val {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>:</span>  fmt.println(<span style=color:#e6db74>&#34;int&#34;</span>,  v)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> <span style=color:#66d9ef>bool</span><span style=color:#f92672>:</span> fmt.println(<span style=color:#e6db74>&#34;bool&#34;</span>, v)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span><span style=color:#f92672>:</span>      fmt.println(<span style=color:#e6db74>&#34;nil&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#75715e>// There is a duality between `any` and `union`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// An `any` has a pointer to the data and allows for any type (open)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// A `union` has as binary blob to store the data and allows only certain types (closed)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// The following code is with `any` but has the same syntax
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		val<span style=color:#f92672>:</span> <span style=color:#66d9ef>any</span>
</span></span><span style=display:flex><span>		val <span style=color:#f92672>=</span> <span style=color:#a6e22e>137</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> i, ok <span style=color:#f92672>:=</span> val.(<span style=color:#66d9ef>int</span>); ok {
</span></span><span style=display:flex><span>			fmt.println(i)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		val <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>		fmt.println(val)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		val <span style=color:#f92672>=</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>switch</span> v <span style=color:#66d9ef>in</span> val {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>:</span>  fmt.println(<span style=color:#e6db74>&#34;int&#34;</span>,  v)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> <span style=color:#66d9ef>bool</span><span style=color:#f92672>:</span> fmt.println(<span style=color:#e6db74>&#34;bool&#34;</span>, v)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span><span style=color:#f92672>:</span>      fmt.println(<span style=color:#e6db74>&#34;nil&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	Vector3 <span style=color:#f92672>::</span> <span style=color:#66d9ef>distinct</span> [<span style=color:#a6e22e>3</span>]<span style=color:#66d9ef>f32</span>
</span></span><span style=display:flex><span>	Quaternion <span style=color:#f92672>::</span> <span style=color:#66d9ef>distinct</span> <span style=color:#66d9ef>quaternion128</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// More realistic examples
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	{
</span></span><span style=display:flex><span>		<span style=color:#75715e>// NOTE(bill): For the above basic examples, you may not have any
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// particular use for it. However, my main use for them is not for these
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// simple cases. My main use is for hierarchical types. Many prefer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// subtyping, embedding the base data into the derived types. Below is
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// an example of this for a basic game Entity.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		Entity <span style=color:#f92672>::</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>			id<span style=color:#f92672>:</span>          <span style=color:#66d9ef>u64</span>,
</span></span><span style=display:flex><span>			name<span style=color:#f92672>:</span>        <span style=color:#66d9ef>string</span>,
</span></span><span style=display:flex><span>			position<span style=color:#f92672>:</span>    Vector3,
</span></span><span style=display:flex><span>			orientation<span style=color:#f92672>:</span> Quaternion,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			derived<span style=color:#f92672>:</span> <span style=color:#66d9ef>any</span>,
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		Frog <span style=color:#f92672>::</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>using</span> entity<span style=color:#f92672>:</span> Entity,
</span></span><span style=display:flex><span>			jump_height<span style=color:#f92672>:</span>  <span style=color:#66d9ef>f32</span>,
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		Monster <span style=color:#f92672>::</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>using</span> entity<span style=color:#f92672>:</span> Entity,
</span></span><span style=display:flex><span>			is_robot<span style=color:#f92672>:</span>     <span style=color:#66d9ef>bool</span>,
</span></span><span style=display:flex><span>			is_zombie<span style=color:#f92672>:</span>    <span style=color:#66d9ef>bool</span>,
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// See `parametric_polymorphism` procedure for details
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		new_entity <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(<span style=color:#960050;background-color:#1e0010>$</span>T<span style=color:#f92672>:</span> <span style=color:#66d9ef>typeid</span>) <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>^</span>Entity {
</span></span><span style=display:flex><span>			t <span style=color:#f92672>:=</span> <span style=color:#66d9ef>new</span>(T)
</span></span><span style=display:flex><span>			t.derived <span style=color:#f92672>=</span> t<span style=color:#f92672>^</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> t
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		entity <span style=color:#f92672>:=</span> new_entity(Monster)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>switch</span> e <span style=color:#66d9ef>in</span> entity.derived {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> Frog<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>			fmt.println(<span style=color:#e6db74>&#34;Ribbit&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> Monster<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> e.is_robot  { fmt.println(<span style=color:#e6db74>&#34;Robotic&#34;</span>) }
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> e.is_zombie { fmt.println(<span style=color:#e6db74>&#34;Grrrr!&#34;</span>)  }
</span></span><span style=display:flex><span>			fmt.println(<span style=color:#e6db74>&#34;I&#39;m a monster&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#75715e>// NOTE(bill): A union can be used to achieve something similar. Instead
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// of embedding the base data into the derived types, the derived data
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// in embedded into the base type. Below is the same example of the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// basic game Entity but using an union.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		Entity <span style=color:#f92672>::</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>			id<span style=color:#f92672>:</span>          <span style=color:#66d9ef>u64</span>,
</span></span><span style=display:flex><span>			name<span style=color:#f92672>:</span>        <span style=color:#66d9ef>string</span>,
</span></span><span style=display:flex><span>			position<span style=color:#f92672>:</span>    Vector3,
</span></span><span style=display:flex><span>			orientation<span style=color:#f92672>:</span> Quaternion,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			derived<span style=color:#f92672>:</span> <span style=color:#66d9ef>union</span> {Frog, Monster},
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		Frog <span style=color:#f92672>::</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>using</span> entity<span style=color:#f92672>:</span> <span style=color:#f92672>^</span>Entity,
</span></span><span style=display:flex><span>			jump_height<span style=color:#f92672>:</span>  <span style=color:#66d9ef>f32</span>,
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		Monster <span style=color:#f92672>::</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>using</span> entity<span style=color:#f92672>:</span> <span style=color:#f92672>^</span>Entity,
</span></span><span style=display:flex><span>			is_robot<span style=color:#f92672>:</span>     <span style=color:#66d9ef>bool</span>,
</span></span><span style=display:flex><span>			is_zombie<span style=color:#f92672>:</span>    <span style=color:#66d9ef>bool</span>,
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// See `parametric_polymorphism` procedure for details
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		new_entity <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(<span style=color:#960050;background-color:#1e0010>$</span>T<span style=color:#f92672>:</span> <span style=color:#66d9ef>typeid</span>) <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>^</span>Entity {
</span></span><span style=display:flex><span>			t <span style=color:#f92672>:=</span> <span style=color:#66d9ef>new</span>(Entity)
</span></span><span style=display:flex><span>			t.derived <span style=color:#f92672>=</span> T{entity <span style=color:#f92672>=</span> t}
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> t
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		entity <span style=color:#f92672>:=</span> new_entity(Monster)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>switch</span> e <span style=color:#66d9ef>in</span> entity.derived {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> Frog<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>			fmt.println(<span style=color:#e6db74>&#34;Ribbit&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> Monster<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> e.is_robot  { fmt.println(<span style=color:#e6db74>&#34;Robotic&#34;</span>) }
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> e.is_zombie { fmt.println(<span style=color:#e6db74>&#34;Grrrr!&#34;</span>)  }
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// NOTE(bill): As you can see, the usage code has not changed, only its
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// memory layout. Both approaches have their own advantages but they can
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// be used together to achieve different results. The subtyping approach
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// can allow for a greater control of the memory layout and memory
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// allocation, e.g. storing the derivatives together. However, this is
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// also its disadvantage. You must either preallocate arrays for each
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// derivative separation (which can be easily missed) or preallocate a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// bunch of &#34;raw&#34; memory; determining the maximum size of the derived
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// types would require the aid of metaprogramming. Unions solve this
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// particular problem as the data is stored with the base data.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// Therefore, it is possible to preallocate, e.g. [100]Entity.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// It should be noted that the union approach can have the same memory
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// layout as the any and with the same type restrictions by using a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// pointer type for the derivatives.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>			Entity :: struct {
</span></span></span><span style=display:flex><span><span style=color:#75715e>				...
</span></span></span><span style=display:flex><span><span style=color:#75715e>				derived: union{^Frog, ^Monster},
</span></span></span><span style=display:flex><span><span style=color:#75715e>			}
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>			Frog :: struct {
</span></span></span><span style=display:flex><span><span style=color:#75715e>				using entity: Entity,
</span></span></span><span style=display:flex><span><span style=color:#75715e>				...
</span></span></span><span style=display:flex><span><span style=color:#75715e>			}
</span></span></span><span style=display:flex><span><span style=color:#75715e>			Monster :: struct {
</span></span></span><span style=display:flex><span><span style=color:#75715e>				using entity: Entity,
</span></span></span><span style=display:flex><span><span style=color:#75715e>				...
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>			}
</span></span></span><span style=display:flex><span><span style=color:#75715e>			new_entity :: proc(T: type) -&gt; ^Entity {
</span></span></span><span style=display:flex><span><span style=color:#75715e>				t := new(T)
</span></span></span><span style=display:flex><span><span style=color:#75715e>				t.derived = t
</span></span></span><span style=display:flex><span><span style=color:#75715e>				return t
</span></span></span><span style=display:flex><span><span style=color:#75715e>			}
</span></span></span><span style=display:flex><span><span style=color:#75715e>		*/</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>using_statement <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() {
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;\n# using statement&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#75715e>// using can used to bring entities declared in a scope/namespace
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// into the current scope. This can be applied to import names, struct
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// fields, procedure fields, and struct values.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	Vector3 <span style=color:#f92672>::</span> <span style=color:#66d9ef>struct</span>{x, y, z<span style=color:#f92672>:</span> <span style=color:#66d9ef>f32</span>}
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		Entity <span style=color:#f92672>::</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>			position<span style=color:#f92672>:</span> Vector3,
</span></span><span style=display:flex><span>			orientation<span style=color:#f92672>:</span> <span style=color:#66d9ef>quaternion128</span>,
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// It can used like this:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		foo0 <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(entity<span style=color:#f92672>:</span> <span style=color:#f92672>^</span>Entity) {
</span></span><span style=display:flex><span>			fmt.println(entity.position.x, entity.position.y, entity.position.z)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// The entity members can be brought into the procedure scope by using it:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		foo1 <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(entity<span style=color:#f92672>:</span> <span style=color:#f92672>^</span>Entity) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>using</span> entity
</span></span><span style=display:flex><span>			fmt.println(position.x, position.y, position.z)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// The using can be applied to the parameter directly:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		foo2 <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(<span style=color:#66d9ef>using</span> entity<span style=color:#f92672>:</span> <span style=color:#f92672>^</span>Entity) {
</span></span><span style=display:flex><span>			fmt.println(position.x, position.y, position.z)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// It can also be applied to sub-fields:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		foo3 <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(entity<span style=color:#f92672>:</span> <span style=color:#f92672>^</span>Entity) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>using</span> entity.position
</span></span><span style=display:flex><span>			fmt.println(x, y, z)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#75715e>// We can also apply the using statement to the struct fields directly,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// making all the fields of position appear as if they on Entity itself:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		Entity <span style=color:#f92672>::</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>using</span> position<span style=color:#f92672>:</span> Vector3,
</span></span><span style=display:flex><span>			orientation<span style=color:#f92672>:</span> <span style=color:#66d9ef>quaternion128</span>,
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		foo <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(entity<span style=color:#f92672>:</span> <span style=color:#f92672>^</span>Entity) {
</span></span><span style=display:flex><span>			fmt.println(entity.x, entity.y, entity.z)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Subtype polymorphism
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// It is possible to get subtype polymorphism, similar to inheritance-like
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// functionality in C++, but without the requirement of vtables or unknown
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// struct layout:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		Colour <span style=color:#f92672>::</span> <span style=color:#66d9ef>struct</span> {r, g, b, a<span style=color:#f92672>:</span> <span style=color:#66d9ef>u8</span>}
</span></span><span style=display:flex><span>		Frog <span style=color:#f92672>::</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>			ribbit_volume<span style=color:#f92672>:</span> <span style=color:#66d9ef>f32</span>,
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>using</span> entity<span style=color:#f92672>:</span> Entity,
</span></span><span style=display:flex><span>			colour<span style=color:#f92672>:</span> Colour,
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		frog<span style=color:#f92672>:</span> Frog
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Both work
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		foo(<span style=color:#f92672>&amp;</span>frog.entity)
</span></span><span style=display:flex><span>		foo(<span style=color:#f92672>&amp;</span>frog)
</span></span><span style=display:flex><span>		frog.x <span style=color:#f92672>=</span> <span style=color:#a6e22e>123</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Note: using can be applied to arbitrarily many things, which allows
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// the ability to have multiple subtype polymorphism (but also its issues).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Note: using’d fields can still be referred by name.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>implicit_context_system <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() {
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;\n# implicit context system&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#75715e>// In each scope, there is an implicit value named context. This
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// context variable is local to each scope and is implicitly passed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// by pointer to any procedure call in that scope (if the procedure
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// has the Odin calling convention).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// The main purpose of the implicit context system is for the ability
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// to intercept third-party code and libraries and modify their
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// functionality. One such case is modifying how a library allocates
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// something or logs something. In C, this was usually achieved with
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// the library defining macros which could be overridden so that the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// user could define what he wanted. However, not many libraries
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// supported this in many languages by default which meant intercepting
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// third-party code to see what it does and to change how it does it is
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// not possible.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	c <span style=color:#f92672>:=</span> <span style=color:#66d9ef>context</span> <span style=color:#75715e>// copy the current scope&#39;s context
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>context</span>.user_index <span style=color:#f92672>=</span> <span style=color:#a6e22e>456</span>
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>context</span>.allocator <span style=color:#f92672>=</span> my_custom_allocator()
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>context</span>.user_index <span style=color:#f92672>=</span> <span style=color:#a6e22e>123</span>
</span></span><span style=display:flex><span>		what_a_fool_believes() <span style=color:#75715e>// the `context` for this scope is implicitly passed to `what_a_fool_believes`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// `context` value is local to the scope it is in
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	assert(<span style=color:#66d9ef>context</span>.user_index <span style=color:#f92672>==</span> <span style=color:#a6e22e>456</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	what_a_fool_believes <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() {
</span></span><span style=display:flex><span>		c <span style=color:#f92672>:=</span> <span style=color:#66d9ef>context</span> <span style=color:#75715e>// this `context` is the same as the parent procedure that it was called from
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// From this example, context.user_index == 123
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// A context.allocator is assigned to the return value of `my_custom_allocator()`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		assert(<span style=color:#66d9ef>context</span>.user_index <span style=color:#f92672>==</span> <span style=color:#a6e22e>123</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// The memory management procedure use the `context.allocator` by
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// default unless explicitly specified otherwise
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		china_grove <span style=color:#f92672>:=</span> <span style=color:#66d9ef>new</span>(<span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>		free(china_grove)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		_ <span style=color:#f92672>=</span> c
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	my_custom_allocator <span style=color:#f92672>::</span> mem.nil_allocator
</span></span><span style=display:flex><span>	_ <span style=color:#f92672>=</span> c
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// By default, the context value has default values for its parameters which is
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// decided in the package runtime. What the defaults are are compiler specific.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// To see what the implicit context value contains, please see the following
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// definition in package runtime.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>parametric_polymorphism <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() {
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;\n# parametric polymorphism&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	print_value <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(value<span style=color:#f92672>:</span> <span style=color:#960050;background-color:#1e0010>$</span>T) {
</span></span><span style=display:flex><span>		fmt.printf(<span style=color:#e6db74>&#34;print_value: %T %v\n&#34;</span>, value, value)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	v1<span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>    <span style=color:#f92672>=</span> <span style=color:#a6e22e>1</span>
</span></span><span style=display:flex><span>	v2<span style=color:#f92672>:</span> <span style=color:#66d9ef>f32</span>    <span style=color:#f92672>=</span> <span style=color:#a6e22e>2</span><span style=color:#ae81ff>.1</span>
</span></span><span style=display:flex><span>	v3<span style=color:#f92672>:</span> <span style=color:#66d9ef>f64</span>    <span style=color:#f92672>=</span> <span style=color:#a6e22e>3</span><span style=color:#ae81ff>.14</span>
</span></span><span style=display:flex><span>	v4<span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;message&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	print_value(v1)
</span></span><span style=display:flex><span>	print_value(v2)
</span></span><span style=display:flex><span>	print_value(v3)
</span></span><span style=display:flex><span>	print_value(v4)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	fmt.println()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	add <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(p, q<span style=color:#f92672>:</span> <span style=color:#960050;background-color:#1e0010>$</span>T) <span style=color:#f92672>-&gt;</span> T {
</span></span><span style=display:flex><span>		x<span style=color:#f92672>:</span> T <span style=color:#f92672>=</span> p <span style=color:#f92672>+</span> q
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> x
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	a <span style=color:#f92672>:=</span> add(<span style=color:#a6e22e>3</span>, <span style=color:#a6e22e>4</span>)
</span></span><span style=display:flex><span>	fmt.printf(<span style=color:#e6db74>&#34;a: %T = %v\n&#34;</span>, a, a)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	b <span style=color:#f92672>:=</span> add(<span style=color:#a6e22e>3</span><span style=color:#ae81ff>.2</span>, <span style=color:#a6e22e>4</span><span style=color:#ae81ff>.3</span>)
</span></span><span style=display:flex><span>	fmt.printf(<span style=color:#e6db74>&#34;b: %T = %v\n&#34;</span>, b, b)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// This is how `new` is implemented
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	alloc_type <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(<span style=color:#960050;background-color:#1e0010>$</span>T<span style=color:#f92672>:</span> <span style=color:#66d9ef>typeid</span>) <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>^</span>T {
</span></span><span style=display:flex><span>		t <span style=color:#f92672>:=</span> <span style=color:#66d9ef>cast</span>(<span style=color:#f92672>^</span>T)mem.alloc(size_of(T), align_of(T))
</span></span><span style=display:flex><span>		t<span style=color:#f92672>^</span> <span style=color:#f92672>=</span> T{} <span style=color:#75715e>// Use default initialization value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>return</span> t
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	copy_slice <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(dst, src<span style=color:#f92672>:</span> []<span style=color:#960050;background-color:#1e0010>$</span>T) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>		n <span style=color:#f92672>:=</span> min(<span style=color:#66d9ef>len</span>(dst), <span style=color:#66d9ef>len</span>(src))
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> n <span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>0</span> {
</span></span><span style=display:flex><span>			mem.<span style=color:#66d9ef>copy</span>(<span style=color:#f92672>&amp;</span>dst[<span style=color:#a6e22e>0</span>], <span style=color:#f92672>&amp;</span>src[<span style=color:#a6e22e>0</span>], n<span style=color:#f92672>*</span>size_of(T))
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> n
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	double_params <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(a<span style=color:#f92672>:</span> <span style=color:#960050;background-color:#1e0010>$</span>A, b<span style=color:#f92672>:</span> <span style=color:#960050;background-color:#1e0010>$</span>B) <span style=color:#f92672>-&gt;</span> A {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> a <span style=color:#f92672>+</span> A(b)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	fmt.println(double_params(<span style=color:#a6e22e>12</span>, <span style=color:#a6e22e>1</span><span style=color:#ae81ff>.345</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	{ <span style=color:#75715e>// Polymorphic Types and Type Specialization
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		Table_Slot <span style=color:#f92672>::</span> <span style=color:#66d9ef>struct</span>(<span style=color:#960050;background-color:#1e0010>$</span>Key, <span style=color:#960050;background-color:#1e0010>$</span>Value<span style=color:#f92672>:</span> <span style=color:#66d9ef>typeid</span>) {
</span></span><span style=display:flex><span>			occupied<span style=color:#f92672>:</span> <span style=color:#66d9ef>bool</span>,
</span></span><span style=display:flex><span>			hash<span style=color:#f92672>:</span>     <span style=color:#66d9ef>u32</span>,
</span></span><span style=display:flex><span>			key<span style=color:#f92672>:</span>      Key,
</span></span><span style=display:flex><span>			value<span style=color:#f92672>:</span>    Value,
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		TABLE_SIZE_MIN <span style=color:#f92672>::</span> <span style=color:#a6e22e>32</span>
</span></span><span style=display:flex><span>		Table <span style=color:#f92672>::</span> <span style=color:#66d9ef>struct</span>(<span style=color:#960050;background-color:#1e0010>$</span>Key, <span style=color:#960050;background-color:#1e0010>$</span>Value<span style=color:#f92672>:</span> <span style=color:#66d9ef>typeid</span>) {
</span></span><span style=display:flex><span>			count<span style=color:#f92672>:</span>     <span style=color:#66d9ef>int</span>,
</span></span><span style=display:flex><span>			allocator<span style=color:#f92672>:</span> mem.Allocator,
</span></span><span style=display:flex><span>			slots<span style=color:#f92672>:</span>     []Table_Slot(Key, Value),
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Only allow types that are specializations of a (polymorphic) slice
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		make_slice <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(<span style=color:#960050;background-color:#1e0010>$</span>T<span style=color:#f92672>:</span> <span style=color:#66d9ef>typeid</span><span style=color:#f92672>/</span>[]<span style=color:#960050;background-color:#1e0010>$</span>E, <span style=color:#66d9ef>len</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>) <span style=color:#f92672>-&gt;</span> T {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>make</span>(T, <span style=color:#66d9ef>len</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Only allow types that are specializations of `Table`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		allocate <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(table<span style=color:#f92672>:</span> <span style=color:#f92672>^</span><span style=color:#960050;background-color:#1e0010>$</span>T<span style=color:#f92672>/</span>Table, capacity<span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>			c <span style=color:#f92672>:=</span> <span style=color:#66d9ef>context</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> table.allocator.procedure <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>				c.allocator <span style=color:#f92672>=</span> table.allocator
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>context</span> <span style=color:#f92672>=</span> c
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			table.slots <span style=color:#f92672>=</span> make_slice(type_of(table.slots), max(capacity, TABLE_SIZE_MIN))
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		expand <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(table<span style=color:#f92672>:</span> <span style=color:#f92672>^</span><span style=color:#960050;background-color:#1e0010>$</span>T<span style=color:#f92672>/</span>Table) {
</span></span><span style=display:flex><span>			c <span style=color:#f92672>:=</span> <span style=color:#66d9ef>context</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> table.allocator.procedure <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>				c.allocator <span style=color:#f92672>=</span> table.allocator
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>context</span> <span style=color:#f92672>=</span> c
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			old_slots <span style=color:#f92672>:=</span> table.slots
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>delete</span>(old_slots)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>cap</span> <span style=color:#f92672>:=</span> max(<span style=color:#a6e22e>2</span><span style=color:#f92672>*</span><span style=color:#66d9ef>len</span>(table.slots), TABLE_SIZE_MIN)
</span></span><span style=display:flex><span>			allocate(table, <span style=color:#66d9ef>cap</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>for</span> s <span style=color:#66d9ef>in</span> old_slots {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> s.occupied {
</span></span><span style=display:flex><span>					put(table, s.key, s.value)
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Polymorphic determination of a polymorphic struct
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// put :: proc(table: ^$T/Table, key: T.Key, value: T.Value) {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		put <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(table<span style=color:#f92672>:</span> <span style=color:#f92672>^</span>Table(<span style=color:#960050;background-color:#1e0010>$</span>Key, <span style=color:#960050;background-color:#1e0010>$</span>Value), key<span style=color:#f92672>:</span> Key, value<span style=color:#f92672>:</span> Value) {
</span></span><span style=display:flex><span>			hash <span style=color:#f92672>:=</span> get_hash(key) <span style=color:#75715e>// Ad-hoc method which would fail in a different scope
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			index <span style=color:#f92672>:=</span> find_index(table, key, hash)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> index <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>0</span> {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> <span style=color:#66d9ef>f64</span>(table.count) <span style=color:#f92672>&gt;=</span> <span style=color:#a6e22e>0</span><span style=color:#ae81ff>.75</span><span style=color:#f92672>*</span><span style=color:#66d9ef>f64</span>(<span style=color:#66d9ef>len</span>(table.slots)) {
</span></span><span style=display:flex><span>					expand(table)
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>				assert(table.count <span style=color:#f92672>&lt;=</span> <span style=color:#66d9ef>len</span>(table.slots))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				index <span style=color:#f92672>=</span> <span style=color:#66d9ef>int</span>(hash <span style=color:#f92672>%</span> <span style=color:#66d9ef>u32</span>(<span style=color:#66d9ef>len</span>(table.slots)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>for</span> table.slots[index].occupied {
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>if</span> index <span style=color:#f92672>+=</span> <span style=color:#a6e22e>1</span>; index <span style=color:#f92672>&gt;=</span> <span style=color:#66d9ef>len</span>(table.slots) {
</span></span><span style=display:flex><span>						index <span style=color:#f92672>=</span> <span style=color:#a6e22e>0</span>
</span></span><span style=display:flex><span>					}
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				table.count <span style=color:#f92672>+=</span> <span style=color:#a6e22e>1</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			slot <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span>table.slots[index]
</span></span><span style=display:flex><span>			slot.occupied <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>			slot.hash     <span style=color:#f92672>=</span> hash
</span></span><span style=display:flex><span>			slot.key      <span style=color:#f92672>=</span> key
</span></span><span style=display:flex><span>			slot.value    <span style=color:#f92672>=</span> value
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// find :: proc(table: ^$T/Table, key: T.Key) -&gt; (T.Value, bool) {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		find <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(table<span style=color:#f92672>:</span> <span style=color:#f92672>^</span>Table(<span style=color:#960050;background-color:#1e0010>$</span>Key, <span style=color:#960050;background-color:#1e0010>$</span>Value), key<span style=color:#f92672>:</span> Key) <span style=color:#f92672>-&gt;</span> (Value, <span style=color:#66d9ef>bool</span>) {
</span></span><span style=display:flex><span>			hash <span style=color:#f92672>:=</span> get_hash(key)
</span></span><span style=display:flex><span>			index <span style=color:#f92672>:=</span> find_index(table, key, hash)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> index <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>0</span> {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>return</span> Value{}, <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> table.slots[index].value, <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		find_index <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(table<span style=color:#f92672>:</span> <span style=color:#f92672>^</span>Table(<span style=color:#960050;background-color:#1e0010>$</span>Key, <span style=color:#960050;background-color:#1e0010>$</span>Value), key<span style=color:#f92672>:</span> Key, hash<span style=color:#f92672>:</span> <span style=color:#66d9ef>u32</span>) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#66d9ef>len</span>(table.slots) <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>0</span> {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#a6e22e>1</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			index <span style=color:#f92672>:=</span> <span style=color:#66d9ef>int</span>(hash <span style=color:#f92672>%</span> <span style=color:#66d9ef>u32</span>(<span style=color:#66d9ef>len</span>(table.slots)))
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>for</span> table.slots[index].occupied {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> table.slots[index].hash <span style=color:#f92672>==</span> hash {
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>if</span> table.slots[index].key <span style=color:#f92672>==</span> key {
</span></span><span style=display:flex><span>						<span style=color:#66d9ef>return</span> index
</span></span><span style=display:flex><span>					}
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> index <span style=color:#f92672>+=</span> <span style=color:#a6e22e>1</span>; index <span style=color:#f92672>&gt;=</span> <span style=color:#66d9ef>len</span>(table.slots) {
</span></span><span style=display:flex><span>					index <span style=color:#f92672>=</span> <span style=color:#a6e22e>0</span>
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#a6e22e>1</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		get_hash <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(s<span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span>) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>u32</span> { <span style=color:#75715e>// fnv32a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			h<span style=color:#f92672>:</span> <span style=color:#66d9ef>u32</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>0x811c9dc5</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#a6e22e>0</span><span style=color:#f92672>..&lt;</span><span style=color:#66d9ef>len</span>(s) {
</span></span><span style=display:flex><span>				h <span style=color:#f92672>=</span> (h <span style=color:#960050;background-color:#1e0010>~</span> <span style=color:#66d9ef>u32</span>(s[i])) <span style=color:#f92672>*</span> <span style=color:#a6e22e>0x01000193</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> h
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		table<span style=color:#f92672>:</span> Table(<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#a6e22e>0</span><span style=color:#f92672>..=</span><span style=color:#a6e22e>36</span> { put(<span style=color:#f92672>&amp;</span>table, <span style=color:#e6db74>&#34;Hellope&#34;</span>, i) }
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#a6e22e>0</span><span style=color:#f92672>..=</span><span style=color:#a6e22e>42</span> { put(<span style=color:#f92672>&amp;</span>table, <span style=color:#e6db74>&#34;World!&#34;</span>,  i) }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		found, _ <span style=color:#f92672>:=</span> find(<span style=color:#f92672>&amp;</span>table, <span style=color:#e6db74>&#34;Hellope&#34;</span>)
</span></span><span style=display:flex><span>		fmt.printf(<span style=color:#e6db74>&#34;`found` is %v\n&#34;</span>, found)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		found, _ <span style=color:#f92672>=</span> find(<span style=color:#f92672>&amp;</span>table, <span style=color:#e6db74>&#34;World!&#34;</span>)
</span></span><span style=display:flex><span>		fmt.printf(<span style=color:#e6db74>&#34;`found` is %v\n&#34;</span>, found)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// I would not personally design a hash table like this in production
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// but this is a nice basic example
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// A better approach would either use a `u64` or equivalent for the key
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// and let the user specify the hashing function or make the user store
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// the hashing procedure with the table
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	{ <span style=color:#75715e>// Parametric polymorphic union
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		Error <span style=color:#f92672>::</span> <span style=color:#66d9ef>enum</span> {
</span></span><span style=display:flex><span>			Foo0,
</span></span><span style=display:flex><span>			Foo1,
</span></span><span style=display:flex><span>			Foo2,
</span></span><span style=display:flex><span>			Foo3,
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		Para_Union <span style=color:#f92672>::</span> <span style=color:#66d9ef>union</span>(<span style=color:#960050;background-color:#1e0010>$</span>T<span style=color:#f92672>:</span> <span style=color:#66d9ef>typeid</span>) {T, Error}
</span></span><span style=display:flex><span>		r<span style=color:#f92672>:</span> Para_Union(<span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>		fmt.println(typeid_of(type_of(r)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		fmt.println(r)
</span></span><span style=display:flex><span>		r <span style=color:#f92672>=</span> <span style=color:#a6e22e>123</span>
</span></span><span style=display:flex><span>		fmt.println(r)
</span></span><span style=display:flex><span>		r <span style=color:#f92672>=</span> Error.Foo0 <span style=color:#75715e>// r = .Foo0 is allow too, see implicit selector expressions below
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		fmt.println(r)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	{ <span style=color:#75715e>// Polymorphic names
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		foo <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(<span style=color:#960050;background-color:#1e0010>$</span>N<span style=color:#f92672>:</span> <span style=color:#960050;background-color:#1e0010>$</span>I, <span style=color:#960050;background-color:#1e0010>$</span>T<span style=color:#f92672>:</span> <span style=color:#66d9ef>typeid</span>) <span style=color:#f92672>-&gt;</span> (res<span style=color:#f92672>:</span> [N]T) {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// `N` is the constant value passed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// `I` is the type of N
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// `T` is the type passed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			fmt.printf(<span style=color:#e6db74>&#34;Generating an array of type %v from the value %v of type %v\n&#34;</span>,
</span></span><span style=display:flex><span>					   typeid_of(type_of(res)), N, typeid_of(I))
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#a6e22e>0</span><span style=color:#f92672>..&lt;</span>N {
</span></span><span style=display:flex><span>				res[i] <span style=color:#f92672>=</span> T(i<span style=color:#f92672>*</span>i)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		T <span style=color:#f92672>::</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>		array <span style=color:#f92672>:=</span> foo(<span style=color:#a6e22e>4</span>, T)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> v, i <span style=color:#66d9ef>in</span> array {
</span></span><span style=display:flex><span>			assert(v <span style=color:#f92672>==</span> T(i<span style=color:#f92672>*</span>i))
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Matrix multiplication
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		mul <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(a<span style=color:#f92672>:</span> [<span style=color:#960050;background-color:#1e0010>$</span>M][<span style=color:#960050;background-color:#1e0010>$</span>N]<span style=color:#960050;background-color:#1e0010>$</span>T, b<span style=color:#f92672>:</span> [N][<span style=color:#960050;background-color:#1e0010>$</span>P]T) <span style=color:#f92672>-&gt;</span> (c<span style=color:#f92672>:</span> [M][P]T) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#a6e22e>0</span><span style=color:#f92672>..&lt;</span>M {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>for</span> j <span style=color:#66d9ef>in</span> <span style=color:#a6e22e>0</span><span style=color:#f92672>..&lt;</span>P {
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>for</span> k <span style=color:#66d9ef>in</span> <span style=color:#a6e22e>0</span><span style=color:#f92672>..&lt;</span>N {
</span></span><span style=display:flex><span>						c[i][j] <span style=color:#f92672>+=</span> a[i][k] <span style=color:#f92672>*</span> b[k][j]
</span></span><span style=display:flex><span>					}
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		x <span style=color:#f92672>:=</span> [<span style=color:#a6e22e>2</span>][<span style=color:#a6e22e>3</span>]<span style=color:#66d9ef>f32</span>{
</span></span><span style=display:flex><span>			{<span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>2</span>, <span style=color:#a6e22e>3</span>},
</span></span><span style=display:flex><span>			{<span style=color:#a6e22e>3</span>, <span style=color:#a6e22e>2</span>, <span style=color:#a6e22e>1</span>},
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		y <span style=color:#f92672>:=</span> [<span style=color:#a6e22e>3</span>][<span style=color:#a6e22e>2</span>]<span style=color:#66d9ef>f32</span>{
</span></span><span style=display:flex><span>			{<span style=color:#a6e22e>0</span>, <span style=color:#a6e22e>8</span>},
</span></span><span style=display:flex><span>			{<span style=color:#a6e22e>6</span>, <span style=color:#a6e22e>2</span>},
</span></span><span style=display:flex><span>			{<span style=color:#a6e22e>8</span>, <span style=color:#a6e22e>4</span>},
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		z <span style=color:#f92672>:=</span> mul(x, y)
</span></span><span style=display:flex><span>		assert(z <span style=color:#f92672>==</span> {{<span style=color:#a6e22e>36</span>, <span style=color:#a6e22e>24</span>}, {<span style=color:#a6e22e>20</span>, <span style=color:#a6e22e>32</span>}})
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>prefix_table <span style=color:#f92672>:=</span> [<span style=color:#960050;background-color:#1e0010>?</span>]<span style=color:#66d9ef>string</span>{
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;White&#34;</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;Red&#34;</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;Green&#34;</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;Blue&#34;</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;Octarine&#34;</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;Black&#34;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print_mutex <span style=color:#f92672>:=</span> <span style=color:#66d9ef>b64</span>(<span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@(disabled=!thread.IS_SUPPORTED)</span>
</span></span><span style=display:flex><span>threading_example <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() {
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;\n# threading_example&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	did_acquire <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(m<span style=color:#f92672>:</span> <span style=color:#f92672>^</span><span style=color:#66d9ef>b64</span>) <span style=color:#f92672>-&gt;</span> (acquired<span style=color:#f92672>:</span> <span style=color:#66d9ef>bool</span>) {
</span></span><span style=display:flex><span>		res, ok <span style=color:#f92672>:=</span> intrinsics.atomic_compare_exchange_strong(m, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> ok <span style=color:#f92672>&amp;&amp;</span> res <span style=color:#f92672>==</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	{ <span style=color:#75715e>// Basic Threads
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		fmt.println(<span style=color:#e6db74>&#34;\n## Basic Threads&#34;</span>)
</span></span><span style=display:flex><span>		worker_proc <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(t<span style=color:#f92672>:</span> <span style=color:#f92672>^</span>thread.Thread) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>for</span> iteration <span style=color:#66d9ef>in</span> <span style=color:#a6e22e>1</span><span style=color:#f92672>..=</span><span style=color:#a6e22e>5</span> {
</span></span><span style=display:flex><span>				fmt.printf(<span style=color:#e6db74>&#34;Thread %d is on iteration %d\n&#34;</span>, t.user_index, iteration)
</span></span><span style=display:flex><span>				fmt.printf(<span style=color:#e6db74>&#34;`%s`: iteration %d\n&#34;</span>, prefix_table[t.user_index], iteration)
</span></span><span style=display:flex><span>				time.sleep(<span style=color:#a6e22e>1</span> <span style=color:#f92672>*</span> time.Millisecond)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		threads <span style=color:#f92672>:=</span> <span style=color:#66d9ef>make</span>([<span style=color:#66d9ef>dynamic</span>]<span style=color:#f92672>^</span>thread.Thread, <span style=color:#a6e22e>0</span>, <span style=color:#66d9ef>len</span>(prefix_table))
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>delete</span>(threads)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> _ <span style=color:#66d9ef>in</span> prefix_table {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> t <span style=color:#f92672>:=</span> thread.create(worker_proc); t <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>				t.init_context <span style=color:#f92672>=</span> <span style=color:#66d9ef>context</span>
</span></span><span style=display:flex><span>				t.user_index <span style=color:#f92672>=</span> <span style=color:#66d9ef>len</span>(threads)
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>append</span>(<span style=color:#f92672>&amp;</span>threads, t)
</span></span><span style=display:flex><span>				thread.start(t)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> <span style=color:#66d9ef>len</span>(threads) <span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>for</span> i <span style=color:#f92672>:=</span> <span style=color:#a6e22e>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>len</span>(threads); <span style=color:#75715e>/**/</span> {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> t <span style=color:#f92672>:=</span> threads[i]; thread.is_done(t) {
</span></span><span style=display:flex><span>					fmt.printf(<span style=color:#e6db74>&#34;Thread %d is done\n&#34;</span>, t.user_index)
</span></span><span style=display:flex><span>					thread.destroy(t)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>					ordered_remove(<span style=color:#f92672>&amp;</span>threads, i)
</span></span><span style=display:flex><span>				} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>					i <span style=color:#f92672>+=</span> <span style=color:#a6e22e>1</span>
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	{ <span style=color:#75715e>// Thread Pool
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		fmt.println(<span style=color:#e6db74>&#34;\n## Thread Pool&#34;</span>)
</span></span><span style=display:flex><span>		task_proc <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(t<span style=color:#f92672>:</span> thread.Task) {
</span></span><span style=display:flex><span>			index <span style=color:#f92672>:=</span> t.user_index <span style=color:#f92672>%</span> <span style=color:#66d9ef>len</span>(prefix_table)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>for</span> iteration <span style=color:#66d9ef>in</span> <span style=color:#a6e22e>1</span><span style=color:#f92672>..=</span><span style=color:#a6e22e>5</span> {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>for</span> <span style=color:#960050;background-color:#1e0010>!</span>did_acquire(<span style=color:#f92672>&amp;</span>print_mutex) { thread.yield() } <span style=color:#75715e>// Allow one thread to print at a time.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>				fmt.printf(<span style=color:#e6db74>&#34;Worker Task %d is on iteration %d\n&#34;</span>, t.user_index, iteration)
</span></span><span style=display:flex><span>				fmt.printf(<span style=color:#e6db74>&#34;`%s`: iteration %d\n&#34;</span>, prefix_table[index], iteration)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				print_mutex <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				time.sleep(<span style=color:#a6e22e>1</span> <span style=color:#f92672>*</span> time.Millisecond)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		N <span style=color:#f92672>::</span> <span style=color:#a6e22e>3</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		pool<span style=color:#f92672>:</span> thread.Pool
</span></span><span style=display:flex><span>		thread.pool_init(<span style=color:#f92672>&amp;</span>pool, allocator<span style=color:#f92672>=</span><span style=color:#66d9ef>context</span>.allocator, thread_count<span style=color:#f92672>=</span>N)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>defer</span> thread.pool_destroy(<span style=color:#f92672>&amp;</span>pool)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#a6e22e>0</span><span style=color:#f92672>..&lt;</span><span style=color:#a6e22e>30</span> {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// be mindful of the allocator used for tasks. The allocator needs to be thread safe, or be owned by the task for exclusive use
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			thread.pool_add_task(<span style=color:#f92672>&amp;</span>pool, allocator<span style=color:#f92672>=</span><span style=color:#66d9ef>context</span>.allocator, procedure<span style=color:#f92672>=</span>task_proc, data<span style=color:#f92672>=</span><span style=color:#66d9ef>nil</span>, user_index<span style=color:#f92672>=</span>i)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		thread.pool_start(<span style=color:#f92672>&amp;</span>pool)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			<span style=color:#75715e>// Wait a moment before we cancel a thread
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			time.sleep(<span style=color:#a6e22e>5</span> <span style=color:#f92672>*</span> time.Millisecond)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#75715e>// Allow one thread to print at a time.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>for</span> <span style=color:#960050;background-color:#1e0010>!</span>did_acquire(<span style=color:#f92672>&amp;</span>print_mutex) { thread.yield() }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			thread.terminate(pool.threads[N <span style=color:#f92672>-</span> <span style=color:#a6e22e>1</span>], <span style=color:#a6e22e>0</span>)
</span></span><span style=display:flex><span>			fmt.println(<span style=color:#e6db74>&#34;Canceled last thread&#34;</span>)
</span></span><span style=display:flex><span>			print_mutex <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		thread.pool_finish(<span style=color:#f92672>&amp;</span>pool)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>array_programming <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() {
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;\n# array programming&#34;</span>)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		a <span style=color:#f92672>:=</span> [<span style=color:#a6e22e>3</span>]<span style=color:#66d9ef>f32</span>{<span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>2</span>, <span style=color:#a6e22e>3</span>}
</span></span><span style=display:flex><span>		b <span style=color:#f92672>:=</span> [<span style=color:#a6e22e>3</span>]<span style=color:#66d9ef>f32</span>{<span style=color:#a6e22e>5</span>, <span style=color:#a6e22e>6</span>, <span style=color:#a6e22e>7</span>}
</span></span><span style=display:flex><span>		c <span style=color:#f92672>:=</span> a <span style=color:#f92672>*</span> b
</span></span><span style=display:flex><span>		d <span style=color:#f92672>:=</span> a <span style=color:#f92672>+</span> b
</span></span><span style=display:flex><span>		e <span style=color:#f92672>:=</span> <span style=color:#a6e22e>1</span> <span style=color:#f92672>+</span>  (c <span style=color:#f92672>-</span> d) <span style=color:#f92672>/</span> <span style=color:#a6e22e>2</span>
</span></span><span style=display:flex><span>		fmt.printf(<span style=color:#e6db74>&#34;%.1f\n&#34;</span>, e) <span style=color:#75715e>// [0.5, 3.0, 6.5]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		a <span style=color:#f92672>:=</span> [<span style=color:#a6e22e>3</span>]<span style=color:#66d9ef>f32</span>{<span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>2</span>, <span style=color:#a6e22e>3</span>}
</span></span><span style=display:flex><span>		b <span style=color:#f92672>:=</span> swizzle(a, <span style=color:#a6e22e>2</span>, <span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>0</span>)
</span></span><span style=display:flex><span>		assert(b <span style=color:#f92672>==</span> [<span style=color:#a6e22e>3</span>]<span style=color:#66d9ef>f32</span>{<span style=color:#a6e22e>3</span>, <span style=color:#a6e22e>2</span>, <span style=color:#a6e22e>1</span>})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		c <span style=color:#f92672>:=</span> swizzle(a, <span style=color:#a6e22e>0</span>, <span style=color:#a6e22e>0</span>)
</span></span><span style=display:flex><span>		assert(c <span style=color:#f92672>==</span> [<span style=color:#a6e22e>2</span>]<span style=color:#66d9ef>f32</span>{<span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>1</span>})
</span></span><span style=display:flex><span>		assert(c <span style=color:#f92672>==</span> <span style=color:#a6e22e>1</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		Vector3 <span style=color:#f92672>::</span> <span style=color:#66d9ef>distinct</span> [<span style=color:#a6e22e>3</span>]<span style=color:#66d9ef>f32</span>
</span></span><span style=display:flex><span>		a <span style=color:#f92672>:=</span> Vector3{<span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>2</span>, <span style=color:#a6e22e>3</span>}
</span></span><span style=display:flex><span>		b <span style=color:#f92672>:=</span> Vector3{<span style=color:#a6e22e>5</span>, <span style=color:#a6e22e>6</span>, <span style=color:#a6e22e>7</span>}
</span></span><span style=display:flex><span>		c <span style=color:#f92672>:=</span> (a <span style=color:#f92672>*</span> b)<span style=color:#f92672>/</span><span style=color:#a6e22e>2</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>1</span>
</span></span><span style=display:flex><span>		d <span style=color:#f92672>:=</span> c.x <span style=color:#f92672>+</span> c.y <span style=color:#f92672>+</span> c.z
</span></span><span style=display:flex><span>		fmt.printf(<span style=color:#e6db74>&#34;%.1f\n&#34;</span>, d) <span style=color:#75715e>// 22.0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		cross <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(a, b<span style=color:#f92672>:</span> Vector3) <span style=color:#f92672>-&gt;</span> Vector3 {
</span></span><span style=display:flex><span>			i <span style=color:#f92672>:=</span> swizzle(a, <span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>2</span>, <span style=color:#a6e22e>0</span>) <span style=color:#f92672>*</span> swizzle(b, <span style=color:#a6e22e>2</span>, <span style=color:#a6e22e>0</span>, <span style=color:#a6e22e>1</span>)
</span></span><span style=display:flex><span>			j <span style=color:#f92672>:=</span> swizzle(a, <span style=color:#a6e22e>2</span>, <span style=color:#a6e22e>0</span>, <span style=color:#a6e22e>1</span>) <span style=color:#f92672>*</span> swizzle(b, <span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>2</span>, <span style=color:#a6e22e>0</span>)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> i <span style=color:#f92672>-</span> j
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		cross_shorter <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(a, b<span style=color:#f92672>:</span> Vector3) <span style=color:#f92672>-&gt;</span> Vector3 {
</span></span><span style=display:flex><span>			i <span style=color:#f92672>:=</span> a.yzx <span style=color:#f92672>*</span> b.zxy
</span></span><span style=display:flex><span>			j <span style=color:#f92672>:=</span> a.zxy <span style=color:#f92672>*</span> b.yzx
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> i <span style=color:#f92672>-</span> j
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		blah <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(a<span style=color:#f92672>:</span> Vector3) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>f32</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> a.x <span style=color:#f92672>+</span> a.y <span style=color:#f92672>+</span> a.z
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		x <span style=color:#f92672>:=</span> cross(a, b)
</span></span><span style=display:flex><span>		fmt.println(x)
</span></span><span style=display:flex><span>		fmt.println(blah(x))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>map_type <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() {
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;\n# map type&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	m <span style=color:#f92672>:=</span> <span style=color:#66d9ef>make</span>(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>delete</span>(m)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	m[<span style=color:#e6db74>&#34;Bob&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>2</span>
</span></span><span style=display:flex><span>	m[<span style=color:#e6db74>&#34;Ted&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>5</span>
</span></span><span style=display:flex><span>	fmt.println(m[<span style=color:#e6db74>&#34;Bob&#34;</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	delete_key(<span style=color:#f92672>&amp;</span>m, <span style=color:#e6db74>&#34;Ted&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// If an element of a key does not exist, the zero value of the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// element will be returned. To check to see if an element exists
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// can be done in two ways:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	elem, ok <span style=color:#f92672>:=</span> m[<span style=color:#e6db74>&#34;Bob&#34;</span>]
</span></span><span style=display:flex><span>	exists <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;Bob&#34;</span> <span style=color:#66d9ef>in</span> m
</span></span><span style=display:flex><span>	_, _ <span style=color:#f92672>=</span> elem, ok
</span></span><span style=display:flex><span>	_ <span style=color:#f92672>=</span> exists
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>implicit_selector_expression <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() {
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;\n# implicit selector expression&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	Foo <span style=color:#f92672>::</span> <span style=color:#66d9ef>enum</span> {A, B, C}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	f<span style=color:#f92672>:</span> Foo
</span></span><span style=display:flex><span>	f <span style=color:#f92672>=</span> Foo.A
</span></span><span style=display:flex><span>	f <span style=color:#f92672>=</span> .A
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	BAR <span style=color:#f92672>::</span> <span style=color:#66d9ef>bit_set</span>[Foo]{.B, .C}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>switch</span> f {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> .A<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#e6db74>&#34;HITHER&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> .B<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#e6db74>&#34;NEVER&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> .C<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#e6db74>&#34;FOREVER&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	my_map <span style=color:#f92672>:=</span> <span style=color:#66d9ef>make</span>(<span style=color:#66d9ef>map</span>[Foo]<span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>delete</span>(my_map)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	my_map[.A] <span style=color:#f92672>=</span> <span style=color:#a6e22e>123</span>
</span></span><span style=display:flex><span>	my_map[Foo.B] <span style=color:#f92672>=</span> <span style=color:#a6e22e>345</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	fmt.println(my_map[.A] <span style=color:#f92672>+</span> my_map[Foo.B] <span style=color:#f92672>+</span> my_map[.C])
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>partial_switch <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() {
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;\n# partial_switch&#34;</span>)
</span></span><span style=display:flex><span>	{ <span style=color:#75715e>// enum
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		Foo <span style=color:#f92672>::</span> <span style=color:#66d9ef>enum</span> {
</span></span><span style=display:flex><span>			A,
</span></span><span style=display:flex><span>			B,
</span></span><span style=display:flex><span>			C,
</span></span><span style=display:flex><span>			D,
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		f <span style=color:#f92672>:=</span> Foo.A
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>switch</span> f {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> .A<span style=color:#f92672>:</span> fmt.println(<span style=color:#e6db74>&#34;A&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> .B<span style=color:#f92672>:</span> fmt.println(<span style=color:#e6db74>&#34;B&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> .C<span style=color:#f92672>:</span> fmt.println(<span style=color:#e6db74>&#34;C&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> .D<span style=color:#f92672>:</span> fmt.println(<span style=color:#e6db74>&#34;D&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span><span style=color:#f92672>:</span>    fmt.println(<span style=color:#e6db74>&#34;?&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>#partial</span> <span style=color:#66d9ef>switch</span> f {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> .A<span style=color:#f92672>:</span> fmt.println(<span style=color:#e6db74>&#34;A&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> .D<span style=color:#f92672>:</span> fmt.println(<span style=color:#e6db74>&#34;D&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	{ <span style=color:#75715e>// union
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		Foo <span style=color:#f92672>::</span> <span style=color:#66d9ef>union</span> {<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>bool</span>}
</span></span><span style=display:flex><span>		f<span style=color:#f92672>:</span> Foo <span style=color:#f92672>=</span> <span style=color:#a6e22e>123</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>switch</span> _ <span style=color:#66d9ef>in</span> f {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>:</span>  fmt.println(<span style=color:#e6db74>&#34;int&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> <span style=color:#66d9ef>bool</span><span style=color:#f92672>:</span> fmt.println(<span style=color:#e6db74>&#34;bool&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>#partial</span> <span style=color:#66d9ef>switch</span> _ <span style=color:#66d9ef>in</span> f {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> <span style=color:#66d9ef>bool</span><span style=color:#f92672>:</span> fmt.println(<span style=color:#e6db74>&#34;bool&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cstring_example <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() {
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;\n# cstring_example&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	W <span style=color:#f92672>::</span> <span style=color:#e6db74>&#34;Hellope&#34;</span>
</span></span><span style=display:flex><span>	X <span style=color:#f92672>::</span> <span style=color:#66d9ef>cstring</span>(W)
</span></span><span style=display:flex><span>	Y <span style=color:#f92672>::</span> <span style=color:#66d9ef>string</span>(X)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	w <span style=color:#f92672>:=</span> W
</span></span><span style=display:flex><span>	_ <span style=color:#f92672>=</span> w
</span></span><span style=display:flex><span>	x<span style=color:#f92672>:</span> <span style=color:#66d9ef>cstring</span> <span style=color:#f92672>=</span> X
</span></span><span style=display:flex><span>	y<span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span> <span style=color:#f92672>=</span> Y
</span></span><span style=display:flex><span>	z <span style=color:#f92672>:=</span> <span style=color:#66d9ef>string</span>(x)
</span></span><span style=display:flex><span>	fmt.println(x, y, z)
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#66d9ef>len</span>(x), <span style=color:#66d9ef>len</span>(y), <span style=color:#66d9ef>len</span>(z))
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#66d9ef>len</span>(W), <span style=color:#66d9ef>len</span>(X), <span style=color:#66d9ef>len</span>(Y))
</span></span><span style=display:flex><span>	<span style=color:#75715e>// IMPORTANT NOTE for cstring variables
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// len(cstring) is O(N)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// cast(string)cstring is O(N)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>bit_set_type <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() {
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;\n# bit_set type&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		Day <span style=color:#f92672>::</span> <span style=color:#66d9ef>enum</span> {
</span></span><span style=display:flex><span>			Sunday,
</span></span><span style=display:flex><span>			Monday,
</span></span><span style=display:flex><span>			Tuesday,
</span></span><span style=display:flex><span>			Wednesday,
</span></span><span style=display:flex><span>			Thursday,
</span></span><span style=display:flex><span>			Friday,
</span></span><span style=display:flex><span>			Saturday,
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		Days <span style=color:#f92672>::</span> <span style=color:#66d9ef>distinct</span> <span style=color:#66d9ef>bit_set</span>[Day]
</span></span><span style=display:flex><span>		WEEKEND <span style=color:#f92672>::</span> Days{.Sunday, .Saturday}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		d<span style=color:#f92672>:</span> Days
</span></span><span style=display:flex><span>		d <span style=color:#f92672>=</span> {.Sunday, .Monday}
</span></span><span style=display:flex><span>		e <span style=color:#f92672>:=</span> d <span style=color:#f92672>+</span> WEEKEND
</span></span><span style=display:flex><span>		e <span style=color:#f92672>+=</span> {.Monday}
</span></span><span style=display:flex><span>		fmt.println(d, e)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		ok <span style=color:#f92672>:=</span> .Saturday <span style=color:#66d9ef>in</span> e <span style=color:#75715e>// `in` is only allowed for `map` and `bit_set` types
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		fmt.println(ok)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> .Saturday <span style=color:#66d9ef>in</span> e {
</span></span><span style=display:flex><span>			fmt.println(<span style=color:#e6db74>&#34;Saturday in&#34;</span>, e)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		X <span style=color:#f92672>::</span> .Saturday <span style=color:#66d9ef>in</span> WEEKEND <span style=color:#75715e>// Constant evaluation
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		fmt.println(X)
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#e6db74>&#34;Cardinality:&#34;</span>, card(e))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		x<span style=color:#f92672>:</span> <span style=color:#66d9ef>bit_set</span>[<span style=color:#e6db74>&#39;A&#39;</span><span style=color:#f92672>..=</span><span style=color:#e6db74>&#39;Z&#39;</span>]
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>#assert</span>(size_of(x) <span style=color:#f92672>==</span> size_of(<span style=color:#66d9ef>u32</span>))
</span></span><span style=display:flex><span>		y<span style=color:#f92672>:</span> <span style=color:#66d9ef>bit_set</span>[<span style=color:#a6e22e>0</span><span style=color:#f92672>..=</span><span style=color:#a6e22e>8</span>; <span style=color:#66d9ef>u16</span>]
</span></span><span style=display:flex><span>		fmt.println(typeid_of(type_of(x))) <span style=color:#75715e>// bit_set[A..=Z]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		fmt.println(typeid_of(type_of(y))) <span style=color:#75715e>// bit_set[0..=8; u16]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		x <span style=color:#f92672>+=</span> {<span style=color:#e6db74>&#39;F&#39;</span>}
</span></span><span style=display:flex><span>		assert(<span style=color:#e6db74>&#39;F&#39;</span> <span style=color:#66d9ef>in</span> x)
</span></span><span style=display:flex><span>		x <span style=color:#f92672>-=</span> {<span style=color:#e6db74>&#39;F&#39;</span>}
</span></span><span style=display:flex><span>		assert(<span style=color:#e6db74>&#39;F&#39;</span> <span style=color:#66d9ef>not_in</span> x)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		y <span style=color:#f92672>+=</span> {<span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>4</span>, <span style=color:#a6e22e>2</span>}
</span></span><span style=display:flex><span>		assert(<span style=color:#a6e22e>2</span> <span style=color:#66d9ef>in</span> y)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		Letters <span style=color:#f92672>::</span> <span style=color:#66d9ef>bit_set</span>[<span style=color:#e6db74>&#39;A&#39;</span><span style=color:#f92672>..=</span><span style=color:#e6db74>&#39;Z&#39;</span>]
</span></span><span style=display:flex><span>		a <span style=color:#f92672>:=</span> Letters{<span style=color:#e6db74>&#39;A&#39;</span>, <span style=color:#e6db74>&#39;B&#39;</span>}
</span></span><span style=display:flex><span>		b <span style=color:#f92672>:=</span> Letters{<span style=color:#e6db74>&#39;A&#39;</span>, <span style=color:#e6db74>&#39;B&#39;</span>, <span style=color:#e6db74>&#39;C&#39;</span>, <span style=color:#e6db74>&#39;D&#39;</span>, <span style=color:#e6db74>&#39;F&#39;</span>}
</span></span><span style=display:flex><span>		c <span style=color:#f92672>:=</span> Letters{<span style=color:#e6db74>&#39;A&#39;</span>, <span style=color:#e6db74>&#39;B&#39;</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		assert(a <span style=color:#f92672>&lt;=</span> b) <span style=color:#75715e>// &#39;a&#39; is a subset of &#39;b&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		assert(b <span style=color:#f92672>&gt;=</span> a) <span style=color:#75715e>// &#39;b&#39; is a superset of &#39;a&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		assert(a <span style=color:#f92672>&lt;</span> b)  <span style=color:#75715e>// &#39;a&#39; is a strict subset of &#39;b&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		assert(b <span style=color:#f92672>&gt;</span> a)  <span style=color:#75715e>// &#39;b&#39; is a strict superset of &#39;a&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		assert(<span style=color:#960050;background-color:#1e0010>!</span>(a <span style=color:#f92672>&lt;</span> c)) <span style=color:#75715e>// &#39;a&#39; is a not strict subset of &#39;c&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		assert(<span style=color:#960050;background-color:#1e0010>!</span>(c <span style=color:#f92672>&gt;</span> a)) <span style=color:#75715e>// &#39;c&#39; is a not strict superset of &#39;a&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>deferred_procedure_associations <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() {
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;\n# deferred procedure associations&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@(deferred_out=closure)</span>
</span></span><span style=display:flex><span>	open <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(s<span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span>) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>		fmt.println(s)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	closure <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(ok<span style=color:#f92672>:</span> <span style=color:#66d9ef>bool</span>) {
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#e6db74>&#34;Goodbye?&#34;</span>, ok)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> open(<span style=color:#e6db74>&#34;Welcome&#34;</span>) {
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#e6db74>&#34;Something in the middle, mate.&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>reflection <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() {
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;\n# reflection&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	Foo <span style=color:#f92672>::</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>		x<span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>    <span style=color:#e6db74>`tag1`</span>,
</span></span><span style=display:flex><span>		y<span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span> <span style=color:#e6db74>`json:&#34;y_field&#34;`</span>,
</span></span><span style=display:flex><span>		z<span style=color:#f92672>:</span> <span style=color:#66d9ef>bool</span>, <span style=color:#75715e>// no tag
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	id <span style=color:#f92672>:=</span> typeid_of(Foo)
</span></span><span style=display:flex><span>	names <span style=color:#f92672>:=</span> reflect.struct_field_names(id)
</span></span><span style=display:flex><span>	types <span style=color:#f92672>:=</span> reflect.struct_field_types(id)
</span></span><span style=display:flex><span>	tags  <span style=color:#f92672>:=</span> reflect.struct_field_tags(id)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	assert(<span style=color:#66d9ef>len</span>(names) <span style=color:#f92672>==</span> <span style=color:#66d9ef>len</span>(types) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#66d9ef>len</span>(names) <span style=color:#f92672>==</span> <span style=color:#66d9ef>len</span>(tags))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;Foo :: struct {&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> tag, i <span style=color:#66d9ef>in</span> tags {
</span></span><span style=display:flex><span>		name, type <span style=color:#f92672>:=</span> names[i], types[i]
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> tag <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#34;&#34;</span> {
</span></span><span style=display:flex><span>			fmt.printf(<span style=color:#e6db74>&#34;\t%s: %T `%s`,\n&#34;</span>, name, type, tag)
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			fmt.printf(<span style=color:#e6db74>&#34;\t%s: %T,\n&#34;</span>, name, type)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;}&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> tag, i <span style=color:#66d9ef>in</span> tags {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> val, ok <span style=color:#f92672>:=</span> reflect.struct_tag_lookup(tag, <span style=color:#e6db74>&#34;json&#34;</span>); ok {
</span></span><span style=display:flex><span>			fmt.printf(<span style=color:#e6db74>&#34;json: %s -&gt; %s\n&#34;</span>, names[i], val)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>quaternions <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Not just an April Fool&#39;s Joke any more, but a fully working thing!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	fmt.println(<span style=color:#e6db74>&#34;\n# quaternions&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	{ <span style=color:#75715e>// Quaternion operations
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		q <span style=color:#f92672>:=</span> <span style=color:#a6e22e>1</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>2i</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>3j</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>4k</span>
</span></span><span style=display:flex><span>		r <span style=color:#f92672>:=</span> quaternion(<span style=color:#66d9ef>real</span><span style=color:#f92672>=</span><span style=color:#a6e22e>5</span>, <span style=color:#66d9ef>imag</span><span style=color:#f92672>=</span><span style=color:#a6e22e>6</span>, jmag<span style=color:#f92672>=</span><span style=color:#a6e22e>7</span>, kmag<span style=color:#f92672>=</span><span style=color:#a6e22e>8</span>)
</span></span><span style=display:flex><span>		t <span style=color:#f92672>:=</span> q <span style=color:#f92672>*</span> r
</span></span><span style=display:flex><span>		fmt.printf(<span style=color:#e6db74>&#34;(%v) * (%v) = %v\n&#34;</span>, q, r, t)
</span></span><span style=display:flex><span>		v <span style=color:#f92672>:=</span> q <span style=color:#f92672>/</span> r
</span></span><span style=display:flex><span>		fmt.printf(<span style=color:#e6db74>&#34;(%v) / (%v) = %v\n&#34;</span>, q, r, v)
</span></span><span style=display:flex><span>		u <span style=color:#f92672>:=</span> q <span style=color:#f92672>+</span> r
</span></span><span style=display:flex><span>		fmt.printf(<span style=color:#e6db74>&#34;(%v) + (%v) = %v\n&#34;</span>, q, r, u)
</span></span><span style=display:flex><span>		s <span style=color:#f92672>:=</span> q <span style=color:#f92672>-</span> r
</span></span><span style=display:flex><span>		fmt.printf(<span style=color:#e6db74>&#34;(%v) - (%v) = %v\n&#34;</span>, q, r, s)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	{ <span style=color:#75715e>// The quaternion types
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		q128<span style=color:#f92672>:</span> <span style=color:#66d9ef>quaternion128</span> <span style=color:#75715e>// 4xf32
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		q256<span style=color:#f92672>:</span> <span style=color:#66d9ef>quaternion256</span> <span style=color:#75715e>// 4xf64
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		q128 <span style=color:#f92672>=</span> quaternion(w<span style=color:#f92672>=</span><span style=color:#a6e22e>1</span>, x<span style=color:#f92672>=</span><span style=color:#a6e22e>0</span>, y<span style=color:#f92672>=</span><span style=color:#a6e22e>0</span>, z<span style=color:#f92672>=</span><span style=color:#a6e22e>0</span>)
</span></span><span style=display:flex><span>		q256 <span style=color:#f92672>=</span> <span style=color:#a6e22e>1</span> <span style=color:#75715e>// quaternion(x=0, y=0, z=0, w=1)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// NOTE: The internal memory layout of a quaternion is xyzw
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>	{ <span style=color:#75715e>// Built-in procedures
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		q <span style=color:#f92672>:=</span> <span style=color:#a6e22e>1</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>2i</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>3j</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>4k</span>
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#e6db74>&#34;q =&#34;</span>, q)
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#e6db74>&#34;real(q) =&#34;</span>, <span style=color:#66d9ef>real</span>(q))
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#e6db74>&#34;imag(q) =&#34;</span>, <span style=color:#66d9ef>imag</span>(q))
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#e6db74>&#34;jmag(q) =&#34;</span>, jmag(q))
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#e6db74>&#34;kmag(q) =&#34;</span>, kmag(q))
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#e6db74>&#34;conj(q) =&#34;</span>, conj(q))
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#e6db74>&#34;abs(q)  =&#34;</span>, abs(q))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	{ <span style=color:#75715e>// Conversion of a complex type to a quaternion type
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		c <span style=color:#f92672>:=</span> <span style=color:#a6e22e>1</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>2i</span>
</span></span><span style=display:flex><span>		q <span style=color:#f92672>:=</span> <span style=color:#66d9ef>quaternion256</span>(c)
</span></span><span style=display:flex><span>		fmt.println(c)
</span></span><span style=display:flex><span>		fmt.println(q)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	{ <span style=color:#75715e>// Memory layout of Quaternions
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		q <span style=color:#f92672>:=</span> <span style=color:#a6e22e>1</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>2i</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>3j</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>4k</span>
</span></span><span style=display:flex><span>		a <span style=color:#f92672>:=</span> <span style=color:#66d9ef>transmute</span>([<span style=color:#a6e22e>4</span>]<span style=color:#66d9ef>f64</span>)q
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#e6db74>&#34;Quaternion memory layout: xyzw/(ijkr)&#34;</span>)
</span></span><span style=display:flex><span>		fmt.println(q) <span style=color:#75715e>// 1.000+2.000i+3.000j+4.000k
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		fmt.println(a) <span style=color:#75715e>// [2.000, 3.000, 4.000, 1.000]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>unroll_for_statement <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() {
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;\n#&#39;#unroll for&#39; statements&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// &#39;#unroll for&#39; works the same as if the &#39;inline&#39; prefix did not
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// exist but these ranged loops are explicitly unrolled which can
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// be very very useful for certain optimizations
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;Ranges&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>#unroll</span> <span style=color:#66d9ef>for</span> x, i <span style=color:#66d9ef>in</span> <span style=color:#a6e22e>1</span><span style=color:#f92672>..&lt;</span><span style=color:#a6e22e>4</span> {
</span></span><span style=display:flex><span>		fmt.println(x, i)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;Strings&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>#unroll</span> <span style=color:#66d9ef>for</span> r, i <span style=color:#66d9ef>in</span> <span style=color:#e6db74>&#34;Hello, 世界&#34;</span> {
</span></span><span style=display:flex><span>		fmt.println(r, i)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;Arrays&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>#unroll</span> <span style=color:#66d9ef>for</span> elem, idx <span style=color:#66d9ef>in</span> ([<span style=color:#a6e22e>4</span>]<span style=color:#66d9ef>int</span>{<span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>4</span>, <span style=color:#a6e22e>9</span>, <span style=color:#a6e22e>16</span>}) {
</span></span><span style=display:flex><span>		fmt.println(elem, idx)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	Foo_Enum <span style=color:#f92672>::</span> <span style=color:#66d9ef>enum</span> {
</span></span><span style=display:flex><span>		A <span style=color:#f92672>=</span> <span style=color:#a6e22e>1</span>,
</span></span><span style=display:flex><span>		B,
</span></span><span style=display:flex><span>		C <span style=color:#f92672>=</span> <span style=color:#a6e22e>6</span>,
</span></span><span style=display:flex><span>		D,
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;Enum types&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>#unroll</span> <span style=color:#66d9ef>for</span> elem, idx <span style=color:#66d9ef>in</span> Foo_Enum {
</span></span><span style=display:flex><span>		fmt.println(elem, idx)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>where_clauses <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() {
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;\n#procedure &#39;where&#39; clauses&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	{ <span style=color:#75715e>// Sanity checks
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		simple_sanity_check <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(x<span style=color:#f92672>:</span> [<span style=color:#a6e22e>2</span>]<span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>where</span> <span style=color:#66d9ef>len</span>(x) <span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>1</span>,
</span></span><span style=display:flex><span>				  type_of(x) <span style=color:#f92672>==</span> [<span style=color:#a6e22e>2</span>]<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>			fmt.println(x)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	{ <span style=color:#75715e>// Parametric polymorphism checks
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		cross_2d <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(a, b<span style=color:#f92672>:</span> <span style=color:#960050;background-color:#1e0010>$</span>T<span style=color:#f92672>/</span>[<span style=color:#a6e22e>2</span>]<span style=color:#960050;background-color:#1e0010>$</span>E) <span style=color:#f92672>-&gt;</span> E
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>where</span> intrinsics.type_is_numeric(E) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> a.x<span style=color:#f92672>*</span>b.y <span style=color:#f92672>-</span> a.y<span style=color:#f92672>*</span>b.x
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		cross_3d <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(a, b<span style=color:#f92672>:</span> <span style=color:#960050;background-color:#1e0010>$</span>T<span style=color:#f92672>/</span>[<span style=color:#a6e22e>3</span>]<span style=color:#960050;background-color:#1e0010>$</span>E) <span style=color:#f92672>-&gt;</span> T
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>where</span> intrinsics.type_is_numeric(E) {
</span></span><span style=display:flex><span>			x <span style=color:#f92672>:=</span> a.y<span style=color:#f92672>*</span>b.z <span style=color:#f92672>-</span> a.z<span style=color:#f92672>*</span>b.y
</span></span><span style=display:flex><span>			y <span style=color:#f92672>:=</span> a.z<span style=color:#f92672>*</span>b.x <span style=color:#f92672>-</span> a.x<span style=color:#f92672>*</span>b.z
</span></span><span style=display:flex><span>			z <span style=color:#f92672>:=</span> a.x<span style=color:#f92672>*</span>b.y <span style=color:#f92672>-</span> a.y<span style=color:#f92672>*</span>b.z
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> T{x, y, z}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		a <span style=color:#f92672>:=</span> [<span style=color:#a6e22e>2</span>]<span style=color:#66d9ef>int</span>{<span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>2</span>}
</span></span><span style=display:flex><span>		b <span style=color:#f92672>:=</span> [<span style=color:#a6e22e>2</span>]<span style=color:#66d9ef>int</span>{<span style=color:#a6e22e>5</span>, <span style=color:#f92672>-</span><span style=color:#a6e22e>3</span>}
</span></span><span style=display:flex><span>		fmt.println(cross_2d(a, b))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		x <span style=color:#f92672>:=</span> [<span style=color:#a6e22e>3</span>]<span style=color:#66d9ef>f32</span>{<span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>4</span>, <span style=color:#a6e22e>9</span>}
</span></span><span style=display:flex><span>		y <span style=color:#f92672>:=</span> [<span style=color:#a6e22e>3</span>]<span style=color:#66d9ef>f32</span>{<span style=color:#f92672>-</span><span style=color:#a6e22e>5</span>, <span style=color:#a6e22e>0</span>, <span style=color:#a6e22e>3</span>}
</span></span><span style=display:flex><span>		fmt.println(cross_3d(x, y))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Failure case
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// i := [2]bool{true, false}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// j := [2]bool{false, true}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// fmt.println(cross_2d(i, j))
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	{ <span style=color:#75715e>// Procedure groups usage
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		foo <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(x<span style=color:#f92672>:</span> [<span style=color:#960050;background-color:#1e0010>$</span>N]<span style=color:#66d9ef>int</span>) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>where</span> N <span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>2</span> {
</span></span><span style=display:flex><span>			fmt.println(<span style=color:#a6e22e>#procedure</span>, <span style=color:#e6db74>&#34;was called with the parameter&#34;</span>, x)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		bar <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(x<span style=color:#f92672>:</span> [<span style=color:#960050;background-color:#1e0010>$</span>N]<span style=color:#66d9ef>int</span>) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>where</span> <span style=color:#a6e22e>0</span> <span style=color:#f92672>&lt;</span> N,
</span></span><span style=display:flex><span>				  N <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>2</span> {
</span></span><span style=display:flex><span>			fmt.println(<span style=color:#a6e22e>#procedure</span>, <span style=color:#e6db74>&#34;was called with the parameter&#34;</span>, x)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		baz <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>{foo, bar}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		x <span style=color:#f92672>:=</span> [<span style=color:#a6e22e>3</span>]<span style=color:#66d9ef>int</span>{<span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>2</span>, <span style=color:#a6e22e>3</span>}
</span></span><span style=display:flex><span>		y <span style=color:#f92672>:=</span> [<span style=color:#a6e22e>2</span>]<span style=color:#66d9ef>int</span>{<span style=color:#a6e22e>4</span>, <span style=color:#a6e22e>9</span>}
</span></span><span style=display:flex><span>		ok_x <span style=color:#f92672>:=</span> baz(x)
</span></span><span style=display:flex><span>		ok_y <span style=color:#f92672>:=</span> baz(y)
</span></span><span style=display:flex><span>		assert(ok_x <span style=color:#f92672>==</span> <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>		assert(ok_y <span style=color:#f92672>==</span> <span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	{ <span style=color:#75715e>// Record types
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		Foo <span style=color:#f92672>::</span> <span style=color:#66d9ef>struct</span>(<span style=color:#960050;background-color:#1e0010>$</span>T<span style=color:#f92672>:</span> <span style=color:#66d9ef>typeid</span>, <span style=color:#960050;background-color:#1e0010>$</span>N<span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>where</span> intrinsics.type_is_integer(T),
</span></span><span style=display:flex><span>				  N <span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>2</span> {
</span></span><span style=display:flex><span>			x<span style=color:#f92672>:</span> [N]T,
</span></span><span style=display:flex><span>			y<span style=color:#f92672>:</span> [N<span style=color:#f92672>-</span><span style=color:#a6e22e>2</span>]T,
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		T <span style=color:#f92672>::</span> <span style=color:#66d9ef>i32</span>
</span></span><span style=display:flex><span>		N <span style=color:#f92672>::</span> <span style=color:#a6e22e>5</span>
</span></span><span style=display:flex><span>		f<span style=color:#f92672>:</span> Foo(T, N)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>#assert</span>(size_of(f) <span style=color:#f92672>==</span> (N<span style=color:#f92672>+</span>N<span style=color:#f92672>-</span><span style=color:#a6e22e>2</span>)<span style=color:#f92672>*</span>size_of(T))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>when</span> ODIN_OS <span style=color:#f92672>==</span> .Windows {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>foreign</span> <span style=color:#f92672>import</span> kernel32 <span style=color:#e6db74>&#34;system:kernel32.lib&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>foreign_system <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() {
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;\n#foreign system&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>when</span> ODIN_OS <span style=color:#f92672>==</span> .Windows {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// It is sometimes necessarily to interface with foreign code,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// such as a C library. In Odin, this is achieved through the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// foreign system. You can “import” a library into the code
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// using the same semantics as a normal import declaration.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// This foreign import declaration will create a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// “foreign import name” which can then be used to associate
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// entities within a foreign block.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>foreign</span> kernel32 {
</span></span><span style=display:flex><span>			ExitProcess <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span> <span style=color:#e6db74>&#34;stdcall&#34;</span> (exit_code<span style=color:#f92672>:</span> <span style=color:#66d9ef>u32</span>) <span style=color:#f92672>---</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Foreign procedure declarations have the cdecl/c calling
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// convention by default unless specified otherwise. Due to
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// foreign procedures do not have a body declared within this
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// code, you need append the --- symbol to the end to distinguish
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// it as a procedure literal without a body and not a procedure type.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// The attributes system can be used to change specific properties
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// of entities declared within a block:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>@(default_calling_convention = &#34;std&#34;)</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>foreign</span> kernel32 {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>@(link_name=&#34;GetLastError&#34;) get_last_error :: proc()</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>i32</span> <span style=color:#f92672>---</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Example using the link_prefix attribute
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>@(default_calling_convention = &#34;std&#34;)</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>@(link_prefix = &#34;Get&#34;)</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>foreign</span> kernel32 {
</span></span><span style=display:flex><span>			LastError <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>i32</span> <span style=color:#f92672>---</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ranged_fields_for_array_compound_literals <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() {
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;\n#ranged fields for array compound literals&#34;</span>)
</span></span><span style=display:flex><span>	{ <span style=color:#75715e>// Normal Array Literal
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		foo <span style=color:#f92672>:=</span> [<span style=color:#960050;background-color:#1e0010>?</span>]<span style=color:#66d9ef>int</span>{<span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>4</span>, <span style=color:#a6e22e>9</span>, <span style=color:#a6e22e>16</span>}
</span></span><span style=display:flex><span>		fmt.println(foo)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	{ <span style=color:#75715e>// Indexed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		foo <span style=color:#f92672>:=</span> [<span style=color:#960050;background-color:#1e0010>?</span>]<span style=color:#66d9ef>int</span>{
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>3</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>16</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>1</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>4</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>2</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>9</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>0</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>1</span>,
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		fmt.println(foo)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	{ <span style=color:#75715e>// Ranges
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		i <span style=color:#f92672>:=</span> <span style=color:#a6e22e>2</span>
</span></span><span style=display:flex><span>		foo <span style=color:#f92672>:=</span> [<span style=color:#960050;background-color:#1e0010>?</span>]<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>0</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>123</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>5</span><span style=color:#f92672>..=</span><span style=color:#a6e22e>9</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>54</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>10</span><span style=color:#f92672>..&lt;</span><span style=color:#a6e22e>16</span> <span style=color:#f92672>=</span> i<span style=color:#f92672>*</span><span style=color:#a6e22e>3</span> <span style=color:#f92672>+</span> (i<span style=color:#f92672>-</span><span style=color:#a6e22e>1</span>)<span style=color:#f92672>*</span><span style=color:#a6e22e>2</span>,
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>#assert</span>(<span style=color:#66d9ef>len</span>(foo) <span style=color:#f92672>==</span> <span style=color:#a6e22e>16</span>)
</span></span><span style=display:flex><span>		fmt.println(foo) <span style=color:#75715e>// [123, 0, 0, 0, 0, 54, 54, 54, 54, 54, 8, 8, 8, 8, 8]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>	{ <span style=color:#75715e>// Slice and Dynamic Array support
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		i <span style=color:#f92672>:=</span> <span style=color:#a6e22e>2</span>
</span></span><span style=display:flex><span>		foo_slice <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>0</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>123</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>5</span><span style=color:#f92672>..=</span><span style=color:#a6e22e>9</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>54</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>10</span><span style=color:#f92672>..&lt;</span><span style=color:#a6e22e>16</span> <span style=color:#f92672>=</span> i<span style=color:#f92672>*</span><span style=color:#a6e22e>3</span> <span style=color:#f92672>+</span> (i<span style=color:#f92672>-</span><span style=color:#a6e22e>1</span>)<span style=color:#f92672>*</span><span style=color:#a6e22e>2</span>,
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		assert(<span style=color:#66d9ef>len</span>(foo_slice) <span style=color:#f92672>==</span> <span style=color:#a6e22e>16</span>)
</span></span><span style=display:flex><span>		fmt.println(foo_slice) <span style=color:#75715e>// [123, 0, 0, 0, 0, 54, 54, 54, 54, 54, 8, 8, 8, 8, 8]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		foo_dynamic_array <span style=color:#f92672>:=</span> [<span style=color:#66d9ef>dynamic</span>]<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>0</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>123</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>5</span><span style=color:#f92672>..=</span><span style=color:#a6e22e>9</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>54</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>10</span><span style=color:#f92672>..&lt;</span><span style=color:#a6e22e>16</span> <span style=color:#f92672>=</span> i<span style=color:#f92672>*</span><span style=color:#a6e22e>3</span> <span style=color:#f92672>+</span> (i<span style=color:#f92672>-</span><span style=color:#a6e22e>1</span>)<span style=color:#f92672>*</span><span style=color:#a6e22e>2</span>,
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		assert(<span style=color:#66d9ef>len</span>(foo_dynamic_array) <span style=color:#f92672>==</span> <span style=color:#a6e22e>16</span>)
</span></span><span style=display:flex><span>		fmt.println(foo_dynamic_array) <span style=color:#75715e>// [123, 0, 0, 0, 0, 54, 54, 54, 54, 54, 8, 8, 8, 8, 8]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>deprecated_attribute <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@(deprecated=&#34;Use foo_v2 instead&#34;)</span>
</span></span><span style=display:flex><span>	foo_v1 <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(x<span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#e6db74>&#34;foo_v1&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	foo_v2 <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(x<span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#e6db74>&#34;foo_v2&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// NOTE: Uncomment to see the warning messages
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// foo_v1(1)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>range_statements_with_multiple_return_values <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() {
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;\n#range statements with multiple return values&#34;</span>)
</span></span><span style=display:flex><span>	My_Iterator <span style=color:#f92672>::</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>		index<span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>,
</span></span><span style=display:flex><span>		data<span style=color:#f92672>:</span>  []<span style=color:#66d9ef>i32</span>,
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	make_my_iterator <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(data<span style=color:#f92672>:</span> []<span style=color:#66d9ef>i32</span>) <span style=color:#f92672>-&gt;</span> My_Iterator {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> My_Iterator{data <span style=color:#f92672>=</span> data}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	my_iterator <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(it<span style=color:#f92672>:</span> <span style=color:#f92672>^</span>My_Iterator) <span style=color:#f92672>-&gt;</span> (val<span style=color:#f92672>:</span> <span style=color:#66d9ef>i32</span>, idx<span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>, cond<span style=color:#f92672>:</span> <span style=color:#66d9ef>bool</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> cond <span style=color:#f92672>=</span> it.index <span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>len</span>(it.data); cond {
</span></span><span style=display:flex><span>			val <span style=color:#f92672>=</span> it.data[it.index]
</span></span><span style=display:flex><span>			idx <span style=color:#f92672>=</span> it.index
</span></span><span style=display:flex><span>			it.index <span style=color:#f92672>+=</span> <span style=color:#a6e22e>1</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	data <span style=color:#f92672>:=</span> <span style=color:#66d9ef>make</span>([]<span style=color:#66d9ef>i32</span>, <span style=color:#a6e22e>6</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> _, i <span style=color:#66d9ef>in</span> data {
</span></span><span style=display:flex><span>		data[i] <span style=color:#f92672>=</span> <span style=color:#66d9ef>i32</span>(i<span style=color:#f92672>*</span>i)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	{ <span style=color:#75715e>// Manual Style
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		it <span style=color:#f92672>:=</span> make_my_iterator(data)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>			val, _, cond <span style=color:#f92672>:=</span> my_iterator(<span style=color:#f92672>&amp;</span>it)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#960050;background-color:#1e0010>!</span>cond {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			fmt.println(val)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	{ <span style=color:#75715e>// or_break
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		it <span style=color:#f92672>:=</span> make_my_iterator(data)
</span></span><span style=display:flex><span>		loop<span style=color:#f92672>:</span> <span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>			val, _ <span style=color:#f92672>:=</span> my_iterator(<span style=color:#f92672>&amp;</span>it) or_break loop
</span></span><span style=display:flex><span>			fmt.println(val)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	{ <span style=color:#75715e>// first value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		it <span style=color:#f92672>:=</span> make_my_iterator(data)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> val <span style=color:#66d9ef>in</span> my_iterator(<span style=color:#f92672>&amp;</span>it) {
</span></span><span style=display:flex><span>			fmt.println(val)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	{ <span style=color:#75715e>// first and second value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		it <span style=color:#f92672>:=</span> make_my_iterator(data)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> val, idx <span style=color:#66d9ef>in</span> my_iterator(<span style=color:#f92672>&amp;</span>it) {
</span></span><span style=display:flex><span>			fmt.println(val, idx)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>soa_struct_layout <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() {
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;\n#SOA Struct Layout&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		Vector3 <span style=color:#f92672>::</span> <span style=color:#66d9ef>struct</span> {x, y, z<span style=color:#f92672>:</span> <span style=color:#66d9ef>f32</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		N <span style=color:#f92672>::</span> <span style=color:#a6e22e>2</span>
</span></span><span style=display:flex><span>		v_aos<span style=color:#f92672>:</span> [N]Vector3
</span></span><span style=display:flex><span>		v_aos[<span style=color:#a6e22e>0</span>].x <span style=color:#f92672>=</span> <span style=color:#a6e22e>1</span>
</span></span><span style=display:flex><span>		v_aos[<span style=color:#a6e22e>0</span>].y <span style=color:#f92672>=</span> <span style=color:#a6e22e>4</span>
</span></span><span style=display:flex><span>		v_aos[<span style=color:#a6e22e>0</span>].z <span style=color:#f92672>=</span> <span style=color:#a6e22e>9</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#66d9ef>len</span>(v_aos))
</span></span><span style=display:flex><span>		fmt.println(v_aos[<span style=color:#a6e22e>0</span>])
</span></span><span style=display:flex><span>		fmt.println(v_aos[<span style=color:#a6e22e>0</span>].x)
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#f92672>&amp;</span>v_aos[<span style=color:#a6e22e>0</span>].x)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		v_aos[<span style=color:#a6e22e>1</span>] <span style=color:#f92672>=</span> {<span style=color:#a6e22e>0</span>, <span style=color:#a6e22e>3</span>, <span style=color:#a6e22e>4</span>}
</span></span><span style=display:flex><span>		v_aos[<span style=color:#a6e22e>1</span>].x <span style=color:#f92672>=</span> <span style=color:#a6e22e>2</span>
</span></span><span style=display:flex><span>		fmt.println(v_aos[<span style=color:#a6e22e>1</span>])
</span></span><span style=display:flex><span>		fmt.println(v_aos)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		v_soa<span style=color:#f92672>:</span> <span style=color:#a6e22e>#soa</span>[N]Vector3
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		v_soa[<span style=color:#a6e22e>0</span>].x <span style=color:#f92672>=</span> <span style=color:#a6e22e>1</span>
</span></span><span style=display:flex><span>		v_soa[<span style=color:#a6e22e>0</span>].y <span style=color:#f92672>=</span> <span style=color:#a6e22e>4</span>
</span></span><span style=display:flex><span>		v_soa[<span style=color:#a6e22e>0</span>].z <span style=color:#f92672>=</span> <span style=color:#a6e22e>9</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Same syntax as AOS and treat as if it was an array
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		fmt.println(<span style=color:#66d9ef>len</span>(v_soa))
</span></span><span style=display:flex><span>		fmt.println(v_soa[<span style=color:#a6e22e>0</span>])
</span></span><span style=display:flex><span>		fmt.println(v_soa[<span style=color:#a6e22e>0</span>].x)
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#f92672>&amp;</span>v_soa[<span style=color:#a6e22e>0</span>].x)
</span></span><span style=display:flex><span>		v_soa[<span style=color:#a6e22e>1</span>] <span style=color:#f92672>=</span> {<span style=color:#a6e22e>0</span>, <span style=color:#a6e22e>3</span>, <span style=color:#a6e22e>4</span>}
</span></span><span style=display:flex><span>		v_soa[<span style=color:#a6e22e>1</span>].x <span style=color:#f92672>=</span> <span style=color:#a6e22e>2</span>
</span></span><span style=display:flex><span>		fmt.println(v_soa[<span style=color:#a6e22e>1</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Can use SOA syntax if necessary
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		v_soa.x[<span style=color:#a6e22e>0</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>1</span>
</span></span><span style=display:flex><span>		v_soa.y[<span style=color:#a6e22e>0</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>4</span>
</span></span><span style=display:flex><span>		v_soa.z[<span style=color:#a6e22e>0</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>9</span>
</span></span><span style=display:flex><span>		fmt.println(v_soa.x[<span style=color:#a6e22e>0</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Same pointer addresses with both syntaxes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		assert(<span style=color:#f92672>&amp;</span>v_soa[<span style=color:#a6e22e>0</span>].x <span style=color:#f92672>==</span> <span style=color:#f92672>&amp;</span>v_soa.x[<span style=color:#a6e22e>0</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Same fmt printing
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		fmt.println(v_aos)
</span></span><span style=display:flex><span>		fmt.println(v_soa)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Works with arrays of length &lt;= 4 which have the implicit fields xyzw/rgba
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		Vector3 <span style=color:#f92672>::</span> <span style=color:#66d9ef>distinct</span> [<span style=color:#a6e22e>3</span>]<span style=color:#66d9ef>f32</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		N <span style=color:#f92672>::</span> <span style=color:#a6e22e>2</span>
</span></span><span style=display:flex><span>		v_aos<span style=color:#f92672>:</span> [N]Vector3
</span></span><span style=display:flex><span>		v_aos[<span style=color:#a6e22e>0</span>].x <span style=color:#f92672>=</span> <span style=color:#a6e22e>1</span>
</span></span><span style=display:flex><span>		v_aos[<span style=color:#a6e22e>0</span>].y <span style=color:#f92672>=</span> <span style=color:#a6e22e>4</span>
</span></span><span style=display:flex><span>		v_aos[<span style=color:#a6e22e>0</span>].z <span style=color:#f92672>=</span> <span style=color:#a6e22e>9</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		v_soa<span style=color:#f92672>:</span> <span style=color:#a6e22e>#soa</span>[N]Vector3
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		v_soa[<span style=color:#a6e22e>0</span>].x <span style=color:#f92672>=</span> <span style=color:#a6e22e>1</span>
</span></span><span style=display:flex><span>		v_soa[<span style=color:#a6e22e>0</span>].y <span style=color:#f92672>=</span> <span style=color:#a6e22e>4</span>
</span></span><span style=display:flex><span>		v_soa[<span style=color:#a6e22e>0</span>].z <span style=color:#f92672>=</span> <span style=color:#a6e22e>9</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#75715e>// SOA Slices
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// Vector3 :: struct {x, y, z: f32}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		Vector3 <span style=color:#f92672>::</span> <span style=color:#66d9ef>struct</span> {x<span style=color:#f92672>:</span> <span style=color:#66d9ef>i8</span>, y<span style=color:#f92672>:</span> <span style=color:#66d9ef>i16</span>, z<span style=color:#f92672>:</span> <span style=color:#66d9ef>f32</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		N <span style=color:#f92672>::</span> <span style=color:#a6e22e>3</span>
</span></span><span style=display:flex><span>		v<span style=color:#f92672>:</span> <span style=color:#a6e22e>#soa</span>[N]Vector3
</span></span><span style=display:flex><span>		v[<span style=color:#a6e22e>0</span>].x <span style=color:#f92672>=</span> <span style=color:#a6e22e>1</span>
</span></span><span style=display:flex><span>		v[<span style=color:#a6e22e>0</span>].y <span style=color:#f92672>=</span> <span style=color:#a6e22e>4</span>
</span></span><span style=display:flex><span>		v[<span style=color:#a6e22e>0</span>].z <span style=color:#f92672>=</span> <span style=color:#a6e22e>9</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		s<span style=color:#f92672>:</span> <span style=color:#a6e22e>#soa</span>[]Vector3
</span></span><span style=display:flex><span>		s <span style=color:#f92672>=</span> v[<span style=color:#f92672>:</span>]
</span></span><span style=display:flex><span>		assert(<span style=color:#66d9ef>len</span>(s) <span style=color:#f92672>==</span> N)
</span></span><span style=display:flex><span>		fmt.println(s)
</span></span><span style=display:flex><span>		fmt.println(s[<span style=color:#a6e22e>0</span>].x)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		a <span style=color:#f92672>:=</span> s[<span style=color:#a6e22e>1</span><span style=color:#f92672>:</span><span style=color:#a6e22e>2</span>]
</span></span><span style=display:flex><span>		assert(<span style=color:#66d9ef>len</span>(a) <span style=color:#f92672>==</span> <span style=color:#a6e22e>1</span>)
</span></span><span style=display:flex><span>		fmt.println(a)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		d<span style=color:#f92672>:</span> <span style=color:#a6e22e>#soa</span>[<span style=color:#66d9ef>dynamic</span>]Vector3
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		append_soa(<span style=color:#f92672>&amp;</span>d, Vector3{<span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>2</span>, <span style=color:#a6e22e>3</span>}, Vector3{<span style=color:#a6e22e>4</span>, <span style=color:#a6e22e>5</span>, <span style=color:#a6e22e>9</span>}, Vector3{<span style=color:#f92672>-</span><span style=color:#a6e22e>4</span>, <span style=color:#f92672>-</span><span style=color:#a6e22e>4</span>, <span style=color:#a6e22e>3</span>})
</span></span><span style=display:flex><span>		fmt.println(d)
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#66d9ef>len</span>(d))
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#66d9ef>cap</span>(d))
</span></span><span style=display:flex><span>		fmt.println(d[<span style=color:#f92672>:</span>])
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	{ <span style=color:#75715e>// soa_zip and soa_unzip
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		fmt.println(<span style=color:#e6db74>&#34;\nsoa_zip and soa_unzip&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		x <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>i32</span>{<span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>3</span>, <span style=color:#a6e22e>9</span>}
</span></span><span style=display:flex><span>		y <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>f32</span>{<span style=color:#a6e22e>2</span>, <span style=color:#a6e22e>4</span>, <span style=color:#a6e22e>16</span>}
</span></span><span style=display:flex><span>		z <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>b32</span>{<span style=color:#66d9ef>true</span>, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>true</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// produce an #soa slice the normal slices passed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		s <span style=color:#f92672>:=</span> soa_zip(a<span style=color:#f92672>=</span>x, b<span style=color:#f92672>=</span>y, c<span style=color:#f92672>=</span>z)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// iterate over the #soa slice
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>for</span> v, i <span style=color:#66d9ef>in</span> s {
</span></span><span style=display:flex><span>			fmt.println(v, i) <span style=color:#75715e>// exactly the same as s[i]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// NOTE: &#39;v&#39; is NOT a temporary value but has a specialized addressing mode
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// which means that when accessing v.a etc, it does the correct transformation
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// internally:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>//         s[i].a === s.a[i]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			fmt.println(v.a, v.b, v.c)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Recover the slices from the #soa slice
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		a, b, c <span style=color:#f92672>:=</span> soa_unzip(s)
</span></span><span style=display:flex><span>		fmt.println(a, b, c)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>constant_literal_expressions <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() {
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;\n#constant literal expressions&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	Bar <span style=color:#f92672>::</span> <span style=color:#66d9ef>struct</span> {x, y<span style=color:#f92672>:</span> <span style=color:#66d9ef>f32</span>}
</span></span><span style=display:flex><span>	Foo <span style=color:#f92672>::</span> <span style=color:#66d9ef>struct</span> {a, b<span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>using</span> c<span style=color:#f92672>:</span> Bar}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	FOO_CONST <span style=color:#f92672>::</span> Foo{b <span style=color:#f92672>=</span> <span style=color:#a6e22e>2</span>, a <span style=color:#f92672>=</span> <span style=color:#a6e22e>1</span>, c <span style=color:#f92672>=</span> {<span style=color:#a6e22e>3</span>, <span style=color:#a6e22e>4</span>}}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	fmt.println(FOO_CONST.a)
</span></span><span style=display:flex><span>	fmt.println(FOO_CONST.b)
</span></span><span style=display:flex><span>	fmt.println(FOO_CONST.c)
</span></span><span style=display:flex><span>	fmt.println(FOO_CONST.c.x)
</span></span><span style=display:flex><span>	fmt.println(FOO_CONST.c.y)
</span></span><span style=display:flex><span>	fmt.println(FOO_CONST.x) <span style=color:#75715e>// using works as expected
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	fmt.println(FOO_CONST.y)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;-------&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	ARRAY_CONST <span style=color:#f92672>::</span> [<span style=color:#a6e22e>3</span>]<span style=color:#66d9ef>int</span>{<span style=color:#a6e22e>1</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>4</span>, <span style=color:#a6e22e>2</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>9</span>, <span style=color:#a6e22e>0</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>1</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	fmt.println(ARRAY_CONST[<span style=color:#a6e22e>0</span>])
</span></span><span style=display:flex><span>	fmt.println(ARRAY_CONST[<span style=color:#a6e22e>1</span>])
</span></span><span style=display:flex><span>	fmt.println(ARRAY_CONST[<span style=color:#a6e22e>2</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;-------&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	FOO_ARRAY_DEFAULTS <span style=color:#f92672>::</span> [<span style=color:#a6e22e>3</span>]Foo{{}, {}, {}}
</span></span><span style=display:flex><span>	fmt.println(FOO_ARRAY_DEFAULTS[<span style=color:#a6e22e>2</span>].x)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;-------&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	Baz <span style=color:#f92672>::</span> <span style=color:#66d9ef>enum</span>{A<span style=color:#f92672>=</span><span style=color:#a6e22e>5</span>, B, C, D}
</span></span><span style=display:flex><span>	ENUM_ARRAY_CONST <span style=color:#f92672>::</span> [Baz]<span style=color:#66d9ef>int</span>{.A <span style=color:#f92672>..=</span> .C <span style=color:#f92672>=</span> <span style=color:#a6e22e>1</span>, .D <span style=color:#f92672>=</span> <span style=color:#a6e22e>16</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	fmt.println(ENUM_ARRAY_CONST[.A])
</span></span><span style=display:flex><span>	fmt.println(ENUM_ARRAY_CONST[.B])
</span></span><span style=display:flex><span>	fmt.println(ENUM_ARRAY_CONST[.C])
</span></span><span style=display:flex><span>	fmt.println(ENUM_ARRAY_CONST[.D])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;-------&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	Sparse_Baz <span style=color:#f92672>::</span> <span style=color:#66d9ef>enum</span>{A<span style=color:#f92672>=</span><span style=color:#a6e22e>5</span>, B, C, D<span style=color:#f92672>=</span><span style=color:#a6e22e>16</span>}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>#assert</span>(<span style=color:#66d9ef>len</span>(Sparse_Baz) <span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>len</span>(<span style=color:#a6e22e>#sparse</span>[Sparse_Baz]<span style=color:#66d9ef>int</span>))
</span></span><span style=display:flex><span>	SPARSE_ENUM_ARRAY_CONST <span style=color:#f92672>::</span> <span style=color:#a6e22e>#sparse</span>[Sparse_Baz]<span style=color:#66d9ef>int</span>{.A <span style=color:#f92672>..=</span> .C <span style=color:#f92672>=</span> <span style=color:#a6e22e>1</span>, .D <span style=color:#f92672>=</span> <span style=color:#a6e22e>16</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	fmt.println(SPARSE_ENUM_ARRAY_CONST[.A])
</span></span><span style=display:flex><span>	fmt.println(SPARSE_ENUM_ARRAY_CONST[.B])
</span></span><span style=display:flex><span>	fmt.println(SPARSE_ENUM_ARRAY_CONST[.C])
</span></span><span style=display:flex><span>	fmt.println(SPARSE_ENUM_ARRAY_CONST[.D])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;-------&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	STRING_CONST <span style=color:#f92672>::</span> <span style=color:#e6db74>&#34;Hellope!&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	fmt.println(STRING_CONST[<span style=color:#a6e22e>0</span>])
</span></span><span style=display:flex><span>	fmt.println(STRING_CONST[<span style=color:#a6e22e>2</span>])
</span></span><span style=display:flex><span>	fmt.println(STRING_CONST[<span style=color:#a6e22e>3</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	fmt.println(STRING_CONST[<span style=color:#a6e22e>0</span><span style=color:#f92672>:</span><span style=color:#a6e22e>5</span>])
</span></span><span style=display:flex><span>	fmt.println(STRING_CONST[<span style=color:#a6e22e>3</span><span style=color:#f92672>:</span>][<span style=color:#f92672>:</span><span style=color:#a6e22e>4</span>])
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>union_maybe <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() {
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;\n#union based maybe&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// NOTE: This is already built-in, and this is just a reimplementation to explain the behaviour
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	Maybe <span style=color:#f92672>::</span> <span style=color:#66d9ef>union</span>(<span style=color:#960050;background-color:#1e0010>$</span>T<span style=color:#f92672>:</span> <span style=color:#66d9ef>typeid</span>) {T}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	i<span style=color:#f92672>:</span> Maybe(<span style=color:#66d9ef>u8</span>)
</span></span><span style=display:flex><span>	p<span style=color:#f92672>:</span> Maybe(<span style=color:#f92672>^</span><span style=color:#66d9ef>u8</span>) <span style=color:#75715e>// No tag is stored for pointers, nil is the sentinel value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Tag size will be as small as needed for the number of variants
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>#assert</span>(size_of(i) <span style=color:#f92672>==</span> size_of(<span style=color:#66d9ef>u8</span>) <span style=color:#f92672>+</span> size_of(<span style=color:#66d9ef>u8</span>))
</span></span><span style=display:flex><span>	<span style=color:#75715e>// No need to store a tag here, the `nil` state is shared with the variant&#39;s `nil`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>#assert</span>(size_of(p) <span style=color:#f92672>==</span> size_of(<span style=color:#f92672>^</span><span style=color:#66d9ef>u8</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	i <span style=color:#f92672>=</span> <span style=color:#a6e22e>123</span>
</span></span><span style=display:flex><span>	x <span style=color:#f92672>:=</span> i.<span style=color:#960050;background-color:#1e0010>?</span>
</span></span><span style=display:flex><span>	y, y_ok <span style=color:#f92672>:=</span> p.<span style=color:#960050;background-color:#1e0010>?</span>
</span></span><span style=display:flex><span>	p <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>x
</span></span><span style=display:flex><span>	z, z_ok <span style=color:#f92672>:=</span> p.<span style=color:#960050;background-color:#1e0010>?</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	fmt.println(i, p)
</span></span><span style=display:flex><span>	fmt.println(x, <span style=color:#f92672>&amp;</span>x)
</span></span><span style=display:flex><span>	fmt.println(y, y_ok)
</span></span><span style=display:flex><span>	fmt.println(z, z_ok)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>dummy_procedure <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() {
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;dummy_procedure&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>explicit_context_definition <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span> <span style=color:#e6db74>&#34;c&#34;</span> () {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Try commenting the following statement out below
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>context</span> <span style=color:#f92672>=</span> runtime.default_context()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;\n#explicit context definition&#34;</span>)
</span></span><span style=display:flex><span>	dummy_procedure()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>or_else_operator <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() {
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;\n#&#39;or_else&#39;&#34;</span>)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		m<span style=color:#f92672>:</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>		i<span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>		ok<span style=color:#f92672>:</span> <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> i, ok <span style=color:#f92672>=</span> m[<span style=color:#e6db74>&#34;hellope&#34;</span>]; <span style=color:#960050;background-color:#1e0010>!</span>ok {
</span></span><span style=display:flex><span>			i <span style=color:#f92672>=</span> <span style=color:#a6e22e>123</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#75715e>// The above can be mapped to &#39;or_else&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		i <span style=color:#f92672>=</span> m[<span style=color:#e6db74>&#34;hellope&#34;</span>] <span style=color:#66d9ef>or_else</span> <span style=color:#a6e22e>123</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		assert(i <span style=color:#f92672>==</span> <span style=color:#a6e22e>123</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#75715e>// &#39;or_else&#39; can be used with type assertions too, as they
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// have optional ok semantics
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		v<span style=color:#f92672>:</span> <span style=color:#66d9ef>union</span>{<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>f64</span>}
</span></span><span style=display:flex><span>		i<span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>		i <span style=color:#f92672>=</span> v.(<span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>or_else</span> <span style=color:#a6e22e>123</span>
</span></span><span style=display:flex><span>		i <span style=color:#f92672>=</span> v.<span style=color:#960050;background-color:#1e0010>?</span> <span style=color:#66d9ef>or_else</span> <span style=color:#a6e22e>123</span> <span style=color:#75715e>// Type inference magic
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		assert(i <span style=color:#f92672>==</span> <span style=color:#a6e22e>123</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		m<span style=color:#f92672>:</span> Maybe(<span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>		i <span style=color:#f92672>=</span> m.<span style=color:#960050;background-color:#1e0010>?</span> <span style=color:#66d9ef>or_else</span> <span style=color:#a6e22e>456</span>
</span></span><span style=display:flex><span>		assert(i <span style=color:#f92672>==</span> <span style=color:#a6e22e>456</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>or_return_operator <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() {
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;\n#&#39;or_return&#39;&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#75715e>// The concept of &#39;or_return&#39; will work by popping off the end value in a multiple
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// valued expression and checking whether it was not &#39;nil&#39; or &#39;false&#39;, and if so,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// set the end return value to value if possible. If the procedure only has one
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// return value, it will do a simple return. If the procedure had multiple return
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// values, &#39;or_return&#39; will require that all parameters be named so that the end
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// value could be assigned to by name and then an empty return could be called.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	Error <span style=color:#f92672>::</span> <span style=color:#66d9ef>enum</span> {
</span></span><span style=display:flex><span>		None,
</span></span><span style=display:flex><span>		Something_Bad,
</span></span><span style=display:flex><span>		Something_Worse,
</span></span><span style=display:flex><span>		The_Worst,
</span></span><span style=display:flex><span>		Your_Mum,
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	caller_1 <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() <span style=color:#f92672>-&gt;</span> Error {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> .None
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	caller_2 <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() <span style=color:#f92672>-&gt;</span> (<span style=color:#66d9ef>int</span>, Error) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>123</span>, .None
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	caller_3 <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() <span style=color:#f92672>-&gt;</span> (<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>, Error) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>123</span>, <span style=color:#a6e22e>345</span>, .None
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	foo_1 <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() <span style=color:#f92672>-&gt;</span> Error {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// This can be a common idiom in many code bases
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		n0, err <span style=color:#f92672>:=</span> caller_2()
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> err <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> err
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// The above idiom can be transformed into the following
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		n1 <span style=color:#f92672>:=</span> caller_2() <span style=color:#66d9ef>or_return</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// And if the expression is 1-valued, it can be used like this
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		caller_1() <span style=color:#66d9ef>or_return</span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// which is functionally equivalent to
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> err1 <span style=color:#f92672>:=</span> caller_1(); err1 <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> err1
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Multiple return values still work with &#39;or_return&#39; as it only
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// pops off the end value in the multi-valued expression
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		n0, n1 <span style=color:#f92672>=</span> caller_3() <span style=color:#66d9ef>or_return</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> .None
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	foo_2 <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() <span style=color:#f92672>-&gt;</span> (n<span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>, err<span style=color:#f92672>:</span> Error) {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// It is more common that your procedure returns multiple values
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// If &#39;or_return&#39; is used within a procedure multiple parameters (2+),
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// then all the parameters must be named so that the remaining parameters
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// so that a bare &#39;return&#39; statement can be used
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// This can be a common idiom in many code bases
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		x<span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>		x, err <span style=color:#f92672>=</span> caller_2()
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> err <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// The above idiom can be transformed into the following
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		y <span style=color:#f92672>:=</span> caller_2() <span style=color:#66d9ef>or_return</span>
</span></span><span style=display:flex><span>		_ <span style=color:#f92672>=</span> y
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// And if the expression is 1-valued, it can be used like this
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		caller_1() <span style=color:#66d9ef>or_return</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// which is functionally equivalent to
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> err1 <span style=color:#f92672>:=</span> caller_1(); err1 <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			err <span style=color:#f92672>=</span> err1
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// If using a non-bare &#39;return&#39; statement is required, setting the return values
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// using the normal idiom is a better choice and clearer to read.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> z, zerr <span style=color:#f92672>:=</span> caller_2(); zerr <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#a6e22e>345</span> <span style=color:#f92672>*</span> z, zerr
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>if</span> err <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			fmt.println(<span style=color:#e6db74>&#34;Error in&#34;</span>, <span style=color:#a6e22e>#procedure</span>, <span style=color:#e6db74>&#34;:&#34;</span> , err)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		n <span style=color:#f92672>=</span> <span style=color:#a6e22e>123</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	foo_1()
</span></span><span style=display:flex><span>	foo_2()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>or_break_and_or_continue_operators <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() {
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;\n#&#39;or_break&#39; and &#39;or_continue&#39;&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#75715e>// The concept of &#39;or_break&#39; and &#39;or_continue&#39; is very similar to that of &#39;or_return&#39;.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// The difference is that unlike &#39;or_return&#39;, the value does not get returned from
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// the current procedure but rather discarded if it is &#39;false&#39; or not &#39;nil&#39;, and then
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// the specified branch (i.e. break or continue).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// The or branch expression can be labelled if a specific statement needs to be used.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	Error <span style=color:#f92672>::</span> <span style=color:#66d9ef>enum</span> {
</span></span><span style=display:flex><span>		None,
</span></span><span style=display:flex><span>		Something_Bad,
</span></span><span style=display:flex><span>		Something_Worse,
</span></span><span style=display:flex><span>		The_Worst,
</span></span><span style=display:flex><span>		Your_Mum,
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	caller_1 <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() <span style=color:#f92672>-&gt;</span> Error {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> .Something_Bad
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	caller_2 <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() <span style=color:#f92672>-&gt;</span> (<span style=color:#66d9ef>int</span>, Error) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>123</span>, .Something_Worse
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	caller_3 <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() <span style=color:#f92672>-&gt;</span> (<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>, Error) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>123</span>, <span style=color:#a6e22e>345</span>, .None
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> { <span style=color:#75715e>// common approach
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		err <span style=color:#f92672>:=</span> caller_1()
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> err <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> { <span style=color:#75715e>// or_break approach
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		caller_1() or_break
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> { <span style=color:#75715e>// or_break approach with multiple values
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		n <span style=color:#f92672>:=</span> caller_2() or_break
</span></span><span style=display:flex><span>		_ <span style=color:#f92672>=</span> n
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	loop<span style=color:#f92672>:</span> <span style=color:#66d9ef>for</span> { <span style=color:#75715e>// or_break approach with named label
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		n <span style=color:#f92672>:=</span> caller_2() or_break loop
</span></span><span style=display:flex><span>		_ <span style=color:#f92672>=</span> n
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> { <span style=color:#75715e>// or_continue
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		x, y <span style=color:#f92672>:=</span> caller_3() or_continue
</span></span><span style=display:flex><span>		_, _ <span style=color:#f92672>=</span> x, y
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	continue_loop<span style=color:#f92672>:</span> <span style=color:#66d9ef>for</span> { <span style=color:#75715e>// or_continue with named label
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		x, y <span style=color:#f92672>:=</span> caller_3() or_continue continue_loop
</span></span><span style=display:flex><span>		_, _ <span style=color:#f92672>=</span> x, y
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>arbitrary_precision_mathematics <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() {
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;\n# core:math/big&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	print_bigint <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>(name<span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span>, a<span style=color:#f92672>:</span> <span style=color:#f92672>^</span>big.Int, base <span style=color:#f92672>:=</span> <span style=color:#66d9ef>i8</span>(<span style=color:#a6e22e>10</span>), print_name <span style=color:#f92672>:=</span> <span style=color:#66d9ef>true</span>, newline <span style=color:#f92672>:=</span> <span style=color:#66d9ef>true</span>, print_extra_info <span style=color:#f92672>:=</span> <span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>		big.assert_if_nil(a)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		as, err <span style=color:#f92672>:=</span> big.itoa(a, base)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>delete</span>(as)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		cb <span style=color:#f92672>:=</span> big.internal_count_bits(a)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> print_name {
</span></span><span style=display:flex><span>			fmt.printf(name)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> err <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			fmt.printf(<span style=color:#e6db74>&#34; (Error: %v) &#34;</span>, err)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		fmt.printf(as)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> print_extra_info {
</span></span><span style=display:flex><span>			fmt.printf(<span style=color:#e6db74>&#34; (base: %v, bits: %v, digits: %v)&#34;</span>, base, cb, a.used)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> newline {
</span></span><span style=display:flex><span>			fmt.println()
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	a, b, c, d, e, f, res <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span>big.Int{}, <span style=color:#f92672>&amp;</span>big.Int{}, <span style=color:#f92672>&amp;</span>big.Int{}, <span style=color:#f92672>&amp;</span>big.Int{}, <span style=color:#f92672>&amp;</span>big.Int{}, <span style=color:#f92672>&amp;</span>big.Int{}, <span style=color:#f92672>&amp;</span>big.Int{}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> big.destroy(a, b, c, d, e, f, res)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// How many bits should the random prime be?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	bits   <span style=color:#f92672>:=</span> <span style=color:#a6e22e>64</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Number of Rabin-Miller trials, -1 for automatic.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	trials <span style=color:#f92672>:=</span> <span style=color:#f92672>-</span><span style=color:#a6e22e>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Default prime generation flags
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	flags <span style=color:#f92672>:=</span> big.Primality_Flags{}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	err <span style=color:#f92672>:=</span> big.internal_random_prime(a, bits, trials, flags)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> err <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		fmt.printf(<span style=color:#e6db74>&#34;Error %v while generating random prime.\n&#34;</span>, err)
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		print_bigint(<span style=color:#e6db74>&#34;Random Prime A: &#34;</span>, a, <span style=color:#a6e22e>10</span>)
</span></span><span style=display:flex><span>		fmt.printf(<span style=color:#e6db74>&#34;Random number iterations until prime found: %v\n&#34;</span>, big.RANDOM_PRIME_ITERATIONS_USED)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// If we want to pack this Int into a buffer of u32, how many do we need?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	count <span style=color:#f92672>:=</span> big.internal_int_pack_count(a, <span style=color:#66d9ef>u32</span>)
</span></span><span style=display:flex><span>	buf <span style=color:#f92672>:=</span> <span style=color:#66d9ef>make</span>([]<span style=color:#66d9ef>u32</span>, count)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>delete</span>(buf)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	written<span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>	written, err <span style=color:#f92672>=</span> big.internal_int_pack(a, buf)
</span></span><span style=display:flex><span>	fmt.printf(<span style=color:#e6db74>&#34;\nPacked into u32 buf: %v | err: %v | written: %v\n&#34;</span>, buf, err, written)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// If we want to pack this Int into a buffer of bytes of which only the bottom 6 bits are used, how many do we need?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	nails <span style=color:#f92672>:=</span> <span style=color:#a6e22e>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	count <span style=color:#f92672>=</span> big.internal_int_pack_count(a, <span style=color:#66d9ef>u8</span>, nails)
</span></span><span style=display:flex><span>	byte_buf <span style=color:#f92672>:=</span> <span style=color:#66d9ef>make</span>([]<span style=color:#66d9ef>u8</span>, count)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>delete</span>(byte_buf)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	written, err <span style=color:#f92672>=</span> big.internal_int_pack(a, byte_buf, nails)
</span></span><span style=display:flex><span>	fmt.printf(<span style=color:#e6db74>&#34;\nPacked into buf of 6-bit bytes: %v | err: %v | written: %v\n&#34;</span>, byte_buf, err, written)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Pick another random big Int, not necesssarily prime.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	err <span style=color:#f92672>=</span> big.random(b, <span style=color:#a6e22e>2048</span>)
</span></span><span style=display:flex><span>	print_bigint(<span style=color:#e6db74>&#34;\n2048 bit random number: &#34;</span>, b)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Calculate GCD + LCM in one fell swoop
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	big.gcd_lcm(c, d, a, b)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	print_bigint(<span style=color:#e6db74>&#34;\nGCD of random prime A and random number B: &#34;</span>, c)
</span></span><span style=display:flex><span>	print_bigint(<span style=color:#e6db74>&#34;\nLCM of random prime A and random number B (in base 36): &#34;</span>, d, <span style=color:#a6e22e>36</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>matrix_type <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() {
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;\n# matrix type&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#75715e>// A matrix is a mathematical type built into Odin. It is a regular array of numbers,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// arranged in rows and columns
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#75715e>// The following represents a matrix that has 2 rows and 3 columns
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		m<span style=color:#f92672>:</span> matrix[<span style=color:#a6e22e>2</span>, <span style=color:#a6e22e>3</span>]<span style=color:#66d9ef>f32</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		m <span style=color:#f92672>=</span> matrix[<span style=color:#a6e22e>2</span>, <span style=color:#a6e22e>3</span>]<span style=color:#66d9ef>f32</span>{
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>9</span>, <span style=color:#f92672>-</span><span style=color:#a6e22e>13</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>20</span>, <span style=color:#a6e22e>5</span>, <span style=color:#f92672>-</span><span style=color:#a6e22e>6</span>,
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Element types of integers, float, and complex numbers are supported by matrices.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// There is no support for booleans, quaternions, or any compound type.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Indexing a matrix can be used with the matrix indexing syntax
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// This mirrors other type usages: type on the left, usage on the right
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		elem <span style=color:#f92672>:=</span> m[<span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>2</span>] <span style=color:#75715e>// row 1, column 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		assert(elem <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#a6e22e>6</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Scalars act as if they are scaled identity matrices
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// and can be assigned to matrices as them
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		b <span style=color:#f92672>:=</span> matrix[<span style=color:#a6e22e>2</span>, <span style=color:#a6e22e>2</span>]<span style=color:#66d9ef>f32</span>{}
</span></span><span style=display:flex><span>		f <span style=color:#f92672>:=</span> <span style=color:#66d9ef>f32</span>(<span style=color:#a6e22e>3</span>)
</span></span><span style=display:flex><span>		b <span style=color:#f92672>=</span> f
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#e6db74>&#34;b&#34;</span>, b)
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#e6db74>&#34;b == f&#34;</span>, b <span style=color:#f92672>==</span> f)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	{ <span style=color:#75715e>// Matrices support multiplication between matrices
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		a <span style=color:#f92672>:=</span> matrix[<span style=color:#a6e22e>2</span>, <span style=color:#a6e22e>3</span>]<span style=color:#66d9ef>f32</span>{
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>2</span>, <span style=color:#a6e22e>3</span>, <span style=color:#a6e22e>1</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>4</span>, <span style=color:#a6e22e>5</span>, <span style=color:#a6e22e>0</span>,
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		b <span style=color:#f92672>:=</span> matrix[<span style=color:#a6e22e>3</span>, <span style=color:#a6e22e>2</span>]<span style=color:#66d9ef>f32</span>{
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>2</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>3</span>, <span style=color:#a6e22e>4</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>5</span>, <span style=color:#a6e22e>6</span>,
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#e6db74>&#34;a&#34;</span>, a)
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#e6db74>&#34;b&#34;</span>, b)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		c <span style=color:#f92672>:=</span> a <span style=color:#f92672>*</span> b
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>#assert</span>(type_of(c) <span style=color:#f92672>==</span> matrix[<span style=color:#a6e22e>2</span>, <span style=color:#a6e22e>2</span>]<span style=color:#66d9ef>f32</span>)
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#e6db74>&#34;c = a * b&#34;</span>, c)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	{ <span style=color:#75715e>// Matrices support multiplication between matrices and arrays
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		m <span style=color:#f92672>:=</span> matrix[<span style=color:#a6e22e>4</span>, <span style=color:#a6e22e>4</span>]<span style=color:#66d9ef>f32</span>{
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>2</span>, <span style=color:#a6e22e>3</span>, <span style=color:#a6e22e>4</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>5</span>, <span style=color:#a6e22e>5</span>, <span style=color:#a6e22e>4</span>, <span style=color:#a6e22e>2</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>0</span>, <span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>3</span>, <span style=color:#a6e22e>0</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>0</span>, <span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>4</span>, <span style=color:#a6e22e>1</span>,
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		v <span style=color:#f92672>:=</span> [<span style=color:#a6e22e>4</span>]<span style=color:#66d9ef>f32</span>{<span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>5</span>, <span style=color:#a6e22e>4</span>, <span style=color:#a6e22e>3</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// treating &#39;v&#39; as a column vector
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		fmt.println(<span style=color:#e6db74>&#34;m * v&#34;</span>, m <span style=color:#f92672>*</span> v)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// treating &#39;v&#39; as a row vector
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		fmt.println(<span style=color:#e6db74>&#34;v * m&#34;</span>, v <span style=color:#f92672>*</span> m)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Support with non-square matrices
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		s <span style=color:#f92672>:=</span> matrix[<span style=color:#a6e22e>2</span>, <span style=color:#a6e22e>4</span>]<span style=color:#66d9ef>f32</span>{ <span style=color:#75715e>// [4][2]f32
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>2</span>, <span style=color:#a6e22e>4</span>, <span style=color:#a6e22e>3</span>, <span style=color:#a6e22e>1</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>7</span>, <span style=color:#a6e22e>8</span>, <span style=color:#a6e22e>6</span>, <span style=color:#a6e22e>5</span>,
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		w <span style=color:#f92672>:=</span> [<span style=color:#a6e22e>2</span>]<span style=color:#66d9ef>f32</span>{<span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>2</span>}
</span></span><span style=display:flex><span>		r<span style=color:#f92672>:</span> [<span style=color:#a6e22e>4</span>]<span style=color:#66d9ef>f32</span> <span style=color:#f92672>=</span> w <span style=color:#f92672>*</span> s
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#e6db74>&#34;r&#34;</span>, r)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	{ <span style=color:#75715e>// Component-wise operations
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// if the element type supports it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// Not support for &#39;/&#39;, &#39;%&#39;, or &#39;%%&#39; operations
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		a <span style=color:#f92672>:=</span> matrix[<span style=color:#a6e22e>2</span>, <span style=color:#a6e22e>2</span>]<span style=color:#66d9ef>i32</span>{
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>2</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>3</span>, <span style=color:#a6e22e>4</span>,
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		b <span style=color:#f92672>:=</span> matrix[<span style=color:#a6e22e>2</span>, <span style=color:#a6e22e>2</span>]<span style=color:#66d9ef>i32</span>{
</span></span><span style=display:flex><span>			<span style=color:#f92672>-</span><span style=color:#a6e22e>5</span>,  <span style=color:#a6e22e>1</span>,
</span></span><span style=display:flex><span>			 <span style=color:#a6e22e>9</span>, <span style=color:#f92672>-</span><span style=color:#a6e22e>7</span>,
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		c0 <span style=color:#f92672>:=</span> a <span style=color:#f92672>+</span> b
</span></span><span style=display:flex><span>		c1 <span style=color:#f92672>:=</span> a <span style=color:#f92672>-</span> b
</span></span><span style=display:flex><span>		c2 <span style=color:#f92672>:=</span> a <span style=color:#f92672>&amp;</span> b
</span></span><span style=display:flex><span>		c3 <span style=color:#f92672>:=</span> a <span style=color:#f92672>|</span> b
</span></span><span style=display:flex><span>		c4 <span style=color:#f92672>:=</span> a <span style=color:#960050;background-color:#1e0010>~</span> b
</span></span><span style=display:flex><span>		c5 <span style=color:#f92672>:=</span> a <span style=color:#f92672>&amp;</span><span style=color:#960050;background-color:#1e0010>~</span> b
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// component-wise multiplication
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// since a * b would be a standard matrix multiplication
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		c6 <span style=color:#f92672>:=</span> intrinsics.hadamard_product(a, b)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#e6db74>&#34;a + b&#34;</span>,  c0)
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#e6db74>&#34;a - b&#34;</span>,  c1)
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#e6db74>&#34;a &amp; b&#34;</span>,  c2)
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#e6db74>&#34;a | b&#34;</span>,  c3)
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#e6db74>&#34;a ~ b&#34;</span>,  c4)
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#e6db74>&#34;a &amp;~ b&#34;</span>, c5)
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#e6db74>&#34;hadamard_product(a, b)&#34;</span>, c6)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	{ <span style=color:#75715e>// Submatrix casting square matrices
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// Casting a square matrix to another square matrix with same element type
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// is supported.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// If the cast is to a smaller matrix type, the top-left submatrix is taken.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// If the cast is to a larger matrix type, the matrix is extended with zeros
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// everywhere and ones in the diagonal for the unfilled elements of the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// extended matrix.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		mat2 <span style=color:#f92672>::</span> <span style=color:#66d9ef>distinct</span> matrix[<span style=color:#a6e22e>2</span>, <span style=color:#a6e22e>2</span>]<span style=color:#66d9ef>f32</span>
</span></span><span style=display:flex><span>		mat4 <span style=color:#f92672>::</span> <span style=color:#66d9ef>distinct</span> matrix[<span style=color:#a6e22e>4</span>, <span style=color:#a6e22e>4</span>]<span style=color:#66d9ef>f32</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		m2 <span style=color:#f92672>:=</span> mat2{
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>3</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>2</span>, <span style=color:#a6e22e>4</span>,
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		m4 <span style=color:#f92672>:=</span> mat4(m2)
</span></span><span style=display:flex><span>		assert(m4[<span style=color:#a6e22e>2</span>, <span style=color:#a6e22e>2</span>] <span style=color:#f92672>==</span> <span style=color:#a6e22e>1</span>)
</span></span><span style=display:flex><span>		assert(m4[<span style=color:#a6e22e>3</span>, <span style=color:#a6e22e>3</span>] <span style=color:#f92672>==</span> <span style=color:#a6e22e>1</span>)
</span></span><span style=display:flex><span>		fmt.printf(<span style=color:#e6db74>&#34;m2 %#v\n&#34;</span>, m2)
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#e6db74>&#34;m4&#34;</span>, m4)
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#e6db74>&#34;mat2(m4)&#34;</span>, mat2(m4))
</span></span><span style=display:flex><span>		assert(mat2(m4) <span style=color:#f92672>==</span> m2)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		b4 <span style=color:#f92672>:=</span> mat4{
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>2</span>, <span style=color:#a6e22e>0</span>, <span style=color:#a6e22e>0</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>3</span>, <span style=color:#a6e22e>4</span>, <span style=color:#a6e22e>0</span>, <span style=color:#a6e22e>0</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>5</span>, <span style=color:#a6e22e>0</span>, <span style=color:#a6e22e>6</span>, <span style=color:#a6e22e>0</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>0</span>, <span style=color:#a6e22e>7</span>, <span style=color:#a6e22e>0</span>, <span style=color:#a6e22e>8</span>,
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#e6db74>&#34;b4&#34;</span>, intrinsics.matrix_flatten(b4))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	{ <span style=color:#75715e>// Casting non-square matrices
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// Casting a matrix to another matrix is allowed as long as they share
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// the same element type and the number of elements (rows*columns).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// Matrices in Odin are stored in column-major order, which means
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// the casts will preserve this element order.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		mat2x4 <span style=color:#f92672>::</span> <span style=color:#66d9ef>distinct</span> matrix[<span style=color:#a6e22e>2</span>, <span style=color:#a6e22e>4</span>]<span style=color:#66d9ef>f32</span>
</span></span><span style=display:flex><span>		mat4x2 <span style=color:#f92672>::</span> <span style=color:#66d9ef>distinct</span> matrix[<span style=color:#a6e22e>4</span>, <span style=color:#a6e22e>2</span>]<span style=color:#66d9ef>f32</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		x <span style=color:#f92672>:=</span> mat2x4{
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>1</span>, <span style=color:#a6e22e>3</span>, <span style=color:#a6e22e>5</span>, <span style=color:#a6e22e>7</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>2</span>, <span style=color:#a6e22e>4</span>, <span style=color:#a6e22e>6</span>, <span style=color:#a6e22e>8</span>,
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		y <span style=color:#f92672>:=</span> mat4x2(x)
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#e6db74>&#34;x&#34;</span>, x)
</span></span><span style=display:flex><span>		fmt.println(<span style=color:#e6db74>&#34;y&#34;</span>, y)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// TECHNICAL INFORMATION: the internal representation of a matrix in Odin is stored
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// in column-major format
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// e.g. matrix[2, 3]f32 is internally [3][2]f32 (with different a alignment requirement)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Column-major is used in order to utilize (SIMD) vector instructions effectively on
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// modern hardware, if possible.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Unlike normal arrays, matrices try to maximize alignment to allow for the (SIMD) vectorization
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// properties whilst keeping zero padding (either between columns or at the end of the type).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Zero padding is a compromise for use with third-party libraries, instead of optimizing for performance.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Padding between columns was not taken even if that would have allowed each column to be loaded
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// individually into a SIMD register with the correct alignment properties.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Currently, matrices are limited to a maximum of 16 elements (rows*columns), and a minimum of 1 element.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// This is because matrices are stored as values (not a reference type), and thus operations on them will
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// be stored on the stack. Restricting the maximum element count minimizing the possibility of stack overflows.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// &#39;intrinsics&#39; Procedures (Compiler Level)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 	transpose(m)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//		transposes a matrix
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 	outer_product(a, b)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 		takes two array-like data types and returns the outer product
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//		of the values in a matrix
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 	hadamard_product(a, b)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 		component-wise multiplication of two matrices of the same type
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 	matrix_flatten(m)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//		converts the matrix into a flatten array of elements
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//		in column-major order
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//		Example:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//		m := matrix[2, 2]f32{
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//			x0, x1,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//			y0, y1,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//		}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//		array: [4]f32 = matrix_flatten(m)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//		assert(array == {x0, y0, x1, y1})
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//	conj(x)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//		conjugates the elements of a matrix for complex element types only
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Procedures in &#34;core:math/linalg&#34; and related (Runtime Level) (all square matrix procedures)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 	determinant(m)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 	adjugate(m)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 	inverse(m)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 	inverse_transpose(m)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 	hermitian_adjoint(m)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 	trace(m)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 	matrix_minor(m)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>bit_field_type <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() {
</span></span><span style=display:flex><span>	fmt.println(<span style=color:#e6db74>&#34;\n# bit_field type&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#75715e>// A `bit_field` is a record type in Odin that is akin to a bit-packed struct.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// IMPORTNAT NOTE: `bit_field` is NOT equivalent to `bit_set` as it has different sematics and use cases.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#75715e>// `bit_field` fields are accessed by using a dot:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		Foo <span style=color:#f92672>::</span> bit_field <span style=color:#66d9ef>u16</span> {          <span style=color:#75715e>// backing type must be an integer or array of integers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		    x<span style=color:#f92672>:</span> <span style=color:#66d9ef>i32</span>     <span style=color:#f92672>|</span> <span style=color:#a6e22e>3</span>,             <span style=color:#75715e>// signed integers will be signed extended on use
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		    y<span style=color:#f92672>:</span> <span style=color:#66d9ef>u16</span>     <span style=color:#f92672>|</span> <span style=color:#a6e22e>2</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>3</span>,         <span style=color:#75715e>// general expressions
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		    z<span style=color:#f92672>:</span> My_Enum <span style=color:#f92672>|</span> SOME_CONSTANT, <span style=color:#75715e>// ability to define the bit-width elsewhere
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		    w<span style=color:#f92672>:</span> <span style=color:#66d9ef>bool</span>    <span style=color:#f92672>|</span> <span style=color:#a6e22e>2</span> <span style=color:#66d9ef>when</span> SOME_CONSTANT <span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>10</span> <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>1</span>,
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		v <span style=color:#f92672>:=</span> Foo{}
</span></span><span style=display:flex><span>		v.x <span style=color:#f92672>=</span> <span style=color:#a6e22e>3</span> <span style=color:#75715e>// truncates the value to fit into 3 bits
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		fmt.println(v.x) <span style=color:#75715e>// accessing will convert `v.x` to an `i32` and do an appropriate sign extension
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		My_Enum <span style=color:#f92672>::</span> <span style=color:#66d9ef>enum</span> <span style=color:#66d9ef>u8</span> {A, B, C, D}
</span></span><span style=display:flex><span>		SOME_CONSTANT <span style=color:#f92672>::</span> <span style=color:#a6e22e>7</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#75715e>// A `bit_field` is different from a struct in that you must specify the backing type.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// This backing type must be an integer or a fixed-length array of integers.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// This is useful if there needs to be a specific alignment or access pattern for the record.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		Bar <span style=color:#f92672>::</span> bit_field <span style=color:#66d9ef>u32</span>   {}
</span></span><span style=display:flex><span>		Baz <span style=color:#f92672>::</span> bit_field [<span style=color:#a6e22e>4</span>]<span style=color:#66d9ef>u8</span> {}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// IMPORTANT NOTES:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//  * If _all_ of the fields in a bit_field are 1-bit in size and they are all booleans,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//    please consider using a `bit_set` instead.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//  * Odin&#39;s `bit_field` and C&#39;s bit-fields might not be compatible
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//     * Odin&#39;s `bit_field`s have a well defined layout (Least-Significant-Bit)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//     * C&#39;s bit-fields on `struct`s are undefined and are not portable across targets and compilers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//  * A `bit_field`&#39;s field type can only be one of the following:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//     * Integer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//     * Boolean
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//     * Enum
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>main <span style=color:#f92672>::</span> <span style=color:#66d9ef>proc</span>() {
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>		For More Odin Examples - https://github.com/odin-lang/examples
</span></span></span><span style=display:flex><span><span style=color:#75715e>			This repository contains examples of how certain things can be accomplished
</span></span></span><span style=display:flex><span><span style=color:#75715e>			in idiomatic Odin, allowing you learn its semantics, as well as how to use
</span></span></span><span style=display:flex><span><span style=color:#75715e>			parts of the core and vendor package collections.
</span></span></span><span style=display:flex><span><span style=color:#75715e>	*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>when</span> <span style=color:#66d9ef>true</span> {
</span></span><span style=display:flex><span>		the_basics()
</span></span><span style=display:flex><span>		control_flow()
</span></span><span style=display:flex><span>		named_proc_return_parameters()
</span></span><span style=display:flex><span>		variadic_procedures()
</span></span><span style=display:flex><span>		explicit_procedure_overloading()
</span></span><span style=display:flex><span>		struct_type()
</span></span><span style=display:flex><span>		union_type()
</span></span><span style=display:flex><span>		using_statement()
</span></span><span style=display:flex><span>		implicit_context_system()
</span></span><span style=display:flex><span>		parametric_polymorphism()
</span></span><span style=display:flex><span>		threading_example()
</span></span><span style=display:flex><span>		array_programming()
</span></span><span style=display:flex><span>		map_type()
</span></span><span style=display:flex><span>		implicit_selector_expression()
</span></span><span style=display:flex><span>		partial_switch()
</span></span><span style=display:flex><span>		cstring_example()
</span></span><span style=display:flex><span>		bit_set_type()
</span></span><span style=display:flex><span>		deferred_procedure_associations()
</span></span><span style=display:flex><span>		reflection()
</span></span><span style=display:flex><span>		quaternions()
</span></span><span style=display:flex><span>		unroll_for_statement()
</span></span><span style=display:flex><span>		where_clauses()
</span></span><span style=display:flex><span>		foreign_system()
</span></span><span style=display:flex><span>		ranged_fields_for_array_compound_literals()
</span></span><span style=display:flex><span>		deprecated_attribute()
</span></span><span style=display:flex><span>		range_statements_with_multiple_return_values()
</span></span><span style=display:flex><span>		soa_struct_layout()
</span></span><span style=display:flex><span>		constant_literal_expressions()
</span></span><span style=display:flex><span>		union_maybe()
</span></span><span style=display:flex><span>		explicit_context_definition()
</span></span><span style=display:flex><span>		or_else_operator()
</span></span><span style=display:flex><span>		or_return_operator()
</span></span><span style=display:flex><span>		or_break_and_or_continue_operators()
</span></span><span style=display:flex><span>		arbitrary_precision_mathematics()
</span></span><span style=display:flex><span>		matrix_type()
</span></span><span style=display:flex><span>		bit_field_type()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></article></div></div></main><footer class=odin-footer><div class="container pb-5 pt-5"><div class="row g-4"><div class=col><a class=navbar-brand href=/><img class=mb-3 src=/logo.svg height=30 alt=Odin></a><p>The Data-Oriented Language for Sane Software Development.</p></div><nav class=col-md-auto><h4 class=fw-normal>Resources</h4><ul class=list-unstyled><li><a href=/docs class=link-light>Docs</a></li><li><a href=https://pkg.odin-lang.org/ class=link-light>Packages</a></li><li><a href=/news class=link-light>News</a></li></ul></nav><nav class=col-md-auto><h4 class=fw-normal>Community</h4><ul class=list-unstyled><li><a href=https://github.com/odin-lang/Odin target=_blank class=link-light>GitHub</a></li><li><a href=https://discord.gg/vafXTdubwr target=_blank class=link-light>Discord</a></li><li><a href=https://www.twitch.tv/ginger_bill target=_blank class=link-light>Twitch</a></li><li><a href=https://www.youtube.com/channel/UCUSck1dOH7VKmG4lRW7tZXg target=_blank class=link-light>YouTube</a></li><li><a href=/showcase target=_blank class=link-light>Showcase</a></li></ul></nav><nav class=col-md-auto><h4 class=fw-normal>Contribute</h4><ul class=list-unstyled><li><a href=https://github.com/odin-lang/Odin/issues target=_blank class=link-light>Issues</a></li><li><a href=https://www.patreon.com/gingerbill target=_blank class=link-light>Donate</a></li></ul></nav></div><div class="mt-4 text-muted">© 2016–2024 Ginger Bill</div></div></footer><script src=/lib/bootstrap/js/bootstrap.min.js></script><script src=/js/script.js></script></body></html>